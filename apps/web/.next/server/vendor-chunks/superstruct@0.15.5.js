"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/superstruct@0.15.5";
exports.ids = ["vendor-chunks/superstruct@0.15.5"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : \"At path: \" + path.join(\".\") + \" -- \" + message;\n        super(msg);\n        this.value = void 0;\n        this.key = void 0;\n        this.type = void 0;\n        this.refinement = void 0;\n        this.path = void 0;\n        this.branch = void 0;\n        this.failures = void 0;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            var _cached;\n            return (_cached = cached) != null ? _cached : cached = [\n                failure,\n                ...failures()\n            ];\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    return typeof value === \"string\" ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : \"\") + \", but received: `\" + print(value) + \"`\" } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let valid = true;\n    for (const failure of struct.validator(value, ctx)){\n        valid = false;\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask\n        });\n        for (const t of ts){\n            if (t[0]) {\n                valid = false;\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    value[k] = v;\n                }\n            }\n        }\n    }\n    if (valid) {\n        for (const failure of struct.refiner(value, ctx)){\n            valid = false;\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (valid) {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        this.TYPE = void 0;\n        this.type = void 0;\n        this.schema = void 0;\n        this.coercer = void 0;\n        this.validator = void 0;\n        this.refiner = void 0;\n        this.entries = void 0;\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */ assert(value) {\n        return assert(value, this);\n    }\n    /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */ create(value) {\n        return create(value, this);\n    }\n    /**\n   * Check if a value passes the struct's validation.\n   */ is(value) {\n        return is(value, this);\n    }\n    /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */ mask(value) {\n        return mask(value, this);\n    }\n    /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */ validate(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct) {\n    const result = validate(value, struct);\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign() {\n    for(var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++){\n        Structs[_key] = arguments[_key];\n    }\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            var _struct;\n            (_struct = struct) != null ? _struct : struct = fn();\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            var _struct2;\n            (_struct2 = struct) != null ? _struct2 : struct = fn();\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            var _struct3;\n            (_struct3 = struct) != null ? _struct3 : struct = fn();\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            var _struct4;\n            (_struct4 = struct) != null ? _struct4 : struct = fn();\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || \"Expected a function, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || \"Expected a string, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            const firstMatch = Structs.find((s)=>{\n                const [e] = s.validate(value, {\n                    coerce: true\n                });\n                return !e;\n            }) || unknown();\n            return firstMatch.coercer(value, ctx);\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                \"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value),\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + '/` but received \"' + value + '\"';\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max) {\n    if (max === void 0) {\n        max = min;\n    }\n    const expected = \"Expected a \" + struct.type;\n    const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJzdHJ1Y3RAMC4xNS41L25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsb0JBQW9CQztJQUN4QkMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsSUFBSUM7UUFDSixNQUFNLEVBQ0pDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdKO1FBQ0osTUFBTSxFQUNKSyxJQUFJLEVBQ0wsR0FBR0w7UUFDSixNQUFNTSxNQUFNRCxLQUFLRSxNQUFNLEtBQUssSUFBSUosVUFBVSxjQUFjRSxLQUFLRyxJQUFJLENBQUMsT0FBTyxTQUFTTDtRQUNsRixLQUFLLENBQUNHO1FBQ04sSUFBSSxDQUFDRyxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNDLEdBQUcsR0FBRyxLQUFLO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEtBQUs7UUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsS0FBSztRQUN2QixJQUFJLENBQUNQLElBQUksR0FBRyxLQUFLO1FBQ2pCLElBQUksQ0FBQ1EsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDWixRQUFRLEdBQUcsS0FBSztRQUNyQmEsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVg7UUFDcEIsSUFBSSxDQUFDWSxJQUFJLEdBQUcsSUFBSSxDQUFDakIsV0FBVyxDQUFDaUIsSUFBSTtRQUVqQyxJQUFJLENBQUNmLFFBQVEsR0FBRztZQUNkLElBQUlnQjtZQUVKLE9BQU8sQ0FBQ0EsVUFBVWYsTUFBSyxLQUFNLE9BQU9lLFVBQVVmLFNBQVM7Z0JBQUNGO21CQUFZQzthQUFXO1FBQ2pGO0lBQ0Y7QUFFRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2lCLFdBQVdD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QU90SCxRQUFRLFFBQVE5QixDQUFBQTtRQUM1QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsaUJBQWlCbUcsTUFBTTtZQUN0RCxPQUFPc0QsT0FBT3pKLFNBQVNBLFNBQVNrSSxPQUFPNEIsV0FBVyxNQUFNQyxLQUFLLG9CQUFvQi9KLFFBQVE7UUFDM0YsT0FBTyxJQUFJQSxpQkFBaUJrRCxPQUFPbEQsaUJBQWlCb0QsS0FBSztZQUN2RCxNQUFNLEVBQ0ppRyxJQUFJLEVBQ0wsR0FBR3JKO1lBQ0osT0FBT3lKLE9BQU9KLFFBQVFBLFFBQVFuQixPQUFPNEIsV0FBVyxrQkFBa0JDLEtBQUssdUNBQXVDVixPQUFPO1FBQ3ZILE9BQU87WUFDTCxNQUFNLEVBQ0p2SixNQUFNLEVBQ1AsR0FBR0U7WUFDSixPQUFPeUosT0FBTzNKLFVBQVVBLFVBQVVvSSxPQUFPNEIsV0FBVyxvQkFBb0JDLEtBQUsseUNBQXlDakssU0FBUztRQUNqSTtJQUNGO0FBQ0Y7QUFDQTs7Ozs7O0NBTUMsR0FFRCxTQUFTc0osT0FBT3RILE1BQU0sRUFBRXZCLElBQUksRUFBRStDLE9BQU87SUFDbkMsT0FBTyxJQUFJQyxPQUFPO1FBQUUsR0FBR3pCLE1BQU07UUFFM0IsQ0FBQ3dCLFNBQVF0RCxLQUFLLEVBQUVxQyxHQUFHO1lBQ2pCLE9BQU9QLE9BQU93QixPQUFPLENBQUN0RCxPQUFPcUM7WUFDN0IsTUFBTVQsU0FBUzBCLFFBQVF0RCxPQUFPcUM7WUFDOUIsTUFBTTdDLFdBQVd1QyxXQUFXSCxRQUFRUyxLQUFLUCxRQUFROUI7WUFFakQsS0FBSyxNQUFNVCxXQUFXQyxTQUFVO2dCQUM5QixNQUFNO29CQUFFLEdBQUdELE9BQU87b0JBQ2hCWSxZQUFZSTtnQkFDZDtZQUNGO1FBQ0Y7SUFFRjtBQUNGO0FBRTZaLENBQzdaLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyc3RydWN0QDAuMTUuNS9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzPzEzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gbG9naWMgaXMgZGVzaWduIHRvIGV4aXQgZWFybHkgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UuIFRoZSBlcnJvclxuICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICogY29udGludWUgdmFsaWRhdGlvbiBhbmQgcmVjZWl2ZSBhbGwgdGhlIGZhaWx1cmVzIGluIHRoZSBkYXRhLlxuICovXG5jbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgbGV0IGNhY2hlZDtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhcbiAgICB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBcIkF0IHBhdGg6IFwiICsgcGF0aC5qb2luKCcuJykgKyBcIiAtLSBcIiArIG1lc3NhZ2U7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZmluZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYnJhbmNoID0gdm9pZCAwO1xuICAgIHRoaXMuZmFpbHVyZXMgPSB2b2lkIDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgdmFyIF9jYWNoZWQ7XG5cbiAgICAgIHJldHVybiAoX2NhY2hlZCA9IGNhY2hlZCkgIT0gbnVsbCA/IF9jYWNoZWQgOiBjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV07XG4gICAgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuLyoqXG4gKiBSZXR1cm4gYSB2YWx1ZSBhcyBhIHByaW50YWJsZSBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBcIlwiICsgdmFsdWU7XG59XG4vKipcbiAqIFNoaWZ0cyAocmVtb3ZlcyBhbmQgcmV0dXJucykgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICovXG5cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgY29uc3Qge1xuICAgIGRvbmUsXG4gICAgdmFsdWVcbiAgfSA9IGlucHV0Lm5leHQoKTtcbiAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gKi9cblxuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHtcbiAgICAgIG1lc3NhZ2U6IHJlc3VsdFxuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgcGF0aCxcbiAgICBicmFuY2hcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICB0eXBlXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHtcbiAgICByZWZpbmVtZW50LFxuICAgIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBgXCIgKyB0eXBlICsgXCJgXCIgKyAocmVmaW5lbWVudCA/IFwiIHdpdGggcmVmaW5lbWVudCBgXCIgKyByZWZpbmVtZW50ICsgXCJgXCIgOiAnJykgKyBcIiwgYnV0IHJlY2VpdmVkOiBgXCIgKyBwcmludCh2YWx1ZSkgKyBcImBcIlxuICB9ID0gcmVzdWx0O1xuICByZXR1cm4ge1xuICAgIHZhbHVlLFxuICAgIHR5cGUsXG4gICAgcmVmaW5lbWVudCxcbiAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICBwYXRoLFxuICAgIGJyYW5jaCxcbiAgICAuLi5yZXN1bHQsXG4gICAgbWVzc2FnZVxuICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gKi9cblxuZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gIH1cblxuICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZShyLCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcblxuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICB5aWVsZCBmYWlsdXJlO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqL1xuXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoID0gW10sXG4gICAgYnJhbmNoID0gW3ZhbHVlXSxcbiAgICBjb2VyY2UgPSBmYWxzZSxcbiAgICBtYXNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9O1xuXG4gIGlmIChjb2VyY2UpIHtcbiAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuXG4gICAgaWYgKG1hc2sgJiYgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJiBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIFt0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdiA9IHRbMV07XG5cbiAgICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICB5aWVsZCBbdW5kZWZpbmVkLCB2YWx1ZV07XG4gIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5cbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5UWVBFID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVtYSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZXJjZXIgPSB2b2lkIDA7XG4gICAgdGhpcy52YWxpZGF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZW50cmllcyA9IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdmFsaWRhdG9yLFxuICAgICAgcmVmaW5lcixcbiAgICAgIGNvZXJjZXIgPSB2YWx1ZSA9PiB2YWx1ZSxcbiAgICAgIGVudHJpZXMgPSBmdW5jdGlvbiogKCkge31cbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG5cbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgfVxuXG4gICAgaWYgKHJlZmluZXIpIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgKi9cblxuXG4gIGFzc2VydCh2YWx1ZSkge1xuICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyBjb2VyY2lvbiBsb2dpYywgdGhlbiB2YWxpZGF0ZSBpdC5cbiAgICovXG5cblxuICBjcmVhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAqL1xuXG5cbiAgaXModmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICovXG5cblxuICBtYXNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuXG5cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG59XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7XG4gICAgY29lcmNlOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICovXG5cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7XG4gICAgY29lcmNlOiB0cnVlLFxuICAgIG1hc2s6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5cbmZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gIHJldHVybiAhcmVzdWx0WzBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAqIHZhbHVlICh3aXRoIHBvdGVudGlhbCBjb2VyY2lvbikgaWYgdmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcblxuICBpZiAodHVwbGVbMF0pIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIFN0cnVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgU3RydWN0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnO1xuICBjb25zdCBzY2hlbWFzID0gU3RydWN0cy5tYXAocyA9PiBzLnNjaGVtYSk7XG4gIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogbmFtZSxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgdmFsaWRhdG9yXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGVkKHN0cnVjdCwgbG9nKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAqIHZhbGlkYXRpb24gbG9naWMgdGhhdCBjaGFuZ2VzIGJhc2VkIG9uIGl0cyBpbnB1dC5cbiAqL1xuXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKi9cblxuZnVuY3Rpb24gbGF6eShmbikge1xuICBsZXQgc3RydWN0O1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xhenknLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0O1xuXG4gICAgICAoX3N0cnVjdCA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3QyO1xuXG4gICAgICAoX3N0cnVjdDIgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0MiA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDM7XG5cbiAgICAgIChfc3RydWN0MyA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QzIDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDQ7XG5cbiAgICAgIChfc3RydWN0NCA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3Q0IDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICBjb25zdCB7XG4gICAgc2NoZW1hXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hXG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IHdpdGggYWxsIG9mIGl0c1xuICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQYXJ0aWFsYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYVxuICB9IDogeyAuLi5zdHJ1Y3RcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWFba2V5XSA9IG9wdGlvbmFsKHNjaGVtYVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RydWN0KG5hbWUsIHZhbGlkYXRvcikge1xuICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cblxuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5cbmZ1bmN0aW9uIGRhdGUoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2RhdGUnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSB8fCBcIkV4cGVjdGVkIGEgdmFsaWQgYERhdGVgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgY29uc3Qgc2NoZW1hID0ge307XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCh2ID0+IHByaW50KHYpKS5qb2luKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8IFwiRXhwZWN0ZWQgb25lIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBcIkV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHwgXCJFeHBlY3RlZCBhIGBcIiArIENsYXNzLm5hbWUgKyBcImAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICp2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWwoY29uc3RhbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gY29uc3RhbnQgfHwgXCJFeHBlY3RlZCB0aGUgbGl0ZXJhbCBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ21hcCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCBcIkV4cGVjdGVkIGEgYE1hcGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICovXG5cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnbnVtYmVyJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChzY2hlbWEgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVua25vd25zKSB7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWVcbiAgICAgIH0gOiB2YWx1ZTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIG9mIHNwZWNpZmljIHR5cGVzLCBidXRcbiAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFJlY29yZGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3JlY29yZCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICpcbiAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdGVzdCB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uISBGb3IgdGhhdFxuICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXQoRWxlbWVudCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3NldCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fCBcIkV4cGVjdGVkIGEgYFNldGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3N0cmluZycsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBcIkV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICogZWxlbWVudHMgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R1cGxlJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0eXBlJyxcbiAgICBzY2hlbWEsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcChzID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndW5pb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9IFN0cnVjdHMuZmluZChzID0+IHtcbiAgICAgICAgY29uc3QgW2VdID0gcy52YWxpZGF0ZSh2YWx1ZSwge1xuICAgICAgICAgIGNvZXJjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICFlO1xuICAgICAgfSkgfHwgdW5rbm93bigpO1xuICAgICAgcmV0dXJuIGZpcnN0TWF0Y2guY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuXG4gICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1wiRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKSwgLi4uZmFpbHVyZXNdO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKSA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eCkgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCB4ID0+IHtcbiAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueFxuICAgICAgfTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCB4ID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgdmFsdWUgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICByZXR1cm4gc2l6ZSA9PT0gMCB8fCBcIkV4cGVjdGVkIGFuIGVtcHR5IFwiICsgc3RydWN0LnR5cGUgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICovXG5cblxuZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPCB0aHJlc2hvbGQgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBsZXNzIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cblxuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPiB0aHJlc2hvbGQgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBncmVhdGVyIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKi9cblxuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnbm9uZW1wdHknLCB2YWx1ZSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgIHJldHVybiBzaXplID4gMCB8fCBcIkV4cGVjdGVkIGEgbm9uZW1wdHkgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cblxuZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIG1hdGNoaW5nIGAvXCIgKyByZWdleHAuc291cmNlICsgXCIvYCBidXQgcmVjZWl2ZWQgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB2b2lkIDApIHtcbiAgICBtYXggPSBtaW47XG4gIH1cblxuICBjb25zdCBleHBlY3RlZCA9IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlO1xuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gXCJvZiBgXCIgKyBtaW4gKyBcImBcIiA6IFwiYmV0d2VlbiBgXCIgKyBtaW4gKyBcImAgYW5kIGBcIiArIG1heCArIFwiYFwiO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpemVcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIHdpdGggYSBzaXplIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgbGVuZ3RoIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgYFwiICsgbGVuZ3RoICsgXCJgXCI7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKi9cblxuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLFxuICAgICAgICAgIHJlZmluZW1lbnQ6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBiaWdpbnQsIGJvb2xlYW4sIGNvZXJjZSwgY3JlYXRlLCBkYXRlLCBkZWZhdWx0ZWQsIGRlZmluZSwgZGVwcmVjYXRlZCwgZHluYW1pYywgZW1wdHksIGVudW1zLCBmdW5jLCBpbnN0YW5jZSwgaW50ZWdlciwgaW50ZXJzZWN0aW9uLCBpcywgbGF6eSwgbGl0ZXJhbCwgbWFwLCBtYXNrLCBtYXgsIG1pbiwgbmV2ZXIsIG5vbmVtcHR5LCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJTdHJ1Y3RFcnJvciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiZmFpbHVyZSIsImZhaWx1cmVzIiwiY2FjaGVkIiwibWVzc2FnZSIsInJlc3QiLCJwYXRoIiwibXNnIiwibGVuZ3RoIiwiam9pbiIsInZhbHVlIiwia2V5IiwidHlwZSIsInJlZmluZW1lbnQiLCJicmFuY2giLCJPYmplY3QiLCJhc3NpZ24iLCJuYW1lIiwiX2NhY2hlZCIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInNoaWZ0SXRlcmF0b3IiLCJpbnB1dCIsImRvbmUiLCJuZXh0IiwidW5kZWZpbmVkIiwidG9GYWlsdXJlIiwicmVzdWx0IiwiY29udGV4dCIsInN0cnVjdCIsInRvRmFpbHVyZXMiLCJyIiwicnVuIiwib3B0aW9ucyIsImNvZXJjZSIsIm1hc2siLCJjdHgiLCJjb2VyY2VyIiwic2NoZW1hIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWQiLCJ2YWxpZGF0b3IiLCJrIiwidiIsInMiLCJlbnRyaWVzIiwidHMiLCJ0IiwiTWFwIiwic2V0IiwiU2V0IiwiYWRkIiwicmVmaW5lciIsIlN0cnVjdCIsInByb3BzIiwiVFlQRSIsImFzc2VydCIsImNyZWF0ZSIsImlzIiwidmFsaWRhdGUiLCJ0dXBsZXMiLCJ0dXBsZSIsImVycm9yIiwiX2xlbiIsImFyZ3VtZW50cyIsIlN0cnVjdHMiLCJfa2V5IiwiaXNUeXBlIiwic2NoZW1hcyIsIm1hcCIsIm9iamVjdCIsImRlZmluZSIsImRlcHJlY2F0ZWQiLCJsb2ciLCJkeW5hbWljIiwiZm4iLCJsYXp5IiwiX3N0cnVjdCIsIl9zdHJ1Y3QyIiwiX3N0cnVjdDMiLCJfc3RydWN0NCIsIm9taXQiLCJrZXlzIiwic3Vic2NoZW1hIiwicGFydGlhbCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJyZWNvcmQiLCJyZWdleHAiLCJSZWdFeHAiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwidW5pb24iLCJmaXJzdE1hdGNoIiwiZmluZCIsImUiLCJ1bmtub3duIiwiZmlyc3QiLCJwdXNoIiwiY29uZGl0aW9uIiwiZGVmYXVsdGVkIiwiZmFsbGJhY2siLCJmIiwic3RyaWN0IiwicmV0IiwiY2hhbmdlZCIsInRyaW1tZWQiLCJ0cmltIiwiZW1wdHkiLCJyZWZpbmUiLCJzaXplIiwiZ2V0U2l6ZSIsInRocmVzaG9sZCIsImV4Y2x1c2l2ZSIsIm1pbiIsIm5vbmVtcHR5IiwicGF0dGVybiIsInRlc3QiLCJzb3VyY2UiLCJleHBlY3RlZCIsIm9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: () => (/* binding */ Struct),\n/* harmony export */   StructError: () => (/* binding */ StructError),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   assign: () => (/* binding */ assign),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   coerce: () => (/* binding */ coerce),\n/* harmony export */   create: () => (/* binding */ create),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   defaulted: () => (/* binding */ defaulted),\n/* harmony export */   define: () => (/* binding */ define),\n/* harmony export */   deprecated: () => (/* binding */ deprecated),\n/* harmony export */   dynamic: () => (/* binding */ dynamic),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   enums: () => (/* binding */ enums),\n/* harmony export */   func: () => (/* binding */ func),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersection: () => (/* binding */ intersection),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mask: () => (/* binding */ mask),\n/* harmony export */   max: () => (/* binding */ max),\n/* harmony export */   min: () => (/* binding */ min),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonempty: () => (/* binding */ nonempty),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   pattern: () => (/* binding */ pattern),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   refine: () => (/* binding */ refine),\n/* harmony export */   regexp: () => (/* binding */ regexp),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   struct: () => (/* binding */ struct),\n/* harmony export */   trimmed: () => (/* binding */ trimmed),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */ /**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */ class StructError extends TypeError {\n    constructor(failure, failures){\n        let cached;\n        const { message, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : \"At path: \" + path.join(\".\") + \" -- \" + message;\n        super(msg);\n        this.value = void 0;\n        this.key = void 0;\n        this.type = void 0;\n        this.refinement = void 0;\n        this.path = void 0;\n        this.branch = void 0;\n        this.failures = void 0;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = ()=>{\n            var _cached;\n            return (_cached = cached) != null ? _cached : cached = [\n                failure,\n                ...failures()\n            ];\n        };\n    }\n}\n/**\n * Check if a value is an iterator.\n */ function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n}\n/**\n * Check if a value is a plain object.\n */ function isObject(x) {\n    return typeof x === \"object\" && x != null;\n}\n/**\n * Check if a value is a plain object.\n */ function isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */ function print(value) {\n    return typeof value === \"string\" ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */ function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */ function toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    } else if (result === false) {\n        result = {};\n    } else if (typeof result === \"string\") {\n        result = {\n            message: result\n        };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : \"\") + \", but received: `\" + print(value) + \"`\" } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */ function* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [\n            result\n        ];\n    }\n    for (const r of result){\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */ function* run(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { path = [], branch = [\n        value\n    ], coerce = false, mask = false } = options;\n    const ctx = {\n        path,\n        branch\n    };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n        if (mask && struct.type !== \"type\" && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n            for(const key in value){\n                if (struct.schema[key] === undefined) {\n                    delete value[key];\n                }\n            }\n        }\n    }\n    let valid = true;\n    for (const failure of struct.validator(value, ctx)){\n        valid = false;\n        yield [\n            failure,\n            undefined\n        ];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)){\n        const ts = run(v, s, {\n            path: k === undefined ? path : [\n                ...path,\n                k\n            ],\n            branch: k === undefined ? branch : [\n                ...branch,\n                v\n            ],\n            coerce,\n            mask\n        });\n        for (const t of ts){\n            if (t[0]) {\n                valid = false;\n                yield [\n                    t[0],\n                    undefined\n                ];\n            } else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                } else if (value instanceof Map) {\n                    value.set(k, v);\n                } else if (value instanceof Set) {\n                    value.add(v);\n                } else if (isObject(value)) {\n                    value[k] = v;\n                }\n            }\n        }\n    }\n    if (valid) {\n        for (const failure of struct.refiner(value, ctx)){\n            valid = false;\n            yield [\n                failure,\n                undefined\n            ];\n        }\n    }\n    if (valid) {\n        yield [\n            undefined,\n            value\n        ];\n    }\n}\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */ class Struct {\n    constructor(props){\n        this.TYPE = void 0;\n        this.type = void 0;\n        this.schema = void 0;\n        this.coercer = void 0;\n        this.validator = void 0;\n        this.refiner = void 0;\n        this.entries = void 0;\n        const { type, schema, validator, refiner, coercer = (value)=>value, entries = function*() {} } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context)=>{\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.validator = ()=>[];\n        }\n        if (refiner) {\n            this.refiner = (value, context)=>{\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        } else {\n            this.refiner = ()=>[];\n        }\n    }\n    /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */ assert(value) {\n        return assert(value, this);\n    }\n    /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */ create(value) {\n        return create(value, this);\n    }\n    /**\n   * Check if a value passes the struct's validation.\n   */ is(value) {\n        return is(value, this);\n    }\n    /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */ mask(value) {\n        return mask(value, this);\n    }\n    /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */ validate(value, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */ function assert(value, struct) {\n    const result = validate(value, struct);\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */ function create(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */ function mask(value, struct) {\n    const result = validate(value, struct, {\n        coerce: true,\n        mask: true\n    });\n    if (result[0]) {\n        throw result[0];\n    } else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */ function is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */ function validate(value, struct, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function*() {\n            for (const t of tuples){\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [\n            error,\n            undefined\n        ];\n    } else {\n        const v = tuple[1];\n        return [\n            undefined,\n            v\n        ];\n    }\n}\nfunction assign() {\n    for(var _len = arguments.length, Structs = new Array(_len), _key = 0; _key < _len; _key++){\n        Structs[_key] = arguments[_key];\n    }\n    const isType = Structs[0].type === \"type\";\n    const schemas = Structs.map((s)=>s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */ function define(name, validator) {\n    return new Struct({\n        type: name,\n        schema: null,\n        validator\n    });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */ function deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx),\n        validator (value, ctx) {\n            if (value === undefined) {\n                return true;\n            } else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        }\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */ function dynamic(fn) {\n    return new Struct({\n        type: \"dynamic\",\n        schema: null,\n        *entries (value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */ function lazy(fn) {\n    let struct;\n    return new Struct({\n        type: \"lazy\",\n        schema: null,\n        *entries (value, ctx) {\n            var _struct;\n            (_struct = struct) != null ? _struct : struct = fn();\n            yield* struct.entries(value, ctx);\n        },\n        validator (value, ctx) {\n            var _struct2;\n            (_struct2 = struct) != null ? _struct2 : struct = fn();\n            return struct.validator(value, ctx);\n        },\n        coercer (value, ctx) {\n            var _struct3;\n            (_struct3 = struct) != null ? _struct3 : struct = fn();\n            return struct.coercer(value, ctx);\n        },\n        refiner (value, ctx) {\n            var _struct4;\n            (_struct4 = struct) != null ? _struct4 : struct = fn();\n            return struct.refiner(value, ctx);\n        }\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */ function omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = {\n        ...schema\n    };\n    for (const key of keys){\n        delete subschema[key];\n    }\n    switch(struct.type){\n        case \"type\":\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */ function partial(struct) {\n    const schema = struct instanceof Struct ? {\n        ...struct.schema\n    } : {\n        ...struct\n    };\n    for(const key in schema){\n        schema[key] = optional(schema[key]);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */ function pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys){\n        subschema[key] = schema[key];\n    }\n    return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */ function struct(name, validator) {\n    console.warn(\"superstruct@0.11 - The `struct` helper has been renamed to `define`.\");\n    return define(name, validator);\n}\n/**\n * Ensure that any value passes validation.\n */ function any() {\n    return define(\"any\", ()=>true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: \"array\",\n        schema: Element,\n        *entries (value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()){\n                    yield [\n                        i,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */ function bigint() {\n    return define(\"bigint\", (value)=>{\n        return typeof value === \"bigint\";\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */ function boolean() {\n    return define(\"boolean\", (value)=>{\n        return typeof value === \"boolean\";\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */ function date() {\n    return define(\"date\", (value)=>{\n        return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v)=>print(v)).join();\n    for (const key of values){\n        schema[key] = key;\n    }\n    return new Struct({\n        type: \"enums\",\n        schema,\n        validator (value) {\n            return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a function.\n */ function func() {\n    return define(\"func\", (value)=>{\n        return typeof value === \"function\" || \"Expected a function, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */ function instance(Class) {\n    return define(\"instance\", (value)=>{\n        return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */ function integer() {\n    return define(\"integer\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */ function intersection(Structs) {\n    return new Struct({\n        type: \"intersection\",\n        schema: null,\n        *entries (value, ctx) {\n            for (const S of Structs){\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator (value, ctx) {\n            for (const S of Structs){\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner (value, ctx) {\n            for (const S of Structs){\n                yield* S.refiner(value, ctx);\n            }\n        }\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: \"literal\",\n        schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n        validator (value) {\n            return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n        }\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: \"map\",\n        schema: null,\n        *entries (value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()){\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator (value) {\n            return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */ function never() {\n    return define(\"never\", ()=>false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */ function nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === null || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === null || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is a number.\n */ function number() {\n    return define(\"number\", (value)=>{\n        return typeof value === \"number\" && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: \"object\",\n        schema: schema ? schema : null,\n        *entries (value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns){\n                    unknowns.delete(key);\n                    yield [\n                        key,\n                        value[key],\n                        schema[key]\n                    ];\n                }\n                for (const key of unknowns){\n                    yield [\n                        key,\n                        value[key],\n                        Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        },\n        coercer (value) {\n            return isObject(value) ? {\n                ...value\n            } : value;\n        }\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */ function optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx)=>value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx)=>value === undefined || struct.refiner(value, ctx)\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */ function record(Key, Value) {\n    return new Struct({\n        type: \"record\",\n        schema: null,\n        *entries (value) {\n            if (isObject(value)) {\n                for(const k in value){\n                    const v = value[k];\n                    yield [\n                        k,\n                        k,\n                        Key\n                    ];\n                    yield [\n                        k,\n                        v,\n                        Value\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */ function regexp() {\n    return define(\"regexp\", (value)=>{\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: \"set\",\n        schema: null,\n        *entries (value) {\n            if (Element && value instanceof Set) {\n                for (const v of value){\n                    yield [\n                        v,\n                        v,\n                        Element\n                    ];\n                }\n            }\n        },\n        coercer (value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator (value) {\n            return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value is a string.\n */ function string() {\n    return define(\"string\", (value)=>{\n        return typeof value === \"string\" || \"Expected a string, but received: \" + print(value);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */ function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: \"tuple\",\n        schema: null,\n        *entries (value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for(let i = 0; i < length; i++){\n                    yield [\n                        i,\n                        value[i],\n                        Structs[i] || Never\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */ function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: \"type\",\n        schema,\n        *entries (value) {\n            if (isObject(value)) {\n                for (const k of keys){\n                    yield [\n                        k,\n                        value[k],\n                        schema[k]\n                    ];\n                }\n            }\n        },\n        validator (value) {\n            return isObject(value) || \"Expected an object, but received: \" + print(value);\n        }\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */ function union(Structs) {\n    const description = Structs.map((s)=>s.type).join(\" | \");\n    return new Struct({\n        type: \"union\",\n        schema: null,\n        coercer (value, ctx) {\n            const firstMatch = Structs.find((s)=>{\n                const [e] = s.validate(value, {\n                    coerce: true\n                });\n                return !e;\n            }) || unknown();\n            return firstMatch.coercer(value, ctx);\n        },\n        validator (value, ctx) {\n            const failures = [];\n            for (const S of Structs){\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                } else {\n                    for (const [failure] of tuples){\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                \"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value),\n                ...failures\n            ];\n        }\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */ function unknown() {\n    return define(\"unknown\", ()=>true);\n}\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationâ€”for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx)=>{\n            return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n        }\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function defaulted(struct, fallback, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    return coerce(struct, unknown(), (x)=>{\n        const f = typeof fallback === \"function\" ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = {\n                ...x\n            };\n            let changed = false;\n            for(const key in f){\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */ function trimmed(struct) {\n    return coerce(struct, string(), (x)=>x.trim());\n}\n/**\n * Ensure that a string, array, map, or set is empty.\n */ function empty(struct) {\n    return refine(struct, \"empty\", (value)=>{\n        const size = getSize(value);\n        return size === 0 || \"Expected an empty \" + struct.type + \" but received one with a size of `\" + size + \"`\";\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    } else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */ function max(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"max\", (value)=>{\n        return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" less than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */ function min(struct, threshold, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    const { exclusive } = options;\n    return refine(struct, \"min\", (value)=>{\n        return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? \"\" : \"or equal to \") + threshold + \" but received `\" + value + \"`\";\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */ function nonempty(struct) {\n    return refine(struct, \"nonempty\", (value)=>{\n        const size = getSize(value);\n        return size > 0 || \"Expected a nonempty \" + struct.type + \" but received an empty one\";\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */ function pattern(struct, regexp) {\n    return refine(struct, \"pattern\", (value)=>{\n        return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + '/` but received \"' + value + '\"';\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */ function size(struct, min, max) {\n    if (max === void 0) {\n        max = min;\n    }\n    const expected = \"Expected a \" + struct.type;\n    const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n    return refine(struct, \"size\", (value)=>{\n        if (typeof value === \"number\" || value instanceof Date) {\n            return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n        } else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n        } else {\n            const { length } = value;\n            return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */ function refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner (value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures){\n                yield {\n                    ...failure,\n                    refinement: name\n                };\n            }\n        }\n    });\n}\n //# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc3VwZXJzdHJ1Y3RAMC4xNS41L25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0NBRUMsR0FFRDs7Ozs7OztDQU9DLEdBQ0QsTUFBTUEsb0JBQW9CQztJQUN4QkMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsSUFBSUM7UUFDSixNQUFNLEVBQ0pDLE9BQU8sRUFDUCxHQUFHQyxNQUNKLEdBQUdKO1FBQ0osTUFBTSxFQUNKSyxJQUFJLEVBQ0wsR0FBR0w7UUFDSixNQUFNTSxNQUFNRCxLQUFLRSxNQUFNLEtBQUssSUFBSUosVUFBVSxjQUFjRSxLQUFLRyxJQUFJLENBQUMsT0FBTyxTQUFTTDtRQUNsRixLQUFLLENBQUNHO1FBQ04sSUFBSSxDQUFDRyxLQUFLLEdBQUcsS0FBSztRQUNsQixJQUFJLENBQUNDLEdBQUcsR0FBRyxLQUFLO1FBQ2hCLElBQUksQ0FBQ0MsSUFBSSxHQUFHLEtBQUs7UUFDakIsSUFBSSxDQUFDQyxVQUFVLEdBQUcsS0FBSztRQUN2QixJQUFJLENBQUNQLElBQUksR0FBRyxLQUFLO1FBQ2pCLElBQUksQ0FBQ1EsTUFBTSxHQUFHLEtBQUs7UUFDbkIsSUFBSSxDQUFDWixRQUFRLEdBQUcsS0FBSztRQUNyQmEsT0FBT0MsTUFBTSxDQUFDLElBQUksRUFBRVg7UUFDcEIsSUFBSSxDQUFDWSxJQUFJLEdBQUcsSUFBSSxDQUFDakIsV0FBVyxDQUFDaUIsSUFBSTtRQUVqQyxJQUFJLENBQUNmLFFBQVEsR0FBRztZQUNkLElBQUlnQjtZQUVKLE9BQU8sQ0FBQ0EsVUFBVWYsTUFBSyxLQUFNLE9BQU9lLFVBQVVmLFNBQVM7Z0JBQUNGO21CQUFZQzthQUFXO1FBQ2pGO0lBQ0Y7QUFFRjtBQUVBOztDQUVDLEdBQ0QsU0FBU2lCLFdBQVdD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QU90SCxRQUFRLFFBQVE5QixDQUFBQTtRQUM1QixJQUFJLE9BQU9BLFVBQVUsWUFBWUEsaUJBQWlCbUcsTUFBTTtZQUN0RCxPQUFPc0QsT0FBT3pKLFNBQVNBLFNBQVNrSSxPQUFPNEIsV0FBVyxNQUFNQyxLQUFLLG9CQUFvQi9KLFFBQVE7UUFDM0YsT0FBTyxJQUFJQSxpQkFBaUJrRCxPQUFPbEQsaUJBQWlCb0QsS0FBSztZQUN2RCxNQUFNLEVBQ0ppRyxJQUFJLEVBQ0wsR0FBR3JKO1lBQ0osT0FBT3lKLE9BQU9KLFFBQVFBLFFBQVFuQixPQUFPNEIsV0FBVyxrQkFBa0JDLEtBQUssdUNBQXVDVixPQUFPO1FBQ3ZILE9BQU87WUFDTCxNQUFNLEVBQ0p2SixNQUFNLEVBQ1AsR0FBR0U7WUFDSixPQUFPeUosT0FBTzNKLFVBQVVBLFVBQVVvSSxPQUFPNEIsV0FBVyxvQkFBb0JDLEtBQUsseUNBQXlDakssU0FBUztRQUNqSTtJQUNGO0FBQ0Y7QUFDQTs7Ozs7O0NBTUMsR0FFRCxTQUFTc0osT0FBT3RILE1BQU0sRUFBRXZCLElBQUksRUFBRStDLE9BQU87SUFDbkMsT0FBTyxJQUFJQyxPQUFPO1FBQUUsR0FBR3pCLE1BQU07UUFFM0IsQ0FBQ3dCLFNBQVF0RCxLQUFLLEVBQUVxQyxHQUFHO1lBQ2pCLE9BQU9QLE9BQU93QixPQUFPLENBQUN0RCxPQUFPcUM7WUFDN0IsTUFBTVQsU0FBUzBCLFFBQVF0RCxPQUFPcUM7WUFDOUIsTUFBTTdDLFdBQVd1QyxXQUFXSCxRQUFRUyxLQUFLUCxRQUFROUI7WUFFakQsS0FBSyxNQUFNVCxXQUFXQyxTQUFVO2dCQUM5QixNQUFNO29CQUFFLEdBQUdELE9BQU87b0JBQ2hCWSxZQUFZSTtnQkFDZDtZQUNGO1FBQ0Y7SUFFRjtBQUNGO0FBRTZaLENBQzdaLG9DQUFvQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL3N1cGVyc3RydWN0QDAuMTUuNS9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzPzEzMjkiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gbG9naWMgaXMgZGVzaWduIHRvIGV4aXQgZWFybHkgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UuIFRoZSBlcnJvclxuICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICogY29udGludWUgdmFsaWRhdGlvbiBhbmQgcmVjZWl2ZSBhbGwgdGhlIGZhaWx1cmVzIGluIHRoZSBkYXRhLlxuICovXG5jbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgbGV0IGNhY2hlZDtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhcbiAgICB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBcIkF0IHBhdGg6IFwiICsgcGF0aC5qb2luKCcuJykgKyBcIiAtLSBcIiArIG1lc3NhZ2U7XG4gICAgc3VwZXIobXNnKTtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnJlZmluZW1lbnQgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuYnJhbmNoID0gdm9pZCAwO1xuICAgIHRoaXMuZmFpbHVyZXMgPSB2b2lkIDA7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCByZXN0KTtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cbiAgICB0aGlzLmZhaWx1cmVzID0gKCkgPT4ge1xuICAgICAgdmFyIF9jYWNoZWQ7XG5cbiAgICAgIHJldHVybiAoX2NhY2hlZCA9IGNhY2hlZCkgIT0gbnVsbCA/IF9jYWNoZWQgOiBjYWNoZWQgPSBbZmFpbHVyZSwgLi4uZmFpbHVyZXMoKV07XG4gICAgfTtcbiAgfVxuXG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBpdGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYWJsZSh4KSB7XG4gIHJldHVybiBpc09iamVjdCh4KSAmJiB0eXBlb2YgeFtTeW1ib2wuaXRlcmF0b3JdID09PSAnZnVuY3Rpb24nO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cblxuZnVuY3Rpb24gaXNPYmplY3QoeCkge1xuICByZXR1cm4gdHlwZW9mIHggPT09ICdvYmplY3QnICYmIHggIT0gbnVsbDtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHgpIHtcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4KSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoeCk7XG4gIHJldHVybiBwcm90b3R5cGUgPT09IG51bGwgfHwgcHJvdG90eXBlID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuLyoqXG4gKiBSZXR1cm4gYSB2YWx1ZSBhcyBhIHByaW50YWJsZSBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gcHJpbnQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgOiBcIlwiICsgdmFsdWU7XG59XG4vKipcbiAqIFNoaWZ0cyAocmVtb3ZlcyBhbmQgcmV0dXJucykgdGhlIGZpcnN0IHZhbHVlIGZyb20gdGhlIGBpbnB1dGAgaXRlcmF0b3IuXG4gKiBMaWtlIGBBcnJheS5wcm90b3R5cGUuc2hpZnQoKWAgYnV0IGZvciBhbiBgSXRlcmF0b3JgLlxuICovXG5cbmZ1bmN0aW9uIHNoaWZ0SXRlcmF0b3IoaW5wdXQpIHtcbiAgY29uc3Qge1xuICAgIGRvbmUsXG4gICAgdmFsdWVcbiAgfSA9IGlucHV0Lm5leHQoKTtcbiAgcmV0dXJuIGRvbmUgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn1cbi8qKlxuICogQ29udmVydCBhIHNpbmdsZSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhIGZhaWx1cmUuXG4gKi9cblxuZnVuY3Rpb24gdG9GYWlsdXJlKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAocmVzdWx0ID09PSB0cnVlKSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICByZXN1bHQgPSB7fTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcmVzdWx0ID09PSAnc3RyaW5nJykge1xuICAgIHJlc3VsdCA9IHtcbiAgICAgIG1lc3NhZ2U6IHJlc3VsdFxuICAgIH07XG4gIH1cblxuICBjb25zdCB7XG4gICAgcGF0aCxcbiAgICBicmFuY2hcbiAgfSA9IGNvbnRleHQ7XG4gIGNvbnN0IHtcbiAgICB0eXBlXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHtcbiAgICByZWZpbmVtZW50LFxuICAgIG1lc3NhZ2UgPSBcIkV4cGVjdGVkIGEgdmFsdWUgb2YgdHlwZSBgXCIgKyB0eXBlICsgXCJgXCIgKyAocmVmaW5lbWVudCA/IFwiIHdpdGggcmVmaW5lbWVudCBgXCIgKyByZWZpbmVtZW50ICsgXCJgXCIgOiAnJykgKyBcIiwgYnV0IHJlY2VpdmVkOiBgXCIgKyBwcmludCh2YWx1ZSkgKyBcImBcIlxuICB9ID0gcmVzdWx0O1xuICByZXR1cm4ge1xuICAgIHZhbHVlLFxuICAgIHR5cGUsXG4gICAgcmVmaW5lbWVudCxcbiAgICBrZXk6IHBhdGhbcGF0aC5sZW5ndGggLSAxXSxcbiAgICBwYXRoLFxuICAgIGJyYW5jaCxcbiAgICAuLi5yZXN1bHQsXG4gICAgbWVzc2FnZVxuICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsaWRhdGlvbiByZXN1bHQgdG8gYW4gaXRlcmFibGUgb2YgZmFpbHVyZXMuXG4gKi9cblxuZnVuY3Rpb24qIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmICghaXNJdGVyYWJsZShyZXN1bHQpKSB7XG4gICAgcmVzdWx0ID0gW3Jlc3VsdF07XG4gIH1cblxuICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0KSB7XG4gICAgY29uc3QgZmFpbHVyZSA9IHRvRmFpbHVyZShyLCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKTtcblxuICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICB5aWVsZCBmYWlsdXJlO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBDaGVjayBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHRyYXZlcnNpbmcgZGVlcGx5IGludG8gbmVzdGVkIHZhbHVlcywgYW5kXG4gKiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb2YgZmFpbHVyZXMgb3Igc3VjY2Vzcy5cbiAqL1xuXG5mdW5jdGlvbiogcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoID0gW10sXG4gICAgYnJhbmNoID0gW3ZhbHVlXSxcbiAgICBjb2VyY2UgPSBmYWxzZSxcbiAgICBtYXNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9O1xuXG4gIGlmIChjb2VyY2UpIHtcbiAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuXG4gICAgaWYgKG1hc2sgJiYgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJiBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIFt0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdiA9IHRbMV07XG5cbiAgICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICB5aWVsZCBbdW5kZWZpbmVkLCB2YWx1ZV07XG4gIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5cbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgdGhpcy5UWVBFID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnNjaGVtYSA9IHZvaWQgMDtcbiAgICB0aGlzLmNvZXJjZXIgPSB2b2lkIDA7XG4gICAgdGhpcy52YWxpZGF0b3IgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWZpbmVyID0gdm9pZCAwO1xuICAgIHRoaXMuZW50cmllcyA9IHZvaWQgMDtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdmFsaWRhdG9yLFxuICAgICAgcmVmaW5lcixcbiAgICAgIGNvZXJjZXIgPSB2YWx1ZSA9PiB2YWx1ZSxcbiAgICAgIGVudHJpZXMgPSBmdW5jdGlvbiogKCkge31cbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG5cbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgfVxuXG4gICAgaWYgKHJlZmluZXIpIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgKi9cblxuXG4gIGFzc2VydCh2YWx1ZSkge1xuICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyBjb2VyY2lvbiBsb2dpYywgdGhlbiB2YWxpZGF0ZSBpdC5cbiAgICovXG5cblxuICBjcmVhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAqL1xuXG5cbiAgaXModmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICovXG5cblxuICBtYXNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuXG5cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRlKHZhbHVlLCB0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG59XG4vKipcbiAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICovXG5cbmZ1bmN0aW9uIGFzc2VydCh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgY29lcmNpb24gbG9naWMgb2Ygc3RydWN0IGFuZCB2YWxpZGF0ZSBpdC5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGUodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7XG4gICAgY29lcmNlOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuLyoqXG4gKiBNYXNrIGEgdmFsdWUsIHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2YgcHJvcGVydGllcyBkZWZpbmVkIGJ5IGEgc3RydWN0LlxuICovXG5cbmZ1bmN0aW9uIG1hc2sodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCB7XG4gICAgY29lcmNlOiB0cnVlLFxuICAgIG1hc2s6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIGEgc3RydWN0LlxuICovXG5cbmZ1bmN0aW9uIGlzKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG4gIHJldHVybiAhcmVzdWx0WzBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZSBhIHZhbHVlIGFnYWluc3QgYSBzdHJ1Y3QsIHJldHVybmluZyBhbiBlcnJvciBpZiBpbnZhbGlkLCBvciB0aGVcbiAqIHZhbHVlICh3aXRoIHBvdGVudGlhbCBjb2VyY2lvbikgaWYgdmFsaWQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcblxuICBpZiAodHVwbGVbMF0pIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbigpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIFN0cnVjdHMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgU3RydWN0c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIGNvbnN0IGlzVHlwZSA9IFN0cnVjdHNbMF0udHlwZSA9PT0gJ3R5cGUnO1xuICBjb25zdCBzY2hlbWFzID0gU3RydWN0cy5tYXAocyA9PiBzLnNjaGVtYSk7XG4gIGNvbnN0IHNjaGVtYSA9IE9iamVjdC5hc3NpZ24oe30sIC4uLnNjaGVtYXMpO1xuICByZXR1cm4gaXNUeXBlID8gdHlwZShzY2hlbWEpIDogb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogbmFtZSxcbiAgICBzY2hlbWE6IG51bGwsXG4gICAgdmFsaWRhdG9yXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIHN0cnVjdCwgYnV0IHRoZSB2YWx1ZSBpcyBhbGxvd2VkIHRvXG4gKiBiZSBgdW5kZWZpbmVkYC4gYGxvZ2Agd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHZhbHVlIGlzIG5vdCBgdW5kZWZpbmVkYC5cbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGVkKHN0cnVjdCwgbG9nKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbG9nKHZhbHVlLCBjdHgpO1xuICAgICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGR5bmFtaWMgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgY2FsbGJhY2sgd2lsbCByZWNlaXZlIHRoZSB2YWx1ZSBjdXJyZW50bHkgYmVpbmcgdmFsaWRhdGVkLCBhbmQgbXVzdFxuICogcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB2YWxpZGF0ZSBpdCB3aXRoLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gbW9kZWxcbiAqIHZhbGlkYXRpb24gbG9naWMgdGhhdCBjaGFuZ2VzIGJhc2VkIG9uIGl0cyBpbnB1dC5cbiAqL1xuXG5mdW5jdGlvbiBkeW5hbWljKGZuKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnZHluYW1pYycsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICByZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggbGF6aWx5IGV2YWx1YXRlZCB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHZhbGlkYXRpb24gaXMgcnVuIHdpdGggdGhlIHN0cnVjdCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gKiBhbmQgbXVzdCByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHVzZS4gVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdVxuICogd2FudCB0byBoYXZlIHNlbGYtcmVmZXJlbnRpYWwgc3RydWN0cyBmb3IgbmVzdGVkIGRhdGEgc3RydWN0dXJlcyB0byBhdm9pZCBhXG4gKiBjaXJjdWxhciBkZWZpbml0aW9uIHByb2JsZW0uXG4gKi9cblxuZnVuY3Rpb24gbGF6eShmbikge1xuICBsZXQgc3RydWN0O1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xhenknLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0O1xuXG4gICAgICAoX3N0cnVjdCA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3QyO1xuXG4gICAgICAoX3N0cnVjdDIgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0MiA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDM7XG5cbiAgICAgIChfc3RydWN0MyA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QzIDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDQ7XG5cbiAgICAgIChfc3RydWN0NCA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3Q0IDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IGV4Y2x1ZGluZ1xuICogc3BlY2lmaWMgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgT21pdGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBvbWl0KHN0cnVjdCwga2V5cykge1xuICBjb25zdCB7XG4gICAgc2NoZW1hXG4gIH0gPSBzdHJ1Y3Q7XG4gIGNvbnN0IHN1YnNjaGVtYSA9IHsgLi4uc2NoZW1hXG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGRlbGV0ZSBzdWJzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHN3aXRjaCAoc3RydWN0LnR5cGUpIHtcbiAgICBjYXNlICd0eXBlJzpcbiAgICAgIHJldHVybiB0eXBlKHN1YnNjaGVtYSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IHdpdGggYWxsIG9mIGl0c1xuICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQYXJ0aWFsYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYVxuICB9IDogeyAuLi5zdHJ1Y3RcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWFba2V5XSA9IG9wdGlvbmFsKHNjaGVtYVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RydWN0KG5hbWUsIHZhbGlkYXRvcikge1xuICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYmlnaW50LlxuICovXG5cbmZ1bmN0aW9uIGJpZ2ludCgpIHtcbiAgcmV0dXJuIGRlZmluZSgnYmlnaW50JywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdiaWdpbnQnO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cblxuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5cbmZ1bmN0aW9uIGRhdGUoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2RhdGUnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSB8fCBcIkV4cGVjdGVkIGEgdmFsaWQgYERhdGVgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgY29uc3Qgc2NoZW1hID0ge307XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCh2ID0+IHByaW50KHYpKS5qb2luKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8IFwiRXhwZWN0ZWQgb25lIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBcIkV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHwgXCJFeHBlY3RlZCBhIGBcIiArIENsYXNzLm5hbWUgKyBcImAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgbWF0Y2hlcyBhbGwgb2YgYSBzZXQgb2YgdHlwZXMuXG4gKi9cblxuZnVuY3Rpb24gaW50ZXJzZWN0aW9uKFN0cnVjdHMpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdpbnRlcnNlY3Rpb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICp2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy5yZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIGxpdGVyYWwoY29uc3RhbnQpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBwcmludChjb25zdGFudCk7XG4gIGNvbnN0IHQgPSB0eXBlb2YgY29uc3RhbnQ7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGl0ZXJhbCcsXG4gICAgc2NoZW1hOiB0ID09PSAnc3RyaW5nJyB8fCB0ID09PSAnbnVtYmVyJyB8fCB0ID09PSAnYm9vbGVhbicgPyBjb25zdGFudCA6IG51bGwsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gY29uc3RhbnQgfHwgXCJFeHBlY3RlZCB0aGUgbGl0ZXJhbCBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiBtYXAoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ21hcCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChLZXkgJiYgVmFsdWUgJiYgdmFsdWUgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgPyBuZXcgTWFwKHZhbHVlKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCBcIkV4cGVjdGVkIGEgYE1hcGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgbm8gdmFsdWUgZXZlciBwYXNzZXMgdmFsaWRhdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBuZXZlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnbmV2ZXInLCAoKSA9PiBmYWxzZSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYW4gZXhpc3Rpbmcgc3RydWN0IHRvIGFsbG93IGBudWxsYCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gbnVsbGFibGUoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSBudWxsIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgbnVtYmVyLlxuICovXG5cbmZ1bmN0aW9uIG51bWJlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnbnVtYmVyJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhIG51bWJlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBvYmplY3Qoc2NoZW1hKSB7XG4gIGNvbnN0IGtub3ducyA9IHNjaGVtYSA/IE9iamVjdC5rZXlzKHNjaGVtYSkgOiBbXTtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgc2NoZW1hOiBzY2hlbWEgPyBzY2hlbWEgOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChzY2hlbWEgJiYgaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IHVua25vd25zID0gbmV3IFNldChPYmplY3Qua2V5cyh2YWx1ZSkpO1xuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtub3ducykge1xuICAgICAgICAgIHVua25vd25zLmRlbGV0ZShrZXkpO1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIHNjaGVtYVtrZXldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVua25vd25zKSB7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgTmV2ZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSA/IHsgLi4udmFsdWVcbiAgICAgIH0gOiB2YWx1ZTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gYWxsb3cgYHVuZGVmaW5lZGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG9wdGlvbmFsKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCksXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGgga2V5cyBhbmQgdmFsdWVzIG9mIHNwZWNpZmljIHR5cGVzLCBidXRcbiAqIHdpdGhvdXQgZW5zdXJpbmcgYW55IHNwZWNpZmljIHNoYXBlIG9mIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFJlY29yZGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiByZWNvcmQoS2V5LCBWYWx1ZSkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3JlY29yZCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgdiA9IHZhbHVlW2tdO1xuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGBSZWdFeHBgLlxuICpcbiAqIE5vdGU6IHRoaXMgZG9lcyBub3QgdGVzdCB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcmVndWxhciBleHByZXNzaW9uISBGb3IgdGhhdFxuICogeW91IG5lZWQgdG8gdXNlIHRoZSBgcGF0dGVybigpYCByZWZpbmVtZW50LlxuICovXG5cbmZ1bmN0aW9uIHJlZ2V4cCgpIHtcbiAgcmV0dXJuIGRlZmluZSgncmVnZXhwJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcbiAgfSk7XG59XG5mdW5jdGlvbiBzZXQoRWxlbWVudCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3NldCcsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZSkge1xuICAgICAgICAgIHlpZWxkIFt2LCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgPyBuZXcgU2V0KHZhbHVlKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCB8fCBcIkV4cGVjdGVkIGEgYFNldGAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBzdHJpbmcoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3N0cmluZycsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCBcIkV4cGVjdGVkIGEgc3RyaW5nLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIHR1cGxlIG9mIGEgc3BlY2lmaWMgbGVuZ3RoLCBhbmQgdGhhdCBlYWNoIG9mIGl0c1xuICogZWxlbWVudHMgaXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHR1cGxlKFN0cnVjdHMpIHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R1cGxlJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KFN0cnVjdHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIFN0cnVjdHNbaV0gfHwgTmV2ZXJdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gYXJyYXksIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGhhcyBhIHNldCBvZiBrbm93biBwcm9wZXJ0aWVzIG9mIHNwZWNpZmljIHR5cGVzLlxuICpcbiAqIE5vdGU6IFVucmVjb2duaXplZCBwcm9wZXJ0aWVzIGFyZSBhbGxvd2VkIGFuZCB1bnRvdWNoZWQuIFRoaXMgaXMgc2ltaWxhciB0b1xuICogaG93IFR5cGVTY3JpcHQncyBzdHJ1Y3R1cmFsIHR5cGluZyB3b3Jrcy5cbiAqL1xuXG5mdW5jdGlvbiB0eXBlKHNjaGVtYSkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICd0eXBlJyxcbiAgICBzY2hlbWEsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICAgIHlpZWxkIFtrLCB2YWx1ZVtrXSwgc2NoZW1hW2tdXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIG1hdGNoZXMgb25lIG9mIGEgc2V0IG9mIHR5cGVzLlxuICovXG5cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcChzID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndW5pb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmlyc3RNYXRjaCA9IFN0cnVjdHMuZmluZChzID0+IHtcbiAgICAgICAgY29uc3QgW2VdID0gcy52YWxpZGF0ZSh2YWx1ZSwge1xuICAgICAgICAgIGNvZXJjZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICFlO1xuICAgICAgfSkgfHwgdW5rbm93bigpO1xuICAgICAgcmV0dXJuIGZpcnN0TWF0Y2guY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IGZhaWx1cmVzID0gW107XG5cbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIGNvbnN0IFsuLi50dXBsZXNdID0gcnVuKHZhbHVlLCBTLCBjdHgpO1xuICAgICAgICBjb25zdCBbZmlyc3RdID0gdHVwbGVzO1xuXG4gICAgICAgIGlmICghZmlyc3RbMF0pIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChjb25zdCBbZmFpbHVyZV0gb2YgdHVwbGVzKSB7XG4gICAgICAgICAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgICAgICAgICBmYWlsdXJlcy5wdXNoKGZhaWx1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW1wiRXhwZWN0ZWQgdGhlIHZhbHVlIHRvIHNhdGlzZnkgYSB1bmlvbiBvZiBgXCIgKyBkZXNjcmlwdGlvbiArIFwiYCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKSwgLi4uZmFpbHVyZXNdO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLCB3aXRob3V0IHdpZGVuaW5nIGl0cyB0eXBlIHRvIGBhbnlgLlxuICovXG5cbmZ1bmN0aW9uIHVua25vd24oKSB7XG4gIHJldHVybiBkZWZpbmUoJ3Vua25vd24nLCAoKSA9PiB0cnVlKTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IGEgYFN0cnVjdGAgdG8gYWRkIGFuIGFkZGl0aW9uYWwgY29lcmNpb24gc3RlcCB0byBpdHMgaW5wdXQuXG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyYW5zZm9ybSBpbnB1dCBkYXRhIGJlZm9yZSB2YWxpZGF0aW5nIGl0LCB0byBpbmNyZWFzZSB0aGVcbiAqIGxpa2VsaWhvb2QgdGhhdCBpdCBwYXNzZXMgdmFsaWRhdGlvbuKAlGZvciBleGFtcGxlIGZvciBkZWZhdWx0IHZhbHVlcywgcGFyc2luZ1xuICogZGlmZmVyZW50IGZvcm1hdHMsIGV0Yy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2Uoc3RydWN0LCBjb25kaXRpb24sIGNvZXJjZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgY29lcmNlcjogKHZhbHVlLCBjdHgpID0+IHtcbiAgICAgIHJldHVybiBpcyh2YWx1ZSwgY29uZGl0aW9uKSA/IHN0cnVjdC5jb2VyY2VyKGNvZXJjZXIodmFsdWUsIGN0eCksIGN0eCkgOiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHJlcGxhY2UgYHVuZGVmaW5lZGAgdmFsdWVzIHdpdGggYSBkZWZhdWx0LlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlZmF1bHRlZChzdHJ1Y3QsIGZhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCB4ID0+IHtcbiAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueFxuICAgICAgfTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCB4ID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgdmFsdWUgPT4ge1xuICAgIGNvbnN0IHNpemUgPSBnZXRTaXplKHZhbHVlKTtcbiAgICByZXR1cm4gc2l6ZSA9PT0gMCB8fCBcIkV4cGVjdGVkIGFuIGVtcHR5IFwiICsgc3RydWN0LnR5cGUgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUodmFsdWUpIHtcbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgcmV0dXJuIHZhbHVlLnNpemU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlLmxlbmd0aDtcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICovXG5cblxuZnVuY3Rpb24gbWF4KHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPCB0aHJlc2hvbGQgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBsZXNzIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cblxuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPiB0aHJlc2hvbGQgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBncmVhdGVyIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwIG9yIHNldCBpcyBub3QgZW1wdHkuXG4gKi9cblxuZnVuY3Rpb24gbm9uZW1wdHkoc3RydWN0KSB7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnbm9uZW1wdHknLCB2YWx1ZSA9PiB7XG4gICAgY29uc3Qgc2l6ZSA9IGdldFNpemUodmFsdWUpO1xuICAgIHJldHVybiBzaXplID4gMCB8fCBcIkV4cGVjdGVkIGEgbm9uZW1wdHkgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGJ1dCByZWNlaXZlZCBhbiBlbXB0eSBvbmVcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cblxuZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIG1hdGNoaW5nIGAvXCIgKyByZWdleHAuc291cmNlICsgXCIvYCBidXQgcmVjZWl2ZWQgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB2b2lkIDApIHtcbiAgICBtYXggPSBtaW47XG4gIH1cblxuICBjb25zdCBleHBlY3RlZCA9IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlO1xuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gXCJvZiBgXCIgKyBtaW4gKyBcImBcIiA6IFwiYmV0d2VlbiBgXCIgKyBtaW4gKyBcImAgYW5kIGBcIiArIG1heCArIFwiYFwiO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpemVcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIHdpdGggYSBzaXplIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgbGVuZ3RoIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgYFwiICsgbGVuZ3RoICsgXCJgXCI7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKi9cblxuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLFxuICAgICAgICAgIHJlZmluZW1lbnQ6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBiaWdpbnQsIGJvb2xlYW4sIGNvZXJjZSwgY3JlYXRlLCBkYXRlLCBkZWZhdWx0ZWQsIGRlZmluZSwgZGVwcmVjYXRlZCwgZHluYW1pYywgZW1wdHksIGVudW1zLCBmdW5jLCBpbnN0YW5jZSwgaW50ZWdlciwgaW50ZXJzZWN0aW9uLCBpcywgbGF6eSwgbGl0ZXJhbCwgbWFwLCBtYXNrLCBtYXgsIG1pbiwgbmV2ZXIsIG5vbmVtcHR5LCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJTdHJ1Y3RFcnJvciIsIlR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwiZmFpbHVyZSIsImZhaWx1cmVzIiwiY2FjaGVkIiwibWVzc2FnZSIsInJlc3QiLCJwYXRoIiwibXNnIiwibGVuZ3RoIiwiam9pbiIsInZhbHVlIiwia2V5IiwidHlwZSIsInJlZmluZW1lbnQiLCJicmFuY2giLCJPYmplY3QiLCJhc3NpZ24iLCJuYW1lIiwiX2NhY2hlZCIsImlzSXRlcmFibGUiLCJ4IiwiaXNPYmplY3QiLCJTeW1ib2wiLCJpdGVyYXRvciIsImlzUGxhaW5PYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJnZXRQcm90b3R5cGVPZiIsInByaW50IiwiSlNPTiIsInN0cmluZ2lmeSIsInNoaWZ0SXRlcmF0b3IiLCJpbnB1dCIsImRvbmUiLCJuZXh0IiwidW5kZWZpbmVkIiwidG9GYWlsdXJlIiwicmVzdWx0IiwiY29udGV4dCIsInN0cnVjdCIsInRvRmFpbHVyZXMiLCJyIiwicnVuIiwib3B0aW9ucyIsImNvZXJjZSIsIm1hc2siLCJjdHgiLCJjb2VyY2VyIiwic2NoZW1hIiwiQXJyYXkiLCJpc0FycmF5IiwidmFsaWQiLCJ2YWxpZGF0b3IiLCJrIiwidiIsInMiLCJlbnRyaWVzIiwidHMiLCJ0IiwiTWFwIiwic2V0IiwiU2V0IiwiYWRkIiwicmVmaW5lciIsIlN0cnVjdCIsInByb3BzIiwiVFlQRSIsImFzc2VydCIsImNyZWF0ZSIsImlzIiwidmFsaWRhdGUiLCJ0dXBsZXMiLCJ0dXBsZSIsImVycm9yIiwiX2xlbiIsImFyZ3VtZW50cyIsIlN0cnVjdHMiLCJfa2V5IiwiaXNUeXBlIiwic2NoZW1hcyIsIm1hcCIsIm9iamVjdCIsImRlZmluZSIsImRlcHJlY2F0ZWQiLCJsb2ciLCJkeW5hbWljIiwiZm4iLCJsYXp5IiwiX3N0cnVjdCIsIl9zdHJ1Y3QyIiwiX3N0cnVjdDMiLCJfc3RydWN0NCIsIm9taXQiLCJrZXlzIiwic3Vic2NoZW1hIiwicGFydGlhbCIsIm9wdGlvbmFsIiwicGljayIsImNvbnNvbGUiLCJ3YXJuIiwiYW55IiwiYXJyYXkiLCJFbGVtZW50IiwiaSIsInNsaWNlIiwiYmlnaW50IiwiYm9vbGVhbiIsImRhdGUiLCJEYXRlIiwiaXNOYU4iLCJnZXRUaW1lIiwiZW51bXMiLCJ2YWx1ZXMiLCJkZXNjcmlwdGlvbiIsImluY2x1ZGVzIiwiZnVuYyIsImluc3RhbmNlIiwiQ2xhc3MiLCJpbnRlZ2VyIiwiTnVtYmVyIiwiaXNJbnRlZ2VyIiwiaW50ZXJzZWN0aW9uIiwiUyIsImxpdGVyYWwiLCJjb25zdGFudCIsIktleSIsIlZhbHVlIiwibmV2ZXIiLCJudWxsYWJsZSIsIm51bWJlciIsImtub3ducyIsIk5ldmVyIiwidW5rbm93bnMiLCJkZWxldGUiLCJyZWNvcmQiLCJyZWdleHAiLCJSZWdFeHAiLCJzdHJpbmciLCJNYXRoIiwibWF4IiwidW5pb24iLCJmaXJzdE1hdGNoIiwiZmluZCIsImUiLCJ1bmtub3duIiwiZmlyc3QiLCJwdXNoIiwiY29uZGl0aW9uIiwiZGVmYXVsdGVkIiwiZmFsbGJhY2siLCJmIiwic3RyaWN0IiwicmV0IiwiY2hhbmdlZCIsInRyaW1tZWQiLCJ0cmltIiwiZW1wdHkiLCJyZWZpbmUiLCJzaXplIiwiZ2V0U2l6ZSIsInRocmVzaG9sZCIsImV4Y2x1c2l2ZSIsIm1pbiIsIm5vbmVtcHR5IiwicGF0dGVybiIsInRlc3QiLCJzb3VyY2UiLCJleHBlY3RlZCIsIm9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/superstruct@0.15.5/node_modules/superstruct/lib/index.es.js\n");

/***/ })

};
;