"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bignumber.js@9.3.1";
exports.ids = ["vendor-chunks/bignumber.js@9.3.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *      bignumber.js v9.3.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */ var isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = \"[BigNumber Error] \", tooManyDigits = bignumberError + \"Number primitive has more than 15 significant digits: \", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\nPOWS_TEN = [\n    1,\n    10,\n    100,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n    1e11,\n    1e12,\n    1e13\n], SQRT_BASE = 1e7, // EDITABLE\n// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n// the arguments to toExponential, toFixed, toFormat, and toPrecision.\nMAX = 1E9; // 0 to MAX_INT32\n/*\r\n * Create and return a BigNumber constructor.\r\n */ function clone(configObject) {\n    var div, convertBase, parseNumeric, P = BigNumber.prototype = {\n        constructor: BigNumber,\n        toString: null,\n        valueOf: null\n    }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n    // The default values below must be integers within the inclusive ranges stated.\n    // The values can also be changed at run-time using BigNumber.set.\n    // The maximum number of decimal places for operations involving division.\n    DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n    // UP         0 Away from zero.\n    // DOWN       1 Towards zero.\n    // CEIL       2 Towards +Infinity.\n    // FLOOR      3 Towards -Infinity.\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n    // The exponent value at and beneath which toString returns exponential notation.\n    // Number type: -7\n    TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.\n    // Number type: 21\n    TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // Number type: -324  (5e-324)\n    MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.\n    // Number type:  308  (1.7976931348623157e+308)\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n    MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.\n    CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN      1 The remainder has the same sign as the dividend.\n    //             This modulo mode is commonly known as 'truncated division' and is\n    //             equivalent to (a % n) in JavaScript.\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n    //             The remainder is always positive.\n    //\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n    // modes are commonly used for the modulus operation.\n    // Although the other rounding modes can also be used, they may not give useful results.\n    MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\n    POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.\n    FORMAT = {\n        prefix: \"\",\n        groupSize: 3,\n        secondaryGroupSize: 0,\n        groupSeparator: \",\",\n        decimalSeparator: \".\",\n        fractionGroupSize: 0,\n        fractionGroupSeparator: \"\\xa0\",\n        suffix: \"\"\n    }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\n    // '-', '.', whitespace, or repeated character.\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n    ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\", alphabetHasNormalDecimalDigits = true;\n    //------------------------------------------------------------------------------------------\n    // CONSTRUCTOR\n    /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */ function BigNumber(v, b) {\n        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;\n        // Enable constructor call without `new`.\n        if (!(x instanceof BigNumber)) return new BigNumber(v, b);\n        if (b == null) {\n            if (v && v._isBigNumber === true) {\n                x.s = v.s;\n                if (!v.c || v.e > MAX_EXP) {\n                    x.c = x.e = null;\n                } else if (v.e < MIN_EXP) {\n                    x.c = [\n                        x.e = 0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.c = v.c.slice();\n                }\n                return;\n            }\n            if ((isNum = typeof v == \"number\") && v * 0 == 0) {\n                // Use `1 / n` to handle minus zero also.\n                x.s = 1 / v < 0 ? (v = -v, -1) : 1;\n                // Fast path for integers, where n < 2147483648 (2**31).\n                if (v === ~~v) {\n                    for(e = 0, i = v; i >= 10; i /= 10, e++);\n                    if (e > MAX_EXP) {\n                        x.c = x.e = null;\n                    } else {\n                        x.e = e;\n                        x.c = [\n                            v\n                        ];\n                    }\n                    return;\n                }\n                str = String(v);\n            } else {\n                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\n                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n            }\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            // Exponential form?\n            if ((i = str.search(/e/i)) > 0) {\n                // Determine exponent.\n                if (e < 0) e = i;\n                e += +str.slice(i + 1);\n                str = str.substring(0, i);\n            } else if (e < 0) {\n                // Integer.\n                e = str.length;\n            }\n        } else {\n            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n            intCheck(b, 2, ALPHABET.length, \"Base\");\n            // Allow exponential notation to be used with base 10 argument, while\n            // also rounding to DECIMAL_PLACES as with other bases.\n            if (b == 10 && alphabetHasNormalDecimalDigits) {\n                x = new BigNumber(v);\n                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n            }\n            str = String(v);\n            if (isNum = typeof v == \"number\") {\n                // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\n                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, \"\").length > 15) {\n                    throw Error(tooManyDigits + v);\n                }\n            } else {\n                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n            }\n            alphabet = ALPHABET.slice(0, b);\n            e = i = 0;\n            // Check that str is a valid base b number.\n            // Don't use RegExp, so alphabet can contain special characters.\n            for(len = str.length; i < len; i++){\n                if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                    if (c == \".\") {\n                        // If '.' is not the first character and it has not be found before.\n                        if (i > e) {\n                            e = len;\n                            continue;\n                        }\n                    } else if (!caseChanged) {\n                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {\n                            caseChanged = true;\n                            i = -1;\n                            e = 0;\n                            continue;\n                        }\n                    }\n                    return parseNumeric(x, String(v), isNum, b);\n                }\n            }\n            // Prevent later check for length on converted number.\n            isNum = false;\n            str = convertBase(str, b, 10, x.s);\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            else e = str.length;\n        }\n        // Determine leading zeros.\n        for(i = 0; str.charCodeAt(i) === 48; i++);\n        // Determine trailing zeros.\n        for(len = str.length; str.charCodeAt(--len) === 48;);\n        if (str = str.slice(i, ++len)) {\n            len -= i;\n            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n            if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\n                throw Error(tooManyDigits + x.s * v);\n            }\n            // Overflow?\n            if ((e = e - i - 1) > MAX_EXP) {\n                // Infinity.\n                x.c = x.e = null;\n            // Underflow?\n            } else if (e < MIN_EXP) {\n                // Zero.\n                x.c = [\n                    x.e = 0\n                ];\n            } else {\n                x.e = e;\n                x.c = [];\n                // Transform base\n                // e is the base 10 exponent.\n                // i is where to slice str to get the first element of the coefficient array.\n                i = (e + 1) % LOG_BASE;\n                if (e < 0) i += LOG_BASE; // i < 1\n                if (i < len) {\n                    if (i) x.c.push(+str.slice(0, i));\n                    for(len -= LOG_BASE; i < len;){\n                        x.c.push(+str.slice(i, i += LOG_BASE));\n                    }\n                    i = LOG_BASE - (str = str.slice(i)).length;\n                } else {\n                    i -= len;\n                }\n                for(; i--; str += \"0\");\n                x.c.push(+str);\n            }\n        } else {\n            // Zero.\n            x.c = [\n                x.e = 0\n            ];\n        }\n    }\n    // CONSTRUCTOR PROPERTIES\n    BigNumber.clone = clone;\n    BigNumber.ROUND_UP = 0;\n    BigNumber.ROUND_DOWN = 1;\n    BigNumber.ROUND_CEIL = 2;\n    BigNumber.ROUND_FLOOR = 3;\n    BigNumber.ROUND_HALF_UP = 4;\n    BigNumber.ROUND_HALF_DOWN = 5;\n    BigNumber.ROUND_HALF_EVEN = 6;\n    BigNumber.ROUND_HALF_CEIL = 7;\n    BigNumber.ROUND_HALF_FLOOR = 8;\n    BigNumber.EUCLID = 9;\n    /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */ BigNumber.config = BigNumber.set = function(obj) {\n        var p, v;\n        if (obj != null) {\n            if (typeof obj == \"object\") {\n                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"DECIMAL_PLACES\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    DECIMAL_PLACES = v;\n                }\n                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"ROUNDING_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 8, p);\n                    ROUNDING_MODE = v;\n                }\n                // EXPONENTIAL_AT {number|number[]}\n                // Integer, -MAX to MAX inclusive or\n                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"EXPONENTIAL_AT\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, 0, p);\n                        intCheck(v[1], 0, MAX, p);\n                        TO_EXP_NEG = v[0];\n                        TO_EXP_POS = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                    }\n                }\n                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                if (obj.hasOwnProperty(p = \"RANGE\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, -1, p);\n                        intCheck(v[1], 1, MAX, p);\n                        MIN_EXP = v[0];\n                        MAX_EXP = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        if (v) {\n                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                        } else {\n                            throw Error(bignumberError + p + \" cannot be zero: \" + v);\n                        }\n                    }\n                }\n                // CRYPTO {boolean} true or false.\n                // '[BigNumber Error] CRYPTO not true or false: {v}'\n                // '[BigNumber Error] crypto unavailable'\n                if (obj.hasOwnProperty(p = \"CRYPTO\")) {\n                    v = obj[p];\n                    if (v === !!v) {\n                        if (v) {\n                            if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                                CRYPTO = v;\n                            } else {\n                                CRYPTO = !v;\n                                throw Error(bignumberError + \"crypto unavailable\");\n                            }\n                        } else {\n                            CRYPTO = v;\n                        }\n                    } else {\n                        throw Error(bignumberError + p + \" not true or false: \" + v);\n                    }\n                }\n                // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"MODULO_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 9, p);\n                    MODULO_MODE = v;\n                }\n                // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"POW_PRECISION\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    POW_PRECISION = v;\n                }\n                // FORMAT {object}\n                // '[BigNumber Error] FORMAT not an object: {v}'\n                if (obj.hasOwnProperty(p = \"FORMAT\")) {\n                    v = obj[p];\n                    if (typeof v == \"object\") FORMAT = v;\n                    else throw Error(bignumberError + p + \" not an object: \" + v);\n                }\n                // ALPHABET {string}\n                // '[BigNumber Error] ALPHABET invalid: {v}'\n                if (obj.hasOwnProperty(p = \"ALPHABET\")) {\n                    v = obj[p];\n                    // Disallow if less than two characters,\n                    // or if it contains '+', '-', '.', whitespace, or a repeated character.\n                    if (typeof v == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\n                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == \"0123456789\";\n                        ALPHABET = v;\n                    } else {\n                        throw Error(bignumberError + p + \" invalid: \" + v);\n                    }\n                }\n            } else {\n                // '[BigNumber Error] Object expected: {v}'\n                throw Error(bignumberError + \"Object expected: \" + obj);\n            }\n        }\n        return {\n            DECIMAL_PLACES: DECIMAL_PLACES,\n            ROUNDING_MODE: ROUNDING_MODE,\n            EXPONENTIAL_AT: [\n                TO_EXP_NEG,\n                TO_EXP_POS\n            ],\n            RANGE: [\n                MIN_EXP,\n                MAX_EXP\n            ],\n            CRYPTO: CRYPTO,\n            MODULO_MODE: MODULO_MODE,\n            POW_PRECISION: POW_PRECISION,\n            FORMAT: FORMAT,\n            ALPHABET: ALPHABET\n        };\n    };\n    /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */ BigNumber.isBigNumber = function(v) {\n        if (!v || v._isBigNumber !== true) return false;\n        if (!BigNumber.DEBUG) return true;\n        var i, n, c = v.c, e = v.e, s = v.s;\n        out: if (({}).toString.call(c) == \"[object Array]\") {\n            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\n                // If the first element is zero, the BigNumber value must be zero.\n                if (c[0] === 0) {\n                    if (e === 0 && c.length === 1) return true;\n                    break out;\n                }\n                // Calculate number of digits that c[0] should have, based on the exponent.\n                i = (e + 1) % LOG_BASE;\n                if (i < 1) i += LOG_BASE;\n                // Calculate number of digits of c[0].\n                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\n                if (String(c[0]).length == i) {\n                    for(i = 0; i < c.length; i++){\n                        n = c[i];\n                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\n                    }\n                    // Last element cannot be zero, unless it is the only element.\n                    if (n !== 0) return true;\n                }\n            }\n        // Infinity/NaN\n        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\n            return true;\n        }\n        throw Error(bignumberError + \"Invalid BigNumber: \" + v);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.maximum = BigNumber.max = function() {\n        return maxOrMin(arguments, -1);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.minimum = BigNumber.min = function() {\n        return maxOrMin(arguments, 1);\n    };\n    /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */ BigNumber.random = function() {\n        var pow2_53 = 0x20000000000000;\n        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n        // Check if Math.random() produces more than 32 bits of randomness.\n        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n        var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {\n            return mathfloor(Math.random() * pow2_53);\n        } : function() {\n            return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);\n        };\n        return function(dp) {\n            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);\n            if (dp == null) dp = DECIMAL_PLACES;\n            else intCheck(dp, 0, MAX);\n            k = mathceil(dp / LOG_BASE);\n            if (CRYPTO) {\n                // Browsers supporting crypto.getRandomValues.\n                if (crypto.getRandomValues) {\n                    a = crypto.getRandomValues(new Uint32Array(k *= 2));\n                    for(; i < k;){\n                        // 53 bits:\n                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                        //                                     11111 11111111 11111111\n                        // 0x20000 is 2^21.\n                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n                        // Rejection sampling:\n                        // 0 <= v < 9007199254740992\n                        // Probability that v >= 9e15, is\n                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                        if (v >= 9e15) {\n                            b = crypto.getRandomValues(new Uint32Array(2));\n                            a[i] = b[0];\n                            a[i + 1] = b[1];\n                        } else {\n                            // 0 <= v <= 8999999999999999\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 2;\n                        }\n                    }\n                    i = k / 2;\n                // Node.js supporting crypto.randomBytes.\n                } else if (crypto.randomBytes) {\n                    // buffer\n                    a = crypto.randomBytes(k *= 7);\n                    for(; i < k;){\n                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                        // 0x100000000 is 2^32, 0x1000000 is 2^24\n                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                        // 0 <= v < 9007199254740992\n                        v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n                        if (v >= 9e15) {\n                            crypto.randomBytes(7).copy(a, i);\n                        } else {\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 7;\n                        }\n                    }\n                    i = k / 7;\n                } else {\n                    CRYPTO = false;\n                    throw Error(bignumberError + \"crypto unavailable\");\n                }\n            }\n            // Use Math.random.\n            if (!CRYPTO) {\n                for(; i < k;){\n                    v = random53bitInt();\n                    if (v < 9e15) c[i++] = v % 1e14;\n                }\n            }\n            k = c[--i];\n            dp %= LOG_BASE;\n            // Convert trailing digits to zeros according to dp.\n            if (k && dp) {\n                v = POWS_TEN[LOG_BASE - dp];\n                c[i] = mathfloor(k / v) * v;\n            }\n            // Remove trailing elements which are zero.\n            for(; c[i] === 0; c.pop(), i--);\n            // Zero?\n            if (i < 0) {\n                c = [\n                    e = 0\n                ];\n            } else {\n                // Remove leading elements which are zero and adjust exponent accordingly.\n                for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n                // Count the digits of the first element of c to determine leading zeros, and...\n                for(i = 1, v = c[0]; v >= 10; v /= 10, i++);\n                // adjust the exponent accordingly.\n                if (i < LOG_BASE) e -= LOG_BASE - i;\n            }\n            rand.e = e;\n            rand.c = c;\n            return rand;\n        };\n    }();\n    /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.sum = function() {\n        var i = 1, args = arguments, sum = new BigNumber(args[0]);\n        for(; i < args.length;)sum = sum.plus(args[i++]);\n        return sum;\n    };\n    // PRIVATE FUNCTIONS\n    // Called by BigNumber and BigNumber.prototype.toString.\n    convertBase = function() {\n        var decimal = \"0123456789\";\n        /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */ function toBaseOut(str, baseIn, baseOut, alphabet) {\n            var j, arr = [\n                0\n            ], arrL, i = 0, len = str.length;\n            for(; i < len;){\n                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n                arr[0] += alphabet.indexOf(str.charAt(i++));\n                for(j = 0; j < arr.length; j++){\n                    if (arr[j] > baseOut - 1) {\n                        if (arr[j + 1] == null) arr[j + 1] = 0;\n                        arr[j + 1] += arr[j] / baseOut | 0;\n                        arr[j] %= baseOut;\n                    }\n                }\n            }\n            return arr.reverse();\n        }\n        // Convert a numeric string of baseIn to a numeric string of baseOut.\n        // If the caller is toString, we are converting from base 10 to baseOut.\n        // If the caller is BigNumber, we are converting from baseIn to base 10.\n        return function(str, baseIn, baseOut, sign, callerIsToString) {\n            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf(\".\"), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;\n            // Non-integer.\n            if (i >= 0) {\n                k = POW_PRECISION;\n                // Unlimited precision.\n                POW_PRECISION = 0;\n                str = str.replace(\".\", \"\");\n                y = new BigNumber(baseIn);\n                x = y.pow(str.length - i);\n                POW_PRECISION = k;\n                // Convert str as if an integer, then restore the fraction part by dividing the\n                // result by its base raised to a power.\n                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, \"0\"), 10, baseOut, decimal);\n                y.e = y.c.length;\n            }\n            // Convert the number as integer.\n            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));\n            // xc now represents str as an integer and converted to baseOut. e is the exponent.\n            e = k = xc.length;\n            // Remove trailing zeros.\n            for(; xc[--k] == 0; xc.pop());\n            // Zero?\n            if (!xc[0]) return alphabet.charAt(0);\n            // Does str represent an integer? If so, no need for the division.\n            if (i < 0) {\n                --e;\n            } else {\n                x.c = xc;\n                x.e = e;\n                // The sign is needed for correct rounding.\n                x.s = sign;\n                x = div(x, y, dp, rm, baseOut);\n                xc = x.c;\n                r = x.r;\n                e = x.e;\n            }\n            // xc now represents str converted to baseOut.\n            // The index of the rounding digit.\n            d = e + dp + 1;\n            // The rounding digit: the digit to the right of the digit that may be rounded up.\n            i = xc[d];\n            // Look at the rounding digits and mode to determine whether to round up.\n            k = baseOut / 2;\n            r = r || d < 0 || xc[d + 1] != null;\n            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));\n            // If the index of the rounding digit is not greater than zero, or xc represents\n            // zero, then the result of the base conversion is zero or, if rounding up, a value\n            // such as 0.00001.\n            if (d < 1 || !xc[0]) {\n                // 1^-dp or 0\n                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\n            } else {\n                // Truncate xc to the required number of decimal places.\n                xc.length = d;\n                // Round up?\n                if (r) {\n                    // Rounding up may mean the previous digit has to be rounded up and so on.\n                    for(--baseOut; ++xc[--d] > baseOut;){\n                        xc[d] = 0;\n                        if (!d) {\n                            ++e;\n                            xc = [\n                                1\n                            ].concat(xc);\n                        }\n                    }\n                }\n                // Determine trailing zeros.\n                for(k = xc.length; !xc[--k];);\n                // E.g. [4, 11, 15] becomes 4bf.\n                for(i = 0, str = \"\"; i <= k; str += alphabet.charAt(xc[i++]));\n                // Add leading zeros, decimal point and trailing zeros as required.\n                str = toFixedPoint(str, e, alphabet.charAt(0));\n            }\n            // The caller will add the sign.\n            return str;\n        };\n    }();\n    // Perform division in the specified base. Called by div and convertBase.\n    div = function() {\n        // Assume non-zero x and k.\n        function multiply(x, k, base) {\n            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;\n            for(x = x.slice(); i--;){\n                xlo = x[i] % SQRT_BASE;\n                xhi = x[i] / SQRT_BASE | 0;\n                m = khi * xlo + xhi * klo;\n                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;\n                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                x[i] = temp % base;\n            }\n            if (carry) x = [\n                carry\n            ].concat(x);\n            return x;\n        }\n        function compare(a, b, aL, bL) {\n            var i, cmp;\n            if (aL != bL) {\n                cmp = aL > bL ? 1 : -1;\n            } else {\n                for(i = cmp = 0; i < aL; i++){\n                    if (a[i] != b[i]) {\n                        cmp = a[i] > b[i] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            return cmp;\n        }\n        function subtract(a, b, aL, base) {\n            var i = 0;\n            // Subtract b from a.\n            for(; aL--;){\n                a[aL] -= i;\n                i = a[aL] < b[aL] ? 1 : 0;\n                a[aL] = i * base + a[aL] - b[aL];\n            }\n            // Remove leading zeros.\n            for(; !a[0] && a.length > 1; a.splice(0, 1));\n        }\n        // x: dividend, y: divisor.\n        return function(x, y, dp, rm, base) {\n            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;\n            // Either NaN, Infinity or 0?\n            if (!xc || !xc[0] || !yc || !yc[0]) {\n                return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.\n                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);\n            }\n            q = new BigNumber(s);\n            qc = q.c = [];\n            e = x.e - y.e;\n            s = dp + e + 1;\n            if (!base) {\n                base = BASE;\n                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                s = s / LOG_BASE | 0;\n            }\n            // Result exponent may be one less then the current value of e.\n            // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n            for(i = 0; yc[i] == (xc[i] || 0); i++);\n            if (yc[i] > (xc[i] || 0)) e--;\n            if (s < 0) {\n                qc.push(1);\n                more = true;\n            } else {\n                xL = xc.length;\n                yL = yc.length;\n                i = 0;\n                s += 2;\n                // Normalise xc and yc so highest order digit of yc is >= base / 2.\n                n = mathfloor(base / (yc[0] + 1));\n                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                if (n > 1) {\n                    yc = multiply(yc, n, base);\n                    xc = multiply(xc, n, base);\n                    yL = yc.length;\n                    xL = xc.length;\n                }\n                xi = yL;\n                rem = xc.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL; rem[remL++] = 0);\n                yz = yc.slice();\n                yz = [\n                    0\n                ].concat(yz);\n                yc0 = yc[0];\n                if (yc[1] >= base / 2) yc0++;\n                // Not necessary, but to prevent trial digit n > base, when using base 3.\n                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n                do {\n                    n = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yc, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, n.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // n is how many times the divisor goes into the current remainder.\n                        n = mathfloor(rem0 / yc0);\n                        //  Algorithm:\n                        //  product = divisor multiplied by trial digit (n).\n                        //  Compare product and remainder.\n                        //  If product is greater than remainder:\n                        //    Subtract divisor from product, decrement trial digit.\n                        //  Subtract product from remainder.\n                        //  If product was less than remainder at the last compare:\n                        //    Compare new remainder and divisor.\n                        //    If remainder is greater than divisor:\n                        //      Subtract divisor from remainder, increment trial digit.\n                        if (n > 1) {\n                            // n may be > base only when base is 3.\n                            if (n >= base) n = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiply(yc, n, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            // If product > remainder then trial digit n too high.\n                            // n is 1 too high about 5% of the time, and is not known to have\n                            // ever been more than 1 too high.\n                            while(compare(prod, rem, prodL, remL) == 1){\n                                n--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                prodL = prod.length;\n                                cmp = 1;\n                            }\n                        } else {\n                            // n is 0 or 1, cmp is -1.\n                            // If n is 0, there is no need to compare yc and rem again below,\n                            // so change cmp to 1 to avoid it.\n                            // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                            if (n == 0) {\n                                // divisor < remainder, so n must be at least 1.\n                                cmp = n = 1;\n                            }\n                            // product = divisor\n                            prod = yc.slice();\n                            prodL = prod.length;\n                        }\n                        if (prodL < remL) prod = [\n                            0\n                        ].concat(prod);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        remL = rem.length;\n                        // If product was < remainder.\n                        if (cmp == -1) {\n                            // Compare divisor and new remainder.\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            // Trial digit n too low.\n                            // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                            while(compare(yc, rem, yL, remL) < 1){\n                                n++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yc, remL, base);\n                                remL = rem.length;\n                            }\n                        }\n                    } else if (cmp === 0) {\n                        n++;\n                        rem = [\n                            0\n                        ];\n                    } // else cmp === 1 and n will be 0\n                    // Add the next digit, n, to the result array.\n                    qc[i++] = n;\n                    // Update the remainder.\n                    if (rem[0]) {\n                        rem[remL++] = xc[xi] || 0;\n                    } else {\n                        rem = [\n                            xc[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] != null) && s--);\n                more = rem[0] != null;\n                // Leading zero?\n                if (!qc[0]) qc.splice(0, 1);\n            }\n            if (base == BASE) {\n                // To calculate q.e, first get the number of digits of qc[0].\n                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n            // Caller is convertBase.\n            } else {\n                q.e = e;\n                q.r = +more;\n            }\n            return q;\n        };\n    }();\n    /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */ function format(n, i, rm, id) {\n        var c0, e, ne, len, str;\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        if (!n.c) return n.toString();\n        c0 = n.c[0];\n        ne = n.e;\n        if (i == null) {\n            str = coeffToString(n.c);\n            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, \"0\");\n        } else {\n            n = round(new BigNumber(n), i, rm);\n            // n.e may have changed if the value was rounded up.\n            e = n.e;\n            str = coeffToString(n.c);\n            len = str.length;\n            // toPrecision returns exponential notation if the number of significant digits\n            // specified is less than the number of digits necessary to represent the integer\n            // part of the value in fixed-point notation.\n            // Exponential notation.\n            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n                // Append zeros?\n                for(; len < i; str += \"0\", len++);\n                str = toExponential(str, e);\n            // Fixed-point notation.\n            } else {\n                i -= ne + (id === 2 && e > ne);\n                str = toFixedPoint(str, e, \"0\");\n                // Append zeros?\n                if (e + 1 > len) {\n                    if (--i > 0) for(str += \".\"; i--; str += \"0\");\n                } else {\n                    i += e - len;\n                    if (i > 0) {\n                        if (e + 1 == len) str += \".\";\n                        for(; i--; str += \"0\");\n                    }\n                }\n            }\n        }\n        return n.s < 0 && c0 ? \"-\" + str : str;\n    }\n    // Handle BigNumber.max and BigNumber.min.\n    // If any number is NaN, return NaN.\n    function maxOrMin(args, n) {\n        var k, y, i = 1, x = new BigNumber(args[0]);\n        for(; i < args.length; i++){\n            y = new BigNumber(args[i]);\n            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\n                x = y;\n            }\n        }\n        return x;\n    }\n    /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */ function normalise(n, c, e) {\n        var i = 1, j = c.length;\n        // Remove trailing zeros.\n        for(; !c[--j]; c.pop());\n        // Calculate the base 10 exponent. First get the number of digits of c[0].\n        for(j = c[0]; j >= 10; j /= 10, i++);\n        // Overflow?\n        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n            // Infinity.\n            n.c = n.e = null;\n        // Underflow?\n        } else if (e < MIN_EXP) {\n            // Zero.\n            n.c = [\n                n.e = 0\n            ];\n        } else {\n            n.e = e;\n            n.c = c;\n        }\n        return n;\n    }\n    // Handle values that fail the validity test in BigNumber.\n    parseNumeric = function() {\n        var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, dotAfter = /^([^.]+)\\.$/, dotBefore = /^\\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n        return function(x, str, isNum, b) {\n            var base, s = isNum ? str : str.replace(whitespaceOrPlus, \"\");\n            // No exception on ±Infinity or NaN.\n            if (isInfinityOrNaN.test(s)) {\n                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n            } else {\n                if (!isNum) {\n                    // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                    s = s.replace(basePrefix, function(m, p1, p2) {\n                        base = (p2 = p2.toLowerCase()) == \"x\" ? 16 : p2 == \"b\" ? 2 : 8;\n                        return !b || b == base ? p1 : m;\n                    });\n                    if (b) {\n                        base = b;\n                        // E.g. '1.' to '1', '.1' to '0.1'\n                        s = s.replace(dotAfter, \"$1\").replace(dotBefore, \"0.$1\");\n                    }\n                    if (str != s) return new BigNumber(s, base);\n                }\n                // '[BigNumber Error] Not a number: {n}'\n                // '[BigNumber Error] Not a base {b} number: {n}'\n                if (BigNumber.DEBUG) {\n                    throw Error(bignumberError + \"Not a\" + (b ? \" base \" + b : \"\") + \" number: \" + str);\n                }\n                // NaN\n                x.s = null;\n            }\n            x.c = x.e = null;\n        };\n    }();\n    /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */ function round(x, sd, rm, r) {\n        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;\n        // if x is not Infinity or NaN...\n        if (xc) {\n            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n            // n is a base 1e14 number, the value of the element of array x.c containing rd.\n            // ni is the index of n within x.c.\n            // d is the number of digits of n.\n            // i is the index of rd within n including leading zeros.\n            // j is the actual index of rd within n (if < 0, rd is a leading zero).\n            out: {\n                // Get the number of digits of the first element of xc.\n                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                i = sd - d;\n                // If the rounding digit is in the first element of xc...\n                if (i < 0) {\n                    i += LOG_BASE;\n                    j = sd;\n                    n = xc[ni = 0];\n                    // Get the rounding digit at index j of n.\n                    rd = mathfloor(n / pows10[d - j - 1] % 10);\n                } else {\n                    ni = mathceil((i + 1) / LOG_BASE);\n                    if (ni >= xc.length) {\n                        if (r) {\n                            // Needed by sqrt.\n                            for(; xc.length <= ni; xc.push(0));\n                            n = rd = 0;\n                            d = 1;\n                            i %= LOG_BASE;\n                            j = i - LOG_BASE + 1;\n                        } else {\n                            break out;\n                        }\n                    } else {\n                        n = k = xc[ni];\n                        // Get the number of digits of n.\n                        for(d = 1; k >= 10; k /= 10, d++);\n                        // Get the index of rd within n.\n                        i %= LOG_BASE;\n                        // Get the index of rd within n, adjusted for leading zeros.\n                        // The number of leading zeros of n is given by LOG_BASE - d.\n                        j = i - LOG_BASE + d;\n                        // Get the rounding digit at index j of n.\n                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\n                    }\n                }\n                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?\n                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n                if (sd < 1 || !xc[0]) {\n                    xc.length = 0;\n                    if (r) {\n                        // Convert sd to decimal places.\n                        sd -= x.e + 1;\n                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                        x.e = -sd || 0;\n                    } else {\n                        // Zero.\n                        xc[0] = x.e = 0;\n                    }\n                    return x;\n                }\n                // Remove excess digits.\n                if (i == 0) {\n                    xc.length = ni;\n                    k = 1;\n                    ni--;\n                } else {\n                    xc.length = ni + 1;\n                    k = pows10[LOG_BASE - i];\n                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                    // j > 0 means i > number of leading zeros of n.\n                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                }\n                // Round up?\n                if (r) {\n                    for(;;){\n                        // If the digit to be rounded up is in the first element of xc...\n                        if (ni == 0) {\n                            // i will be the length of xc[0] before k is added.\n                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                            j = xc[0] += k;\n                            for(k = 1; j >= 10; j /= 10, k++);\n                            // if i != k the length has increased.\n                            if (i != k) {\n                                x.e++;\n                                if (xc[0] == BASE) xc[0] = 1;\n                            }\n                            break;\n                        } else {\n                            xc[ni] += k;\n                            if (xc[ni] != BASE) break;\n                            xc[ni--] = 0;\n                            k = 1;\n                        }\n                    }\n                }\n                // Remove trailing zeros.\n                for(i = xc.length; xc[--i] === 0; xc.pop());\n            }\n            // Overflow? Infinity.\n            if (x.e > MAX_EXP) {\n                x.c = x.e = null;\n            // Underflow? Zero.\n            } else if (x.e < MIN_EXP) {\n                x.c = [\n                    x.e = 0\n                ];\n            }\n        }\n        return x;\n    }\n    function valueOf(n) {\n        var str, e = n.e;\n        if (e === null) return n.toString();\n        str = coeffToString(n.c);\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, \"0\");\n        return n.s < 0 ? \"-\" + str : str;\n    }\n    // PROTOTYPE/INSTANCE METHODS\n    /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */ P.absoluteValue = P.abs = function() {\n        var x = new BigNumber(this);\n        if (x.s < 0) x.s = 1;\n        return x;\n    };\n    /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */ P.comparedTo = function(y, b) {\n        return compare(this, new BigNumber(y, b));\n    };\n    /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.decimalPlaces = P.dp = function(dp, rm) {\n        var c, n, v, x = this;\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), dp + x.e + 1, rm);\n        }\n        if (!(c = x.c)) return null;\n        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last number.\n        if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);\n        if (n < 0) n = 0;\n        return n;\n    };\n    /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.dividedBy = P.div = function(y, b) {\n        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */ P.dividedToIntegerBy = P.idiv = function(y, b) {\n        return div(this, new BigNumber(y, b), 0, 1);\n    };\n    /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */ P.exponentiatedBy = P.pow = function(n, m) {\n        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;\n        n = new BigNumber(n);\n        // Allow NaN and ±Infinity, but not other non-integers.\n        if (n.c && !n.isInteger()) {\n            throw Error(bignumberError + \"Exponent not an integer: \" + valueOf(n));\n        }\n        if (m != null) m = new BigNumber(m);\n        // Exponent of MAX_SAFE_INTEGER is 15.\n        nIsBig = n.e > 14;\n        // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\n        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n            // The sign of the result of pow when x is negative depends on the evenness of n.\n            // If +n overflows to ±Infinity, the evenness of n would be not be known.\n            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\n            return m ? y.mod(m) : y;\n        }\n        nIsNeg = n.s < 0;\n        if (m) {\n            // x % m returns NaN if abs(m) is zero, or m is NaN.\n            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n            isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n            if (isModExp) x = x.mod(m);\n        // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\n        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\n        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n            // If x is negative and n is odd, k = -0, else k = 0.\n            k = x.s < 0 && isOdd(n) ? -0 : 0;\n            // If x >= 1, k = ±Infinity.\n            if (x.e > -1) k = 1 / k;\n            // If n is negative return ±0, else return ±Infinity.\n            return new BigNumber(nIsNeg ? 1 / k : k);\n        } else if (POW_PRECISION) {\n            // Truncating each coefficient array to a length of k after each multiplication\n            // equates to truncating significant digits to POW_PRECISION + [28, 41],\n            // i.e. there will be a minimum of 28 guard digits retained.\n            k = mathceil(POW_PRECISION / LOG_BASE + 2);\n        }\n        if (nIsBig) {\n            half = new BigNumber(0.5);\n            if (nIsNeg) n.s = 1;\n            nIsOdd = isOdd(n);\n        } else {\n            i = Math.abs(+valueOf(n));\n            nIsOdd = i % 2;\n        }\n        y = new BigNumber(ONE);\n        // Performs 54 loop iterations for n of 9007199254740991.\n        for(;;){\n            if (nIsOdd) {\n                y = y.times(x);\n                if (!y.c) break;\n                if (k) {\n                    if (y.c.length > k) y.c.length = k;\n                } else if (isModExp) {\n                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                }\n            }\n            if (i) {\n                i = mathfloor(i / 2);\n                if (i === 0) break;\n                nIsOdd = i % 2;\n            } else {\n                n = n.times(half);\n                round(n, n.e + 1, 1);\n                if (n.e > 14) {\n                    nIsOdd = isOdd(n);\n                } else {\n                    i = +valueOf(n);\n                    if (i === 0) break;\n                    nIsOdd = i % 2;\n                }\n            }\n            x = x.times(x);\n            if (k) {\n                if (x.c && x.c.length > k) x.c.length = k;\n            } else if (isModExp) {\n                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n            }\n        }\n        if (isModExp) return y;\n        if (nIsNeg) y = ONE.div(y);\n        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */ P.integerValue = function(rm) {\n        var n = new BigNumber(this);\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        return round(n, n.e + 1, rm);\n    };\n    /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isEqualTo = P.eq = function(y, b) {\n        return compare(this, new BigNumber(y, b)) === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */ P.isFinite = function() {\n        return !!this.c;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isGreaterThan = P.gt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */ P.isInteger = function() {\n        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isLessThan = P.lt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isLessThanOrEqualTo = P.lte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */ P.isNaN = function() {\n        return !this.s;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */ P.isNegative = function() {\n        return this.s < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */ P.isPositive = function() {\n        return this.s > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */ P.isZero = function() {\n        return !!this.c && this.c[0] == 0;\n    };\n    /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */ P.minus = function(y, b) {\n        var i, j, t, xLTy, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.plus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Either Infinity?\n            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n            // Either zero?\n            if (!xc[0] || !yc[0]) {\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                ROUNDING_MODE == 3 ? -0 : 0);\n            }\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Determine which is the bigger number.\n        if (a = xe - ye) {\n            if (xLTy = a < 0) {\n                a = -a;\n                t = xc;\n            } else {\n                ye = xe;\n                t = yc;\n            }\n            t.reverse();\n            // Prepend zeros to equalise exponents.\n            for(b = a; b--; t.push(0));\n            t.reverse();\n        } else {\n            // Exponents equal. Check digit by digit.\n            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n            for(a = b = 0; b < j; b++){\n                if (xc[b] != yc[b]) {\n                    xLTy = xc[b] < yc[b];\n                    break;\n                }\n            }\n        }\n        // x < y? Point xc to the array of the bigger number.\n        if (xLTy) {\n            t = xc;\n            xc = yc;\n            yc = t;\n            y.s = -y.s;\n        }\n        b = (j = yc.length) - (i = xc.length);\n        // Append zeros to xc if shorter.\n        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n        if (b > 0) for(; b--; xc[i++] = 0);\n        b = BASE - 1;\n        // Subtract yc from xc.\n        for(; j > a;){\n            if (xc[--j] < yc[j]) {\n                for(i = j; i && !xc[--i]; xc[i] = b);\n                --xc[i];\n                xc[j] += BASE;\n            }\n            xc[j] -= yc[j];\n        }\n        // Remove leading zeros and adjust exponent accordingly.\n        for(; xc[0] == 0; xc.splice(0, 1), --ye);\n        // Zero?\n        if (!xc[0]) {\n            // Following IEEE 754 (2008) 6.3,\n            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n            y.s = ROUNDING_MODE == 3 ? -1 : 1;\n            y.c = [\n                y.e = 0\n            ];\n            return y;\n        }\n        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n        // for finite x and y.\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */ P.modulo = P.mod = function(y, b) {\n        var q, s, x = this;\n        y = new BigNumber(y, b);\n        // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n        if (!x.c || !y.s || y.c && !y.c[0]) {\n            return new BigNumber(NaN);\n        // Return x if y is Infinity or x is zero.\n        } else if (!y.c || x.c && !x.c[0]) {\n            return new BigNumber(x);\n        }\n        if (MODULO_MODE == 9) {\n            // Euclidian division: q = sign(y) * floor(x / abs(y))\n            // r = x - qy    where  0 <= r < abs(y)\n            s = y.s;\n            y.s = 1;\n            q = div(x, y, 0, 3);\n            y.s = s;\n            q.s *= s;\n        } else {\n            q = div(x, y, 0, MODULO_MODE);\n        }\n        y = x.minus(q.times(y));\n        // To match JavaScript %, ensure sign of zero is sign of dividend.\n        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n        return y;\n    };\n    /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */ P.multipliedBy = P.times = function(y, b) {\n        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;\n        // Either NaN, ±Infinity or ±0?\n        if (!xc || !yc || !xc[0] || !yc[0]) {\n            // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                y.c = y.e = y.s = null;\n            } else {\n                y.s *= x.s;\n                // Return ±Infinity if either is ±Infinity.\n                if (!xc || !yc) {\n                    y.c = y.e = null;\n                // Return ±0 if either is ±0.\n                } else {\n                    y.c = [\n                        0\n                    ];\n                    y.e = 0;\n                }\n            }\n            return y;\n        }\n        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n        y.s *= x.s;\n        xcL = xc.length;\n        ycL = yc.length;\n        // Ensure xc points to longer array and xcL to its length.\n        if (xcL < ycL) {\n            zc = xc;\n            xc = yc;\n            yc = zc;\n            i = xcL;\n            xcL = ycL;\n            ycL = i;\n        }\n        // Initialise the result array with zeros.\n        for(i = xcL + ycL, zc = []; i--; zc.push(0));\n        base = BASE;\n        sqrtBase = SQRT_BASE;\n        for(i = ycL; --i >= 0;){\n            c = 0;\n            ylo = yc[i] % sqrtBase;\n            yhi = yc[i] / sqrtBase | 0;\n            for(k = xcL, j = i + k; j > i;){\n                xlo = xc[--k] % sqrtBase;\n                xhi = xc[k] / sqrtBase | 0;\n                m = yhi * xlo + xhi * ylo;\n                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;\n                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                zc[j--] = xlo % base;\n            }\n            zc[j] = c;\n        }\n        if (c) {\n            ++e;\n        } else {\n            zc.splice(0, 1);\n        }\n        return normalise(y, zc, e);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */ P.negated = function() {\n        var x = new BigNumber(this);\n        x.s = -x.s || null;\n        return x;\n    };\n    /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */ P.plus = function(y, b) {\n        var t, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.minus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Return ±Infinity if either ±Infinity.\n            if (!xc || !yc) return new BigNumber(a / 0);\n            // Either zero?\n            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n        if (a = xe - ye) {\n            if (a > 0) {\n                ye = xe;\n                t = yc;\n            } else {\n                a = -a;\n                t = xc;\n            }\n            t.reverse();\n            for(; a--; t.push(0));\n            t.reverse();\n        }\n        a = xc.length;\n        b = yc.length;\n        // Point xc to the longer array, and b to the shorter length.\n        if (a - b < 0) {\n            t = yc;\n            yc = xc;\n            xc = t;\n            b = a;\n        }\n        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n        for(a = 0; b;){\n            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n        }\n        if (a) {\n            xc = [\n                a\n            ].concat(xc);\n            ++ye;\n        }\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n        // ye = MAX_EXP + 1 possible\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.precision = P.sd = function(sd, rm) {\n        var c, n, v, x = this;\n        if (sd != null && sd !== !!sd) {\n            intCheck(sd, 1, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), sd, rm);\n        }\n        if (!(c = x.c)) return null;\n        v = c.length - 1;\n        n = v * LOG_BASE + 1;\n        if (v = c[v]) {\n            // Subtract the number of trailing zeros of the last element.\n            for(; v % 10 == 0; v /= 10, n--);\n            // Add the number of digits of the first element.\n            for(v = c[0]; v >= 10; v /= 10, n++);\n        }\n        if (sd && x.e + 1 > n) n = x.e + 1;\n        return n;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */ P.shiftedBy = function(k) {\n        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n        return this.times(\"1e\" + k);\n    };\n    /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.squareRoot = P.sqrt = function() {\n        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber(\"0.5\");\n        // Negative/NaN/Infinity/zero?\n        if (s !== 1 || !c || !c[0]) {\n            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n        }\n        // Initial estimate.\n        s = Math.sqrt(+valueOf(x));\n        // Math.sqrt underflow/overflow?\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n        if (s == 0 || s == 1 / 0) {\n            n = coeffToString(c);\n            if ((n.length + e) % 2 == 0) n += \"0\";\n            s = Math.sqrt(+n);\n            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n            if (s == 1 / 0) {\n                n = \"5e\" + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n            }\n            r = new BigNumber(n);\n        } else {\n            r = new BigNumber(s + \"\");\n        }\n        // Check for zero.\n        // r could be zero if MIN_EXP is changed after the this value was created.\n        // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n        // coeffToString to throw.\n        if (r.c[0]) {\n            e = r.e;\n            s = e + dp;\n            if (s < 3) s = 0;\n            // Newton-Raphson iteration.\n            for(;;){\n                t = r;\n                r = half.times(t.plus(div(x, t, dp, 1)));\n                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\n                    // The exponent of r may here be one less than the final result exponent,\n                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                    // are indexed correctly.\n                    if (r.e < e) --s;\n                    n = n.slice(s - 3, s + 1);\n                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                    // iteration.\n                    if (n == \"9999\" || !rep && n == \"4999\") {\n                        // On the first iteration only, check to see if rounding up gives the\n                        // exact result as the nines may infinitely repeat.\n                        if (!rep) {\n                            round(t, t.e + DECIMAL_PLACES + 2, 0);\n                            if (t.times(t).eq(x)) {\n                                r = t;\n                                break;\n                            }\n                        }\n                        dp += 4;\n                        s += 4;\n                        rep = 1;\n                    } else {\n                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                        // result. If not, then there are further digits and m will be truthy.\n                        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                            // Truncate to the first rounding digit.\n                            round(r, r.e + DECIMAL_PLACES + 2, 1);\n                            m = !r.times(r).eq(x);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toExponential = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp++;\n        }\n        return format(this, dp, rm, 1);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toFixed = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp = dp + this.e + 1;\n        }\n        return format(this, dp, rm);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */ P.toFormat = function(dp, rm, format) {\n        var str, x = this;\n        if (format == null) {\n            if (dp != null && rm && typeof rm == \"object\") {\n                format = rm;\n                rm = null;\n            } else if (dp && typeof dp == \"object\") {\n                format = dp;\n                dp = rm = null;\n            } else {\n                format = FORMAT;\n            }\n        } else if (typeof format != \"object\") {\n            throw Error(bignumberError + \"Argument not an object: \" + format);\n        }\n        str = x.toFixed(dp, rm);\n        if (x.c) {\n            var i, arr = str.split(\".\"), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || \"\", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;\n            if (g2) {\n                i = g1;\n                g1 = g2;\n                g2 = i;\n                len -= i;\n            }\n            if (g1 > 0 && len > 0) {\n                i = len % g1 || g1;\n                intPart = intDigits.substr(0, i);\n                for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);\n                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                if (isNeg) intPart = \"-\" + intPart;\n            }\n            str = fractionPart ? intPart + (format.decimalSeparator || \"\") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp(\"\\\\d{\" + g2 + \"}\\\\B\", \"g\"), \"$&\" + (format.fractionGroupSeparator || \"\")) : fractionPart) : intPart;\n        }\n        return (format.prefix || \"\") + str + (format.suffix || \"\");\n    };\n    /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */ P.toFraction = function(md) {\n        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;\n        if (md != null) {\n            n = new BigNumber(md);\n            // Throw if md is less than one or is not an integer, unless it is Infinity.\n            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                throw Error(bignumberError + \"Argument \" + (n.isInteger() ? \"out of range: \" : \"not an integer: \") + valueOf(n));\n            }\n        }\n        if (!xc) return new BigNumber(x);\n        d = new BigNumber(ONE);\n        n1 = d0 = new BigNumber(ONE);\n        d1 = n0 = new BigNumber(ONE);\n        s = coeffToString(xc);\n        // Determine initial denominator.\n        // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n        e = d.e = s.length - x.e - 1;\n        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;\n        exp = MAX_EXP;\n        MAX_EXP = 1 / 0;\n        n = new BigNumber(s);\n        // n0 = d1 = 0\n        n0.c[0] = 0;\n        for(;;){\n            q = div(n, d, 0, 1);\n            d2 = d0.plus(q.times(d1));\n            if (d2.comparedTo(md) == 1) break;\n            d0 = d1;\n            d1 = d2;\n            n1 = n0.plus(q.times(d2 = n1));\n            n0 = d2;\n            d = n.minus(q.times(d2 = d));\n            n = d2;\n        }\n        d2 = div(md.minus(d0), d1, 0, 1);\n        n0 = n0.plus(d2.times(n1));\n        d0 = d0.plus(d2.times(d1));\n        n0.s = n1.s = x.s;\n        e = e * 2;\n        // Determine which fraction is closer to x, n0/d0 or n1/d1\n        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [\n            n1,\n            d1\n        ] : [\n            n0,\n            d0\n        ];\n        MAX_EXP = exp;\n        return r;\n    };\n    /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */ P.toNumber = function() {\n        return +valueOf(this);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.toPrecision = function(sd, rm) {\n        if (sd != null) intCheck(sd, 1, MAX);\n        return format(this, sd, rm, 2);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */ P.toString = function(b) {\n        var str, n = this, s = n.s, e = n.e;\n        // Infinity or NaN?\n        if (e === null) {\n            if (s) {\n                str = \"Infinity\";\n                if (s < 0) str = \"-\" + str;\n            } else {\n                str = \"NaN\";\n            }\n        } else {\n            if (b == null) {\n                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, \"0\");\n            } else if (b === 10 && alphabetHasNormalDecimalDigits) {\n                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\n                str = toFixedPoint(coeffToString(n.c), n.e, \"0\");\n            } else {\n                intCheck(b, 2, ALPHABET.length, \"Base\");\n                str = convertBase(toFixedPoint(coeffToString(n.c), e, \"0\"), 10, b, s, true);\n            }\n            if (s < 0 && n.c[0]) str = \"-\" + str;\n        }\n        return str;\n    };\n    /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */ P.valueOf = P.toJSON = function() {\n        return valueOf(this);\n    };\n    P._isBigNumber = true;\n    P[Symbol.toStringTag] = \"BigNumber\";\n    // Node.js v10.12.0+\n    P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.valueOf;\n    if (configObject != null) BigNumber.set(configObject);\n    return BigNumber;\n}\n// PRIVATE HELPER FUNCTIONS\n// These functions don't need access to variables,\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\nfunction bitFloor(n) {\n    var i = n | 0;\n    return n > 0 || n === i ? i : i - 1;\n}\n// Return a coefficient array as a string of base 10 digits.\nfunction coeffToString(a) {\n    var s, z, i = 1, j = a.length, r = a[0] + \"\";\n    for(; i < j;){\n        s = a[i++] + \"\";\n        z = LOG_BASE - s.length;\n        for(; z--; s = \"0\" + s);\n        r += s;\n    }\n    // Determine trailing zeros.\n    for(j = r.length; r.charCodeAt(--j) === 48;);\n    return r.slice(0, j + 1 || 1);\n}\n// Compare the value of BigNumbers x and y.\nfunction compare(x, y) {\n    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either NaN?\n    if (!i || !j) return null;\n    a = xc && !xc[0];\n    b = yc && !yc[0];\n    // Either zero?\n    if (a || b) return a ? b ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    a = i < 0;\n    b = k == l;\n    // Either Infinity?\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n    // Compare exponents.\n    if (!b) return k > l ^ a ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\n}\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */ function intCheck(n, min, max, name) {\n    if (n < min || n > max || n !== mathfloor(n)) {\n        throw Error(bignumberError + (name || \"Argument\") + (typeof n == \"number\" ? n < min || n > max ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(n));\n    }\n}\n// Assumes finite n.\nfunction isOdd(n) {\n    var k = n.c.length - 1;\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n}\nfunction toExponential(str, e) {\n    return (str.length > 1 ? str.charAt(0) + \".\" + str.slice(1) : str) + (e < 0 ? \"e\" : \"e+\") + e;\n}\nfunction toFixedPoint(str, e, z) {\n    var len, zs;\n    // Negative exponent?\n    if (e < 0) {\n        // Prepend zeros.\n        for(zs = z + \".\"; ++e; zs += z);\n        str = zs + str;\n    // Positive exponent\n    } else {\n        len = str.length;\n        // Append zeros.\n        if (++e > len) {\n            for(zs = z, e -= len; --e; zs += z);\n            str += zs;\n        } else if (e < len) {\n            str = str.slice(0, e) + \".\" + str.slice(e);\n        }\n    }\n    return str;\n}\n// EXPORT\nvar BigNumber = clone();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigNumber);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYmlnbnVtYmVyLmpzQDkuMy4xL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2Q0MsR0FHRCxJQUNFQSxZQUFZLDhDQUNaQyxXQUFXQyxLQUFLQyxJQUFJLEVBQ3BCQyxZQUFZRixLQUFLRyxLQUFLLEVBRXRCQyxpQkFBaUIsc0JBQ2pCQyxnQkFBZ0JELGlCQUFpQiwwREFFakNFLE9BQU8sTUFDUEMsV0FBVyxJQUNYQyxtQkFBbUIsa0JBQ25CLHdEQUF3RDtBQUN4REMsV0FBVztJQUFDO0lBQUc7SUFBSTtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUFNO0lBQU07Q0FBSyxFQUNsRkMsWUFBWSxLQUVaLFdBQVc7QUFDWCwwRkFBMEY7QUFDMUYsc0VBQXNFO0FBQ3RFQyxNQUFNLEtBQXVDLGlCQUFpQjtBQUdoRTs7Q0FFQyxHQUNELFNBQVNDLE1BQU1DLFlBQVk7SUFDekIsSUFBSUMsS0FBS0MsYUFBYUMsY0FDcEJDLElBQUlDLFVBQVVDLFNBQVMsR0FBRztRQUFFQyxhQUFhRjtRQUFXRyxVQUFVO1FBQU1DLFNBQVM7SUFBSyxHQUNsRkMsTUFBTSxJQUFJTCxVQUFVLElBR3BCLHdGQUF3RjtJQUd4RixnRkFBZ0Y7SUFDaEYsa0VBQWtFO0lBRWxFLDBFQUEwRTtJQUMxRU0saUJBQWlCLElBRWpCLG1GQUFtRjtJQUNuRiwrRUFBK0U7SUFDL0UsK0JBQStCO0lBQy9CLDZCQUE2QjtJQUM3QixrQ0FBa0M7SUFDbEMsa0NBQWtDO0lBQ2xDLDhEQUE4RDtJQUM5RCxnRUFBZ0U7SUFDaEUsa0ZBQWtGO0lBQ2xGLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0VDLGdCQUFnQixHQUVoQiw2Q0FBNkM7SUFFN0MsaUZBQWlGO0lBQ2pGLGtCQUFr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dEUsRUFBRS9DLENBQUMsR0FBRzFDLGFBQWF1RyxLQUFLZCxFQUFFakQsQ0FBQyxDQUFDK0QsRUFBRSxHQUFHLEtBQUs7QUFDeEQ7QUFHQSxTQUFTNkQsY0FBY3RILEdBQUcsRUFBRUosQ0FBQztJQUMzQixPQUFPLENBQUNJLElBQUlZLE1BQU0sR0FBRyxJQUFJWixJQUFJaUIsTUFBTSxDQUFDLEtBQUssTUFBTWpCLElBQUlJLEtBQUssQ0FBQyxLQUFLSixHQUFFLElBQzlESixDQUFBQSxJQUFJLElBQUksTUFBTSxJQUFHLElBQUtBO0FBQzFCO0FBR0EsU0FBU3FGLGFBQWFqRixHQUFHLEVBQUVKLENBQUMsRUFBRW9OLENBQUM7SUFDN0IsSUFBSWpOLEtBQUtvTjtJQUVULHFCQUFxQjtJQUNyQixJQUFJdk4sSUFBSSxHQUFHO1FBRVQsaUJBQWlCO1FBQ2pCLElBQUt1TixLQUFLSCxJQUFJLEtBQUssRUFBRXBOLEdBQUd1TixNQUFNSDtRQUM5QmhOLE1BQU1tTixLQUFLbk47SUFFYixvQkFBb0I7SUFDcEIsT0FBTztRQUNMRCxNQUFNQyxJQUFJWSxNQUFNO1FBRWhCLGdCQUFnQjtRQUNoQixJQUFJLEVBQUVoQixJQUFJRyxLQUFLO1lBQ2IsSUFBS29OLEtBQUtILEdBQUdwTixLQUFLRyxLQUFLLEVBQUVILEdBQUd1TixNQUFNSDtZQUNsQ2hOLE9BQU9tTjtRQUNULE9BQU8sSUFBSXZOLElBQUlHLEtBQUs7WUFDbEJDLE1BQU1BLElBQUlJLEtBQUssQ0FBQyxHQUFHUixLQUFLLE1BQU1JLElBQUlJLEtBQUssQ0FBQ1I7UUFDMUM7SUFDRjtJQUVBLE9BQU9JO0FBQ1Q7QUFHQSxTQUFTO0FBR0YsSUFBSW5DLFlBQVlOLFFBQVE7QUFFL0IsaUVBQWVNLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVzYWxlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9iaWdudW1iZXIuanNAOS4zLjEvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIubWpzP2ZmOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMy4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG52YXJcclxuICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICBCQVNFID0gMWUxNCxcclxuICBMT0dfQkFTRSA9IDE0LFxyXG4gIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgLy8gRURJVEFCTEVcclxuICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4vKlxyXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgLy9cclxuICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICBGT1JNQVQgPSB7XHJcbiAgICAgIHByZWZpeDogJycsXHJcbiAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIHN1ZmZpeDogJydcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICpcclxuICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5lID0gZTtcclxuICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gWmVyby5cclxuICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgKlxyXG4gICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAqXHJcbiAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgKlxyXG4gICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICpcclxuICAgKiBFLmcuXHJcbiAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICpcclxuICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgKlxyXG4gICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgKi9cclxuICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHZhciBwLCB2O1xyXG5cclxuICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgIH07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICpcclxuICAgKiB2IHthbnl9XHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgKi9cclxuICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgdmFyIGksIG4sXHJcbiAgICAgIGMgPSB2LmMsXHJcbiAgICAgIGUgPSB2LmUsXHJcbiAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IEVycm9yXHJcbiAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgLTEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgKi9cclxuICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBrID0gY1stLWldO1xyXG4gICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgIHJldHVybiByYW5kO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgIC8qXHJcbiAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgcmV0dXJuIHN1bTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgdmFyIGosXHJcbiAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgIGFyckwsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgLS1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICB4YyA9IHguYztcclxuICAgICAgICByID0geC5yO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgIHlMLCB5eixcclxuICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICpcclxuICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBjMCA9IG4uY1swXTtcclxuICAgIG5lID0gbi5lO1xyXG5cclxuICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpIC09IG5lICsgKGlkID09PSAyICYmIGUgPiBuZSk7XHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG4pIHtcclxuICAgIHZhciBrLCB5LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG4gICAgICBpZiAoIXkucyB8fCAoayA9IGNvbXBhcmUoeCwgeSkpID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XHJcbiAgICAgICAgeCA9IHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuLmUgPSBlO1xyXG4gICAgICBuLmMgPSBjO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgIH1cclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgcmQgPSBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICBuaS0tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAqL1xyXG4gIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5cclxuICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAqL1xyXG4gIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICpcclxuICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgYywgbiwgdixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC8gMCA9IElcclxuICAgKiAgbiAvIE4gPSBOXHJcbiAgICogIG4gLyBJID0gMFxyXG4gICAqICAwIC8gbiA9IDBcclxuICAgKiAgMCAvIDAgPSBOXHJcbiAgICogIDAgLyBOID0gTlxyXG4gICAqICAwIC8gSSA9IDBcclxuICAgKiAgTiAvIG4gPSBOXHJcbiAgICogIE4gLyAwID0gTlxyXG4gICAqICBOIC8gTiA9IE5cclxuICAgKiAgTiAvIEkgPSBOXHJcbiAgICogIEkgLyBuID0gSVxyXG4gICAqICBJIC8gMCA9IElcclxuICAgKiAgSSAvIE4gPSBOXHJcbiAgICogIEkgLyBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgKlxyXG4gICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAqXHJcbiAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAqXHJcbiAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAqL1xyXG4gIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgIH1cclxuXHJcbiAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgfVxyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkpIHtcclxuICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICBpZiAoaykge1xyXG4gICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAqL1xyXG4gIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMucztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC0gMCA9IG5cclxuICAgKiAgbiAtIE4gPSBOXHJcbiAgICogIG4gLSBJID0gLUlcclxuICAgKiAgMCAtIG4gPSAtblxyXG4gICAqICAwIC0gMCA9IDBcclxuICAgKiAgMCAtIE4gPSBOXHJcbiAgICogIDAgLSBJID0gLUlcclxuICAgKiAgTiAtIG4gPSBOXHJcbiAgICogIE4gLSAwID0gTlxyXG4gICAqICBOIC0gTiA9IE5cclxuICAgKiAgTiAtIEkgPSBOXHJcbiAgICogIEkgLSBuID0gSVxyXG4gICAqICBJIC0gMCA9IElcclxuICAgKiAgSSAtIE4gPSBOXHJcbiAgICogIEkgLSBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAqL1xyXG4gIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBhID0geC5zO1xyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgYiA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgeS5zID0gLWI7XHJcbiAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHllID0geGU7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgaWYgKHhMVHkpIHtcclxuICAgICAgdCA9IHhjO1xyXG4gICAgICB4YyA9IHljO1xyXG4gICAgICB5YyA9IHQ7XHJcbiAgICAgIHkucyA9IC15LnM7XHJcbiAgICB9XHJcblxyXG4gICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgLy8gWmVybz9cclxuICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgIG4gJSAwID0gIE5cclxuICAgKiAgIG4gJSBOID0gIE5cclxuICAgKiAgIG4gJSBJID0gIG5cclxuICAgKiAgIDAgJSBuID0gIDBcclxuICAgKiAgLTAgJSBuID0gLTBcclxuICAgKiAgIDAgJSAwID0gIE5cclxuICAgKiAgIDAgJSBOID0gIE5cclxuICAgKiAgIDAgJSBJID0gIDBcclxuICAgKiAgIE4gJSBuID0gIE5cclxuICAgKiAgIE4gJSAwID0gIE5cclxuICAgKiAgIE4gJSBOID0gIE5cclxuICAgKiAgIE4gJSBJID0gIE5cclxuICAgKiAgIEkgJSBuID0gIE5cclxuICAgKiAgIEkgJSAwID0gIE5cclxuICAgKiAgIEkgJSBOID0gIE5cclxuICAgKiAgIEkgJSBJID0gIE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICovXHJcbiAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICB2YXIgcSwgcyxcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICBzID0geS5zO1xyXG4gICAgICB5LnMgPSAxO1xyXG4gICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICB5LnMgPSBzO1xyXG4gICAgICBxLnMgKj0gcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgfVxyXG5cclxuICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgIHJldHVybiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICogMCA9IDBcclxuICAgKiAgbiAqIE4gPSBOXHJcbiAgICogIG4gKiBJID0gSVxyXG4gICAqICAwICogbiA9IDBcclxuICAgKiAgMCAqIDAgPSAwXHJcbiAgICogIDAgKiBOID0gTlxyXG4gICAqICAwICogSSA9IE5cclxuICAgKiAgTiAqIG4gPSBOXHJcbiAgICogIE4gKiAwID0gTlxyXG4gICAqICBOICogTiA9IE5cclxuICAgKiAgTiAqIEkgPSBOXHJcbiAgICogIEkgKiBuID0gSVxyXG4gICAqICBJICogMCA9IE5cclxuICAgKiAgSSAqIE4gPSBOXHJcbiAgICogIEkgKiBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIHkucyAqPSB4LnM7XHJcbiAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgaWYgKHhjTCA8IHljTCkge1xyXG4gICAgICB6YyA9IHhjO1xyXG4gICAgICB4YyA9IHljO1xyXG4gICAgICB5YyA9IHpjO1xyXG4gICAgICBpID0geGNMO1xyXG4gICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgIHljTCA9IGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgYmFzZSA9IEJBU0U7XHJcbiAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICBjID0gMDtcclxuICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB6Y1tqXSA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGMpIHtcclxuICAgICAgKytlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAqL1xyXG4gIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgIGlmIChhIC0gYiA8IDApIHtcclxuICAgICAgdCA9IHljO1xyXG4gICAgICB5YyA9IHhjO1xyXG4gICAgICB4YyA9IHQ7XHJcbiAgICAgIGIgPSBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhKSB7XHJcbiAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICsreWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICpcclxuICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAqL1xyXG4gIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICpcclxuICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgKi9cclxuICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIHNxcnQoLW4pID0gIE5cclxuICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICogIHNxcnQoLUkpID0gIE5cclxuICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICovXHJcbiAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGMgPSB4LmMsXHJcbiAgICAgIHMgPSB4LnMsXHJcbiAgICAgIGUgPSB4LmUsXHJcbiAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgIGUgPSByLmU7XHJcbiAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICBkcCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAqXHJcbiAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAqXHJcbiAgICogRk9STUFUID0ge1xyXG4gICAqICAgcHJlZml4OiAnJyxcclxuICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICogICBzdWZmaXg6ICcnXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgKi9cclxuICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgIGlmICh4LmMpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoZzIpIHtcclxuICAgICAgICBpID0gZzE7XHJcbiAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICBnMiA9IGk7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICA6IGludFBhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICpcclxuICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAqL1xyXG4gIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgLy8gbjAgPSBkMSA9IDBcclxuICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgIGZvciAoOyA7KSAge1xyXG4gICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgIGQwID0gZDE7XHJcbiAgICAgIGQxID0gZDI7XHJcbiAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgbjAgPSBkMjtcclxuICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgbiA9IGQyO1xyXG4gICAgfVxyXG5cclxuICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgZSA9IGUgKiAyO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAqL1xyXG4gIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAqL1xyXG4gIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICovXHJcbiAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICBuID0gdGhpcyxcclxuICAgICAgcyA9IG4ucyxcclxuICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICBpZiAocykge1xyXG4gICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAqL1xyXG4gIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgUFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0JpZ051bWJlcic7XHJcblxyXG4gIC8vIE5vZGUuanMgdjEwLjEyLjArXHJcbiAgUFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFAudmFsdWVPZjtcclxuXHJcbiAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gIHJldHVybiBCaWdOdW1iZXI7XHJcbn1cclxuXHJcblxyXG4vLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbi8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbi8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG5mdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgdmFyIGkgPSBuIHwgMDtcclxuICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxufVxyXG5cclxuXHJcbi8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG5mdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICB2YXIgcywgeixcclxuICAgIGkgPSAxLFxyXG4gICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICByICs9IHM7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxufVxyXG5cclxuXHJcbi8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgdmFyIGEsIGIsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0geS5jLFxyXG4gICAgaSA9IHgucyxcclxuICAgIGogPSB5LnMsXHJcbiAgICBrID0geC5lLFxyXG4gICAgbCA9IHkuZTtcclxuXHJcbiAgLy8gRWl0aGVyIE5hTj9cclxuICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICBhID0geGMgJiYgIXhjWzBdO1xyXG4gIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgYSA9IGkgPCAwO1xyXG4gIGIgPSBrID09IGw7XHJcblxyXG4gIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gKi9cclxuZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgdGhyb3cgRXJyb3JcclxuICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuZnVuY3Rpb24gaXNPZGQobikge1xyXG4gIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gIHZhciBsZW4sIHpzO1xyXG5cclxuICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICB9IGVsc2Uge1xyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgc3RyICs9IHpzO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBFWFBPUlRcclxuXHJcblxyXG5leHBvcnQgdmFyIEJpZ051bWJlciA9IGNsb25lKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCaWdOdW1iZXI7XHJcbiJdLCJuYW1lcyI6WyJpc051bWVyaWMiLCJtYXRoY2VpbCIsIk1hdGgiLCJjZWlsIiwibWF0aGZsb29yIiwiZmxvb3IiLCJiaWdudW1iZXJFcnJvciIsInRvb01hbnlEaWdpdHMiLCJCQVNFIiwiTE9HX0JBU0UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiUE9XU19URU4iLCJTUVJUX0JBU0UiLCJNQVgiLCJjbG9uZSIsImNvbmZpZ09iamVjdCIsImRpdiIsImNvbnZlcnRCYXNlIiwicGFyc2VOdW1lcmljIiwiUCIsIkJpZ051bWJlciIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwiT05FIiwiREVDSU1BTF9QTEFDRVMiLCJST1VORElOR19NT0RFIiwiVE9fRVhQX05FRyIsIlRPX0VYUF9QT1MiLCJNSU5fRVhQIiwiTUFYX0VYUCIsIkNSWVBUTyIsIk1PRFVMT19NT0RFIiwiUE9XX1BSRUNJU0lPTiIsIkZPUk1BVCIsInByZWZpeCIsImdyb3VwU2l6ZSIsInNlY29uZGFyeUdyb3VwU2l6ZSIsImdyb3VwU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvciIsImZyYWN0aW9uR3JvdXBTaXplIiwiZnJhY3Rpb25Hcm91cFNlcGFyYXRvciIsInN1ZmZpeCIsIkFMUEhBQkVUIiwiYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzIiwidiIsImIiLCJhbHBoYWJldCIsImMiLCJjYXNlQ2hhbmdlZCIsImUiLCJpIiwiaXNOdW0iLCJsZW4iLCJzdHIiLCJ4IiwiX2lzQmlnTnVtYmVyIiwicyIsInNsaWNlIiwiU3RyaW5nIiwidGVzdCIsImNoYXJDb2RlQXQiLCJpbmRleE9mIiwicmVwbGFjZSIsInNlYXJjaCIsInN1YnN0cmluZyIsImxlbmd0aCIsImludENoZWNrIiwicm91bmQiLCJERUJVRyIsIkVycm9yIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsImNvbmZpZyIsInNldCIsIm9iaiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInBvcCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJ5dGVzIiwiRVhQT05FTlRJQUxfQVQiLCJSQU5HRSIsImlzQmlnTnVtYmVyIiwibiIsIm91dCIsImNhbGwiLCJtYXhpbXVtIiwibWF4IiwibWF4T3JNaW4iLCJhcmd1bWVudHMiLCJtaW5pbXVtIiwibWluIiwicmFuZG9tIiwicG93Ml81MyIsInJhbmRvbTUzYml0SW50IiwiZHAiLCJhIiwiayIsInJhbmQiLCJVaW50MzJBcnJheSIsImNvcHkiLCJzcGxpY2UiLCJzdW0iLCJhcmdzIiwicGx1cyIsImRlY2ltYWwiLCJ0b0Jhc2VPdXQiLCJiYXNlSW4iLCJiYXNlT3V0IiwiaiIsImFyciIsImFyckwiLCJyZXZlcnNlIiwic2lnbiIsImNhbGxlcklzVG9TdHJpbmciLCJkIiwiciIsInhjIiwieSIsInJtIiwicG93IiwidG9GaXhlZFBvaW50IiwiY29lZmZUb1N0cmluZyIsImNvbmNhdCIsIm11bHRpcGx5IiwiYmFzZSIsIm0iLCJ0ZW1wIiwieGxvIiwieGhpIiwiY2FycnkiLCJrbG8iLCJraGkiLCJjb21wYXJlIiwiYUwiLCJiTCIsImNtcCIsInN1YnRyYWN0IiwibW9yZSIsInByb2QiLCJwcm9kTCIsInEiLCJxYyIsInJlbSIsInJlbUwiLCJyZW0wIiwieGkiLCJ4TCIsInljMCIsInlMIiwieXoiLCJ5YyIsIk5hTiIsImJpdEZsb29yIiwiZm9ybWF0IiwiaWQiLCJjMCIsIm5lIiwidG9FeHBvbmVudGlhbCIsIm5vcm1hbGlzZSIsImJhc2VQcmVmaXgiLCJkb3RBZnRlciIsImRvdEJlZm9yZSIsImlzSW5maW5pdHlPck5hTiIsIndoaXRlc3BhY2VPclBsdXMiLCJpc05hTiIsInAxIiwicDIiLCJzZCIsIm5pIiwicmQiLCJwb3dzMTAiLCJhYnNvbHV0ZVZhbHVlIiwiYWJzIiwiY29tcGFyZWRUbyIsImRlY2ltYWxQbGFjZXMiLCJkaXZpZGVkQnkiLCJkaXZpZGVkVG9JbnRlZ2VyQnkiLCJpZGl2IiwiZXhwb25lbnRpYXRlZEJ5IiwiaGFsZiIsImlzTW9kRXhwIiwibklzQmlnIiwibklzTmVnIiwibklzT2RkIiwiaXNJbnRlZ2VyIiwiaXNPZGQiLCJtb2QiLCJ0aW1lcyIsImludGVnZXJWYWx1ZSIsImlzRXF1YWxUbyIsImVxIiwiaXNGaW5pdGUiLCJpc0dyZWF0ZXJUaGFuIiwiZ3QiLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaXNMZXNzVGhhbiIsImx0IiwiaXNMZXNzVGhhbk9yRXF1YWxUbyIsImx0ZSIsImlzTmVnYXRpdmUiLCJpc1Bvc2l0aXZlIiwiaXNaZXJvIiwibWludXMiLCJ0IiwieExUeSIsInhlIiwieWUiLCJtb2R1bG8iLCJtdWx0aXBsaWVkQnkiLCJ4Y0wiLCJ5Y0wiLCJ5bG8iLCJ5aGkiLCJ6YyIsInNxcnRCYXNlIiwibmVnYXRlZCIsInByZWNpc2lvbiIsInNoaWZ0ZWRCeSIsInNxdWFyZVJvb3QiLCJzcXJ0IiwicmVwIiwidG9GaXhlZCIsInRvRm9ybWF0Iiwic3BsaXQiLCJnMSIsImcyIiwiaW50UGFydCIsImZyYWN0aW9uUGFydCIsImlzTmVnIiwiaW50RGlnaXRzIiwic3Vic3RyIiwiUmVnRXhwIiwidG9GcmFjdGlvbiIsIm1kIiwiZDAiLCJkMSIsImQyIiwiZXhwIiwibjAiLCJuMSIsInRvTnVtYmVyIiwidG9QcmVjaXNpb24iLCJ0b0pTT04iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImZvciIsInoiLCJsIiwibmFtZSIsInpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BigNumber: () => (/* binding */ BigNumber),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*\r\n *      bignumber.js v9.3.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */ var isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = \"[BigNumber Error] \", tooManyDigits = bignumberError + \"Number primitive has more than 15 significant digits: \", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 0x1fffffffffffff, // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\nPOWS_TEN = [\n    1,\n    10,\n    100,\n    1e3,\n    1e4,\n    1e5,\n    1e6,\n    1e7,\n    1e8,\n    1e9,\n    1e10,\n    1e11,\n    1e12,\n    1e13\n], SQRT_BASE = 1e7, // EDITABLE\n// The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\n// the arguments to toExponential, toFixed, toFormat, and toPrecision.\nMAX = 1E9; // 0 to MAX_INT32\n/*\r\n * Create and return a BigNumber constructor.\r\n */ function clone(configObject) {\n    var div, convertBase, parseNumeric, P = BigNumber.prototype = {\n        constructor: BigNumber,\n        toString: null,\n        valueOf: null\n    }, ONE = new BigNumber(1), //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\n    // The default values below must be integers within the inclusive ranges stated.\n    // The values can also be changed at run-time using BigNumber.set.\n    // The maximum number of decimal places for operations involving division.\n    DECIMAL_PLACES = 20, // The rounding mode used when rounding to the above decimal places, and when using\n    // toExponential, toFixed, toFormat and toPrecision, and round (default value).\n    // UP         0 Away from zero.\n    // DOWN       1 Towards zero.\n    // CEIL       2 Towards +Infinity.\n    // FLOOR      3 Towards -Infinity.\n    // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    ROUNDING_MODE = 4, // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\n    // The exponent value at and beneath which toString returns exponential notation.\n    // Number type: -7\n    TO_EXP_NEG = -7, // The exponent value at and above which toString returns exponential notation.\n    // Number type: 21\n    TO_EXP_POS = 21, // RANGE : [MIN_EXP, MAX_EXP]\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // Number type: -324  (5e-324)\n    MIN_EXP = -1e7, // The maximum exponent value, above which overflow to Infinity occurs.\n    // Number type:  308  (1.7976931348623157e+308)\n    // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\n    MAX_EXP = 1e7, // Whether to use cryptographically-secure random number generation, if available.\n    CRYPTO = false, // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP        0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN      1 The remainder has the same sign as the dividend.\n    //             This modulo mode is commonly known as 'truncated division' and is\n    //             equivalent to (a % n) in JavaScript.\n    // FLOOR     3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\n    // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\n    //             The remainder is always positive.\n    //\n    // The truncated division, floored division, Euclidian division and IEEE 754 remainder\n    // modes are commonly used for the modulus operation.\n    // Although the other rounding modes can also be used, they may not give useful results.\n    MODULO_MODE = 1, // The maximum number of significant digits of the result of the exponentiatedBy operation.\n    // If POW_PRECISION is 0, there will be unlimited significant digits.\n    POW_PRECISION = 0, // The format specification used by the BigNumber.prototype.toFormat method.\n    FORMAT = {\n        prefix: \"\",\n        groupSize: 3,\n        secondaryGroupSize: 0,\n        groupSeparator: \",\",\n        decimalSeparator: \".\",\n        fractionGroupSize: 0,\n        fractionGroupSeparator: \"\\xa0\",\n        suffix: \"\"\n    }, // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\n    // '-', '.', whitespace, or repeated character.\n    // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\n    ALPHABET = \"0123456789abcdefghijklmnopqrstuvwxyz\", alphabetHasNormalDecimalDigits = true;\n    //------------------------------------------------------------------------------------------\n    // CONSTRUCTOR\n    /*\r\n   * The BigNumber constructor and exported function.\r\n   * Create and return a new instance of a BigNumber object.\r\n   *\r\n   * v {number|string|BigNumber} A numeric value.\r\n   * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n   */ function BigNumber(v, b) {\n        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;\n        // Enable constructor call without `new`.\n        if (!(x instanceof BigNumber)) return new BigNumber(v, b);\n        if (b == null) {\n            if (v && v._isBigNumber === true) {\n                x.s = v.s;\n                if (!v.c || v.e > MAX_EXP) {\n                    x.c = x.e = null;\n                } else if (v.e < MIN_EXP) {\n                    x.c = [\n                        x.e = 0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.c = v.c.slice();\n                }\n                return;\n            }\n            if ((isNum = typeof v == \"number\") && v * 0 == 0) {\n                // Use `1 / n` to handle minus zero also.\n                x.s = 1 / v < 0 ? (v = -v, -1) : 1;\n                // Fast path for integers, where n < 2147483648 (2**31).\n                if (v === ~~v) {\n                    for(e = 0, i = v; i >= 10; i /= 10, e++);\n                    if (e > MAX_EXP) {\n                        x.c = x.e = null;\n                    } else {\n                        x.e = e;\n                        x.c = [\n                            v\n                        ];\n                    }\n                    return;\n                }\n                str = String(v);\n            } else {\n                if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\n                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\n            }\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            // Exponential form?\n            if ((i = str.search(/e/i)) > 0) {\n                // Determine exponent.\n                if (e < 0) e = i;\n                e += +str.slice(i + 1);\n                str = str.substring(0, i);\n            } else if (e < 0) {\n                // Integer.\n                e = str.length;\n            }\n        } else {\n            // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\n            intCheck(b, 2, ALPHABET.length, \"Base\");\n            // Allow exponential notation to be used with base 10 argument, while\n            // also rounding to DECIMAL_PLACES as with other bases.\n            if (b == 10 && alphabetHasNormalDecimalDigits) {\n                x = new BigNumber(v);\n                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\n            }\n            str = String(v);\n            if (isNum = typeof v == \"number\") {\n                // Avoid potential interpretation of Infinity and NaN as base 44+ values.\n                if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\n                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\n                // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n                if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, \"\").length > 15) {\n                    throw Error(tooManyDigits + v);\n                }\n            } else {\n                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\n            }\n            alphabet = ALPHABET.slice(0, b);\n            e = i = 0;\n            // Check that str is a valid base b number.\n            // Don't use RegExp, so alphabet can contain special characters.\n            for(len = str.length; i < len; i++){\n                if (alphabet.indexOf(c = str.charAt(i)) < 0) {\n                    if (c == \".\") {\n                        // If '.' is not the first character and it has not be found before.\n                        if (i > e) {\n                            e = len;\n                            continue;\n                        }\n                    } else if (!caseChanged) {\n                        // Allow e.g. hexadecimal 'FF' as well as 'ff'.\n                        if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {\n                            caseChanged = true;\n                            i = -1;\n                            e = 0;\n                            continue;\n                        }\n                    }\n                    return parseNumeric(x, String(v), isNum, b);\n                }\n            }\n            // Prevent later check for length on converted number.\n            isNum = false;\n            str = convertBase(str, b, 10, x.s);\n            // Decimal point?\n            if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n            else e = str.length;\n        }\n        // Determine leading zeros.\n        for(i = 0; str.charCodeAt(i) === 48; i++);\n        // Determine trailing zeros.\n        for(len = str.length; str.charCodeAt(--len) === 48;);\n        if (str = str.slice(i, ++len)) {\n            len -= i;\n            // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\n            if (isNum && BigNumber.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\n                throw Error(tooManyDigits + x.s * v);\n            }\n            // Overflow?\n            if ((e = e - i - 1) > MAX_EXP) {\n                // Infinity.\n                x.c = x.e = null;\n            // Underflow?\n            } else if (e < MIN_EXP) {\n                // Zero.\n                x.c = [\n                    x.e = 0\n                ];\n            } else {\n                x.e = e;\n                x.c = [];\n                // Transform base\n                // e is the base 10 exponent.\n                // i is where to slice str to get the first element of the coefficient array.\n                i = (e + 1) % LOG_BASE;\n                if (e < 0) i += LOG_BASE; // i < 1\n                if (i < len) {\n                    if (i) x.c.push(+str.slice(0, i));\n                    for(len -= LOG_BASE; i < len;){\n                        x.c.push(+str.slice(i, i += LOG_BASE));\n                    }\n                    i = LOG_BASE - (str = str.slice(i)).length;\n                } else {\n                    i -= len;\n                }\n                for(; i--; str += \"0\");\n                x.c.push(+str);\n            }\n        } else {\n            // Zero.\n            x.c = [\n                x.e = 0\n            ];\n        }\n    }\n    // CONSTRUCTOR PROPERTIES\n    BigNumber.clone = clone;\n    BigNumber.ROUND_UP = 0;\n    BigNumber.ROUND_DOWN = 1;\n    BigNumber.ROUND_CEIL = 2;\n    BigNumber.ROUND_FLOOR = 3;\n    BigNumber.ROUND_HALF_UP = 4;\n    BigNumber.ROUND_HALF_DOWN = 5;\n    BigNumber.ROUND_HALF_EVEN = 6;\n    BigNumber.ROUND_HALF_CEIL = 7;\n    BigNumber.ROUND_HALF_FLOOR = 8;\n    BigNumber.EUCLID = 9;\n    /*\r\n   * Configure infrequently-changing library-wide settings.\r\n   *\r\n   * Accept an object with the following optional properties (if the value of a property is\r\n   * a number, it must be an integer within the inclusive range stated):\r\n   *\r\n   *   DECIMAL_PLACES   {number}           0 to MAX\r\n   *   ROUNDING_MODE    {number}           0 to 8\r\n   *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n   *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n   *   CRYPTO           {boolean}          true or false\r\n   *   MODULO_MODE      {number}           0 to 9\r\n   *   POW_PRECISION       {number}           0 to MAX\r\n   *   ALPHABET         {string}           A string of two or more unique characters which does\r\n   *                                       not contain '.'.\r\n   *   FORMAT           {object}           An object with some of the following properties:\r\n   *     prefix                 {string}\r\n   *     groupSize              {number}\r\n   *     secondaryGroupSize     {number}\r\n   *     groupSeparator         {string}\r\n   *     decimalSeparator       {string}\r\n   *     fractionGroupSize      {number}\r\n   *     fractionGroupSeparator {string}\r\n   *     suffix                 {string}\r\n   *\r\n   * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n   *\r\n   * E.g.\r\n   * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n   *\r\n   * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n   *\r\n   * Return an object with the properties current values.\r\n   */ BigNumber.config = BigNumber.set = function(obj) {\n        var p, v;\n        if (obj != null) {\n            if (typeof obj == \"object\") {\n                // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"DECIMAL_PLACES\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    DECIMAL_PLACES = v;\n                }\n                // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\n                // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"ROUNDING_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 8, p);\n                    ROUNDING_MODE = v;\n                }\n                // EXPONENTIAL_AT {number|number[]}\n                // Integer, -MAX to MAX inclusive or\n                // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\n                // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"EXPONENTIAL_AT\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, 0, p);\n                        intCheck(v[1], 0, MAX, p);\n                        TO_EXP_NEG = v[0];\n                        TO_EXP_POS = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\n                    }\n                }\n                // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\n                // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\n                // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\n                if (obj.hasOwnProperty(p = \"RANGE\")) {\n                    v = obj[p];\n                    if (v && v.pop) {\n                        intCheck(v[0], -MAX, -1, p);\n                        intCheck(v[1], 1, MAX, p);\n                        MIN_EXP = v[0];\n                        MAX_EXP = v[1];\n                    } else {\n                        intCheck(v, -MAX, MAX, p);\n                        if (v) {\n                            MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\n                        } else {\n                            throw Error(bignumberError + p + \" cannot be zero: \" + v);\n                        }\n                    }\n                }\n                // CRYPTO {boolean} true or false.\n                // '[BigNumber Error] CRYPTO not true or false: {v}'\n                // '[BigNumber Error] crypto unavailable'\n                if (obj.hasOwnProperty(p = \"CRYPTO\")) {\n                    v = obj[p];\n                    if (v === !!v) {\n                        if (v) {\n                            if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                                CRYPTO = v;\n                            } else {\n                                CRYPTO = !v;\n                                throw Error(bignumberError + \"crypto unavailable\");\n                            }\n                        } else {\n                            CRYPTO = v;\n                        }\n                    } else {\n                        throw Error(bignumberError + p + \" not true or false: \" + v);\n                    }\n                }\n                // MODULO_MODE {number} Integer, 0 to 9 inclusive.\n                // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"MODULO_MODE\")) {\n                    v = obj[p];\n                    intCheck(v, 0, 9, p);\n                    MODULO_MODE = v;\n                }\n                // POW_PRECISION {number} Integer, 0 to MAX inclusive.\n                // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\n                if (obj.hasOwnProperty(p = \"POW_PRECISION\")) {\n                    v = obj[p];\n                    intCheck(v, 0, MAX, p);\n                    POW_PRECISION = v;\n                }\n                // FORMAT {object}\n                // '[BigNumber Error] FORMAT not an object: {v}'\n                if (obj.hasOwnProperty(p = \"FORMAT\")) {\n                    v = obj[p];\n                    if (typeof v == \"object\") FORMAT = v;\n                    else throw Error(bignumberError + p + \" not an object: \" + v);\n                }\n                // ALPHABET {string}\n                // '[BigNumber Error] ALPHABET invalid: {v}'\n                if (obj.hasOwnProperty(p = \"ALPHABET\")) {\n                    v = obj[p];\n                    // Disallow if less than two characters,\n                    // or if it contains '+', '-', '.', whitespace, or a repeated character.\n                    if (typeof v == \"string\" && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\n                        alphabetHasNormalDecimalDigits = v.slice(0, 10) == \"0123456789\";\n                        ALPHABET = v;\n                    } else {\n                        throw Error(bignumberError + p + \" invalid: \" + v);\n                    }\n                }\n            } else {\n                // '[BigNumber Error] Object expected: {v}'\n                throw Error(bignumberError + \"Object expected: \" + obj);\n            }\n        }\n        return {\n            DECIMAL_PLACES: DECIMAL_PLACES,\n            ROUNDING_MODE: ROUNDING_MODE,\n            EXPONENTIAL_AT: [\n                TO_EXP_NEG,\n                TO_EXP_POS\n            ],\n            RANGE: [\n                MIN_EXP,\n                MAX_EXP\n            ],\n            CRYPTO: CRYPTO,\n            MODULO_MODE: MODULO_MODE,\n            POW_PRECISION: POW_PRECISION,\n            FORMAT: FORMAT,\n            ALPHABET: ALPHABET\n        };\n    };\n    /*\r\n   * Return true if v is a BigNumber instance, otherwise return false.\r\n   *\r\n   * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n   *\r\n   * v {any}\r\n   *\r\n   * '[BigNumber Error] Invalid BigNumber: {v}'\r\n   */ BigNumber.isBigNumber = function(v) {\n        if (!v || v._isBigNumber !== true) return false;\n        if (!BigNumber.DEBUG) return true;\n        var i, n, c = v.c, e = v.e, s = v.s;\n        out: if (({}).toString.call(c) == \"[object Array]\") {\n            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\n                // If the first element is zero, the BigNumber value must be zero.\n                if (c[0] === 0) {\n                    if (e === 0 && c.length === 1) return true;\n                    break out;\n                }\n                // Calculate number of digits that c[0] should have, based on the exponent.\n                i = (e + 1) % LOG_BASE;\n                if (i < 1) i += LOG_BASE;\n                // Calculate number of digits of c[0].\n                //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\n                if (String(c[0]).length == i) {\n                    for(i = 0; i < c.length; i++){\n                        n = c[i];\n                        if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\n                    }\n                    // Last element cannot be zero, unless it is the only element.\n                    if (n !== 0) return true;\n                }\n            }\n        // Infinity/NaN\n        } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\n            return true;\n        }\n        throw Error(bignumberError + \"Invalid BigNumber: \" + v);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.maximum = BigNumber.max = function() {\n        return maxOrMin(arguments, -1);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.minimum = BigNumber.min = function() {\n        return maxOrMin(arguments, 1);\n    };\n    /*\r\n   * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n   * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n   * zeros are produced).\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n   * '[BigNumber Error] crypto unavailable'\r\n   */ BigNumber.random = function() {\n        var pow2_53 = 0x20000000000000;\n        // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\n        // Check if Math.random() produces more than 32 bits of randomness.\n        // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\n        // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\n        var random53bitInt = Math.random() * pow2_53 & 0x1fffff ? function() {\n            return mathfloor(Math.random() * pow2_53);\n        } : function() {\n            return (Math.random() * 0x40000000 | 0) * 0x800000 + (Math.random() * 0x800000 | 0);\n        };\n        return function(dp) {\n            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber(ONE);\n            if (dp == null) dp = DECIMAL_PLACES;\n            else intCheck(dp, 0, MAX);\n            k = mathceil(dp / LOG_BASE);\n            if (CRYPTO) {\n                // Browsers supporting crypto.getRandomValues.\n                if (crypto.getRandomValues) {\n                    a = crypto.getRandomValues(new Uint32Array(k *= 2));\n                    for(; i < k;){\n                        // 53 bits:\n                        // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\n                        // 11111 11111111 11111111 11111111 11100000 00000000 00000000\n                        // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\n                        //                                     11111 11111111 11111111\n                        // 0x20000 is 2^21.\n                        v = a[i] * 0x20000 + (a[i + 1] >>> 11);\n                        // Rejection sampling:\n                        // 0 <= v < 9007199254740992\n                        // Probability that v >= 9e15, is\n                        // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\n                        if (v >= 9e15) {\n                            b = crypto.getRandomValues(new Uint32Array(2));\n                            a[i] = b[0];\n                            a[i + 1] = b[1];\n                        } else {\n                            // 0 <= v <= 8999999999999999\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 2;\n                        }\n                    }\n                    i = k / 2;\n                // Node.js supporting crypto.randomBytes.\n                } else if (crypto.randomBytes) {\n                    // buffer\n                    a = crypto.randomBytes(k *= 7);\n                    for(; i < k;){\n                        // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\n                        // 0x100000000 is 2^32, 0x1000000 is 2^24\n                        // 11111 11111111 11111111 11111111 11111111 11111111 11111111\n                        // 0 <= v < 9007199254740992\n                        v = (a[i] & 31) * 0x1000000000000 + a[i + 1] * 0x10000000000 + a[i + 2] * 0x100000000 + a[i + 3] * 0x1000000 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\n                        if (v >= 9e15) {\n                            crypto.randomBytes(7).copy(a, i);\n                        } else {\n                            // 0 <= (v % 1e14) <= 99999999999999\n                            c.push(v % 1e14);\n                            i += 7;\n                        }\n                    }\n                    i = k / 7;\n                } else {\n                    CRYPTO = false;\n                    throw Error(bignumberError + \"crypto unavailable\");\n                }\n            }\n            // Use Math.random.\n            if (!CRYPTO) {\n                for(; i < k;){\n                    v = random53bitInt();\n                    if (v < 9e15) c[i++] = v % 1e14;\n                }\n            }\n            k = c[--i];\n            dp %= LOG_BASE;\n            // Convert trailing digits to zeros according to dp.\n            if (k && dp) {\n                v = POWS_TEN[LOG_BASE - dp];\n                c[i] = mathfloor(k / v) * v;\n            }\n            // Remove trailing elements which are zero.\n            for(; c[i] === 0; c.pop(), i--);\n            // Zero?\n            if (i < 0) {\n                c = [\n                    e = 0\n                ];\n            } else {\n                // Remove leading elements which are zero and adjust exponent accordingly.\n                for(e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\n                // Count the digits of the first element of c to determine leading zeros, and...\n                for(i = 1, v = c[0]; v >= 10; v /= 10, i++);\n                // adjust the exponent accordingly.\n                if (i < LOG_BASE) e -= LOG_BASE - i;\n            }\n            rand.e = e;\n            rand.c = c;\n            return rand;\n        };\n    }();\n    /*\r\n   * Return a BigNumber whose value is the sum of the arguments.\r\n   *\r\n   * arguments {number|string|BigNumber}\r\n   */ BigNumber.sum = function() {\n        var i = 1, args = arguments, sum = new BigNumber(args[0]);\n        for(; i < args.length;)sum = sum.plus(args[i++]);\n        return sum;\n    };\n    // PRIVATE FUNCTIONS\n    // Called by BigNumber and BigNumber.prototype.toString.\n    convertBase = function() {\n        var decimal = \"0123456789\";\n        /*\r\n     * Convert string of baseIn to an array of numbers of baseOut.\r\n     * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n     * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n     */ function toBaseOut(str, baseIn, baseOut, alphabet) {\n            var j, arr = [\n                0\n            ], arrL, i = 0, len = str.length;\n            for(; i < len;){\n                for(arrL = arr.length; arrL--; arr[arrL] *= baseIn);\n                arr[0] += alphabet.indexOf(str.charAt(i++));\n                for(j = 0; j < arr.length; j++){\n                    if (arr[j] > baseOut - 1) {\n                        if (arr[j + 1] == null) arr[j + 1] = 0;\n                        arr[j + 1] += arr[j] / baseOut | 0;\n                        arr[j] %= baseOut;\n                    }\n                }\n            }\n            return arr.reverse();\n        }\n        // Convert a numeric string of baseIn to a numeric string of baseOut.\n        // If the caller is toString, we are converting from base 10 to baseOut.\n        // If the caller is BigNumber, we are converting from baseIn to base 10.\n        return function(str, baseIn, baseOut, sign, callerIsToString) {\n            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf(\".\"), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;\n            // Non-integer.\n            if (i >= 0) {\n                k = POW_PRECISION;\n                // Unlimited precision.\n                POW_PRECISION = 0;\n                str = str.replace(\".\", \"\");\n                y = new BigNumber(baseIn);\n                x = y.pow(str.length - i);\n                POW_PRECISION = k;\n                // Convert str as if an integer, then restore the fraction part by dividing the\n                // result by its base raised to a power.\n                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, \"0\"), 10, baseOut, decimal);\n                y.e = y.c.length;\n            }\n            // Convert the number as integer.\n            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));\n            // xc now represents str as an integer and converted to baseOut. e is the exponent.\n            e = k = xc.length;\n            // Remove trailing zeros.\n            for(; xc[--k] == 0; xc.pop());\n            // Zero?\n            if (!xc[0]) return alphabet.charAt(0);\n            // Does str represent an integer? If so, no need for the division.\n            if (i < 0) {\n                --e;\n            } else {\n                x.c = xc;\n                x.e = e;\n                // The sign is needed for correct rounding.\n                x.s = sign;\n                x = div(x, y, dp, rm, baseOut);\n                xc = x.c;\n                r = x.r;\n                e = x.e;\n            }\n            // xc now represents str converted to baseOut.\n            // The index of the rounding digit.\n            d = e + dp + 1;\n            // The rounding digit: the digit to the right of the digit that may be rounded up.\n            i = xc[d];\n            // Look at the rounding digits and mode to determine whether to round up.\n            k = baseOut / 2;\n            r = r || d < 0 || xc[d + 1] != null;\n            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));\n            // If the index of the rounding digit is not greater than zero, or xc represents\n            // zero, then the result of the base conversion is zero or, if rounding up, a value\n            // such as 0.00001.\n            if (d < 1 || !xc[0]) {\n                // 1^-dp or 0\n                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\n            } else {\n                // Truncate xc to the required number of decimal places.\n                xc.length = d;\n                // Round up?\n                if (r) {\n                    // Rounding up may mean the previous digit has to be rounded up and so on.\n                    for(--baseOut; ++xc[--d] > baseOut;){\n                        xc[d] = 0;\n                        if (!d) {\n                            ++e;\n                            xc = [\n                                1\n                            ].concat(xc);\n                        }\n                    }\n                }\n                // Determine trailing zeros.\n                for(k = xc.length; !xc[--k];);\n                // E.g. [4, 11, 15] becomes 4bf.\n                for(i = 0, str = \"\"; i <= k; str += alphabet.charAt(xc[i++]));\n                // Add leading zeros, decimal point and trailing zeros as required.\n                str = toFixedPoint(str, e, alphabet.charAt(0));\n            }\n            // The caller will add the sign.\n            return str;\n        };\n    }();\n    // Perform division in the specified base. Called by div and convertBase.\n    div = function() {\n        // Assume non-zero x and k.\n        function multiply(x, k, base) {\n            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;\n            for(x = x.slice(); i--;){\n                xlo = x[i] % SQRT_BASE;\n                xhi = x[i] / SQRT_BASE | 0;\n                m = khi * xlo + xhi * klo;\n                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;\n                carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\n                x[i] = temp % base;\n            }\n            if (carry) x = [\n                carry\n            ].concat(x);\n            return x;\n        }\n        function compare(a, b, aL, bL) {\n            var i, cmp;\n            if (aL != bL) {\n                cmp = aL > bL ? 1 : -1;\n            } else {\n                for(i = cmp = 0; i < aL; i++){\n                    if (a[i] != b[i]) {\n                        cmp = a[i] > b[i] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            return cmp;\n        }\n        function subtract(a, b, aL, base) {\n            var i = 0;\n            // Subtract b from a.\n            for(; aL--;){\n                a[aL] -= i;\n                i = a[aL] < b[aL] ? 1 : 0;\n                a[aL] = i * base + a[aL] - b[aL];\n            }\n            // Remove leading zeros.\n            for(; !a[0] && a.length > 1; a.splice(0, 1));\n        }\n        // x: dividend, y: divisor.\n        return function(x, y, dp, rm, base) {\n            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;\n            // Either NaN, Infinity or 0?\n            if (!xc || !xc[0] || !yc || !yc[0]) {\n                return new BigNumber(// Return NaN if either NaN, or both Infinity or 0.\n                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.\n                xc && xc[0] == 0 || !yc ? s * 0 : s / 0);\n            }\n            q = new BigNumber(s);\n            qc = q.c = [];\n            e = x.e - y.e;\n            s = dp + e + 1;\n            if (!base) {\n                base = BASE;\n                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\n                s = s / LOG_BASE | 0;\n            }\n            // Result exponent may be one less then the current value of e.\n            // The coefficients of the BigNumbers from convertBase may have trailing zeros.\n            for(i = 0; yc[i] == (xc[i] || 0); i++);\n            if (yc[i] > (xc[i] || 0)) e--;\n            if (s < 0) {\n                qc.push(1);\n                more = true;\n            } else {\n                xL = xc.length;\n                yL = yc.length;\n                i = 0;\n                s += 2;\n                // Normalise xc and yc so highest order digit of yc is >= base / 2.\n                n = mathfloor(base / (yc[0] + 1));\n                // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\n                // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\n                if (n > 1) {\n                    yc = multiply(yc, n, base);\n                    xc = multiply(xc, n, base);\n                    yL = yc.length;\n                    xL = xc.length;\n                }\n                xi = yL;\n                rem = xc.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL; rem[remL++] = 0);\n                yz = yc.slice();\n                yz = [\n                    0\n                ].concat(yz);\n                yc0 = yc[0];\n                if (yc[1] >= base / 2) yc0++;\n                // Not necessary, but to prevent trial digit n > base, when using base 3.\n                // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\n                do {\n                    n = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yc, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, n.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // n is how many times the divisor goes into the current remainder.\n                        n = mathfloor(rem0 / yc0);\n                        //  Algorithm:\n                        //  product = divisor multiplied by trial digit (n).\n                        //  Compare product and remainder.\n                        //  If product is greater than remainder:\n                        //    Subtract divisor from product, decrement trial digit.\n                        //  Subtract product from remainder.\n                        //  If product was less than remainder at the last compare:\n                        //    Compare new remainder and divisor.\n                        //    If remainder is greater than divisor:\n                        //      Subtract divisor from remainder, increment trial digit.\n                        if (n > 1) {\n                            // n may be > base only when base is 3.\n                            if (n >= base) n = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiply(yc, n, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            // If product > remainder then trial digit n too high.\n                            // n is 1 too high about 5% of the time, and is not known to have\n                            // ever been more than 1 too high.\n                            while(compare(prod, rem, prodL, remL) == 1){\n                                n--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yc, prodL, base);\n                                prodL = prod.length;\n                                cmp = 1;\n                            }\n                        } else {\n                            // n is 0 or 1, cmp is -1.\n                            // If n is 0, there is no need to compare yc and rem again below,\n                            // so change cmp to 1 to avoid it.\n                            // If n is 1, leave cmp as -1, so yc and rem are compared again.\n                            if (n == 0) {\n                                // divisor < remainder, so n must be at least 1.\n                                cmp = n = 1;\n                            }\n                            // product = divisor\n                            prod = yc.slice();\n                            prodL = prod.length;\n                        }\n                        if (prodL < remL) prod = [\n                            0\n                        ].concat(prod);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        remL = rem.length;\n                        // If product was < remainder.\n                        if (cmp == -1) {\n                            // Compare divisor and new remainder.\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            // Trial digit n too low.\n                            // n is 1 too low about 5% of the time, and very rarely 2 too low.\n                            while(compare(yc, rem, yL, remL) < 1){\n                                n++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yc, remL, base);\n                                remL = rem.length;\n                            }\n                        }\n                    } else if (cmp === 0) {\n                        n++;\n                        rem = [\n                            0\n                        ];\n                    } // else cmp === 1 and n will be 0\n                    // Add the next digit, n, to the result array.\n                    qc[i++] = n;\n                    // Update the remainder.\n                    if (rem[0]) {\n                        rem[remL++] = xc[xi] || 0;\n                    } else {\n                        rem = [\n                            xc[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] != null) && s--);\n                more = rem[0] != null;\n                // Leading zero?\n                if (!qc[0]) qc.splice(0, 1);\n            }\n            if (base == BASE) {\n                // To calculate q.e, first get the number of digits of qc[0].\n                for(i = 1, s = qc[0]; s >= 10; s /= 10, i++);\n                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\n            // Caller is convertBase.\n            } else {\n                q.e = e;\n                q.r = +more;\n            }\n            return q;\n        };\n    }();\n    /*\r\n   * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n   * notation rounded to the specified decimal places or significant digits.\r\n   *\r\n   * n: a BigNumber.\r\n   * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n   * rm: the rounding mode.\r\n   * id: 1 (toExponential) or 2 (toPrecision).\r\n   */ function format(n, i, rm, id) {\n        var c0, e, ne, len, str;\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        if (!n.c) return n.toString();\n        c0 = n.c[0];\n        ne = n.e;\n        if (i == null) {\n            str = coeffToString(n.c);\n            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, \"0\");\n        } else {\n            n = round(new BigNumber(n), i, rm);\n            // n.e may have changed if the value was rounded up.\n            e = n.e;\n            str = coeffToString(n.c);\n            len = str.length;\n            // toPrecision returns exponential notation if the number of significant digits\n            // specified is less than the number of digits necessary to represent the integer\n            // part of the value in fixed-point notation.\n            // Exponential notation.\n            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\n                // Append zeros?\n                for(; len < i; str += \"0\", len++);\n                str = toExponential(str, e);\n            // Fixed-point notation.\n            } else {\n                i -= ne + (id === 2 && e > ne);\n                str = toFixedPoint(str, e, \"0\");\n                // Append zeros?\n                if (e + 1 > len) {\n                    if (--i > 0) for(str += \".\"; i--; str += \"0\");\n                } else {\n                    i += e - len;\n                    if (i > 0) {\n                        if (e + 1 == len) str += \".\";\n                        for(; i--; str += \"0\");\n                    }\n                }\n            }\n        }\n        return n.s < 0 && c0 ? \"-\" + str : str;\n    }\n    // Handle BigNumber.max and BigNumber.min.\n    // If any number is NaN, return NaN.\n    function maxOrMin(args, n) {\n        var k, y, i = 1, x = new BigNumber(args[0]);\n        for(; i < args.length; i++){\n            y = new BigNumber(args[i]);\n            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {\n                x = y;\n            }\n        }\n        return x;\n    }\n    /*\r\n   * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n   * Called by minus, plus and times.\r\n   */ function normalise(n, c, e) {\n        var i = 1, j = c.length;\n        // Remove trailing zeros.\n        for(; !c[--j]; c.pop());\n        // Calculate the base 10 exponent. First get the number of digits of c[0].\n        for(j = c[0]; j >= 10; j /= 10, i++);\n        // Overflow?\n        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\n            // Infinity.\n            n.c = n.e = null;\n        // Underflow?\n        } else if (e < MIN_EXP) {\n            // Zero.\n            n.c = [\n                n.e = 0\n            ];\n        } else {\n            n.e = e;\n            n.c = c;\n        }\n        return n;\n    }\n    // Handle values that fail the validity test in BigNumber.\n    parseNumeric = function() {\n        var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i, dotAfter = /^([^.]+)\\.$/, dotBefore = /^\\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\n        return function(x, str, isNum, b) {\n            var base, s = isNum ? str : str.replace(whitespaceOrPlus, \"\");\n            // No exception on ±Infinity or NaN.\n            if (isInfinityOrNaN.test(s)) {\n                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\n            } else {\n                if (!isNum) {\n                    // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\n                    s = s.replace(basePrefix, function(m, p1, p2) {\n                        base = (p2 = p2.toLowerCase()) == \"x\" ? 16 : p2 == \"b\" ? 2 : 8;\n                        return !b || b == base ? p1 : m;\n                    });\n                    if (b) {\n                        base = b;\n                        // E.g. '1.' to '1', '.1' to '0.1'\n                        s = s.replace(dotAfter, \"$1\").replace(dotBefore, \"0.$1\");\n                    }\n                    if (str != s) return new BigNumber(s, base);\n                }\n                // '[BigNumber Error] Not a number: {n}'\n                // '[BigNumber Error] Not a base {b} number: {n}'\n                if (BigNumber.DEBUG) {\n                    throw Error(bignumberError + \"Not a\" + (b ? \" base \" + b : \"\") + \" number: \" + str);\n                }\n                // NaN\n                x.s = null;\n            }\n            x.c = x.e = null;\n        };\n    }();\n    /*\r\n   * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n   * If r is truthy, it is known that there are more digits after the rounding digit.\r\n   */ function round(x, sd, rm, r) {\n        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;\n        // if x is not Infinity or NaN...\n        if (xc) {\n            // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\n            // n is a base 1e14 number, the value of the element of array x.c containing rd.\n            // ni is the index of n within x.c.\n            // d is the number of digits of n.\n            // i is the index of rd within n including leading zeros.\n            // j is the actual index of rd within n (if < 0, rd is a leading zero).\n            out: {\n                // Get the number of digits of the first element of xc.\n                for(d = 1, k = xc[0]; k >= 10; k /= 10, d++);\n                i = sd - d;\n                // If the rounding digit is in the first element of xc...\n                if (i < 0) {\n                    i += LOG_BASE;\n                    j = sd;\n                    n = xc[ni = 0];\n                    // Get the rounding digit at index j of n.\n                    rd = mathfloor(n / pows10[d - j - 1] % 10);\n                } else {\n                    ni = mathceil((i + 1) / LOG_BASE);\n                    if (ni >= xc.length) {\n                        if (r) {\n                            // Needed by sqrt.\n                            for(; xc.length <= ni; xc.push(0));\n                            n = rd = 0;\n                            d = 1;\n                            i %= LOG_BASE;\n                            j = i - LOG_BASE + 1;\n                        } else {\n                            break out;\n                        }\n                    } else {\n                        n = k = xc[ni];\n                        // Get the number of digits of n.\n                        for(d = 1; k >= 10; k /= 10, d++);\n                        // Get the index of rd within n.\n                        i %= LOG_BASE;\n                        // Get the index of rd within n, adjusted for leading zeros.\n                        // The number of leading zeros of n is given by LOG_BASE - d.\n                        j = i - LOG_BASE + d;\n                        // Get the rounding digit at index j of n.\n                        rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);\n                    }\n                }\n                r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?\n                // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\n                // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\n                xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\n                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n                if (sd < 1 || !xc[0]) {\n                    xc.length = 0;\n                    if (r) {\n                        // Convert sd to decimal places.\n                        sd -= x.e + 1;\n                        // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                        xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\n                        x.e = -sd || 0;\n                    } else {\n                        // Zero.\n                        xc[0] = x.e = 0;\n                    }\n                    return x;\n                }\n                // Remove excess digits.\n                if (i == 0) {\n                    xc.length = ni;\n                    k = 1;\n                    ni--;\n                } else {\n                    xc.length = ni + 1;\n                    k = pows10[LOG_BASE - i];\n                    // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                    // j > 0 means i > number of leading zeros of n.\n                    xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\n                }\n                // Round up?\n                if (r) {\n                    for(;;){\n                        // If the digit to be rounded up is in the first element of xc...\n                        if (ni == 0) {\n                            // i will be the length of xc[0] before k is added.\n                            for(i = 1, j = xc[0]; j >= 10; j /= 10, i++);\n                            j = xc[0] += k;\n                            for(k = 1; j >= 10; j /= 10, k++);\n                            // if i != k the length has increased.\n                            if (i != k) {\n                                x.e++;\n                                if (xc[0] == BASE) xc[0] = 1;\n                            }\n                            break;\n                        } else {\n                            xc[ni] += k;\n                            if (xc[ni] != BASE) break;\n                            xc[ni--] = 0;\n                            k = 1;\n                        }\n                    }\n                }\n                // Remove trailing zeros.\n                for(i = xc.length; xc[--i] === 0; xc.pop());\n            }\n            // Overflow? Infinity.\n            if (x.e > MAX_EXP) {\n                x.c = x.e = null;\n            // Underflow? Zero.\n            } else if (x.e < MIN_EXP) {\n                x.c = [\n                    x.e = 0\n                ];\n            }\n        }\n        return x;\n    }\n    function valueOf(n) {\n        var str, e = n.e;\n        if (e === null) return n.toString();\n        str = coeffToString(n.c);\n        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, \"0\");\n        return n.s < 0 ? \"-\" + str : str;\n    }\n    // PROTOTYPE/INSTANCE METHODS\n    /*\r\n   * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n   */ P.absoluteValue = P.abs = function() {\n        var x = new BigNumber(this);\n        if (x.s < 0) x.s = 1;\n        return x;\n    };\n    /*\r\n   * Return\r\n   *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   *   0 if they have the same value,\r\n   *   or null if the value of either is NaN.\r\n   */ P.comparedTo = function(y, b) {\n        return compare(this, new BigNumber(y, b));\n    };\n    /*\r\n   * If dp is undefined or null or true or false, return the number of decimal places of the\r\n   * value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   *\r\n   * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.decimalPlaces = P.dp = function(dp, rm) {\n        var c, n, v, x = this;\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), dp + x.e + 1, rm);\n        }\n        if (!(c = x.c)) return null;\n        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last number.\n        if (v = c[v]) for(; v % 10 == 0; v /= 10, n--);\n        if (n < 0) n = 0;\n        return n;\n    };\n    /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n   * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.dividedBy = P.div = function(y, b) {\n        return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n   * BigNumber by the value of BigNumber(y, b).\r\n   */ P.dividedToIntegerBy = P.idiv = function(y, b) {\n        return div(this, new BigNumber(y, b), 0, 1);\n    };\n    /*\r\n   * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n   *\r\n   * If m is present, return the result modulo m.\r\n   * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n   *\r\n   * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n   * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n   *\r\n   * n {number|string|BigNumber} The exponent. An integer.\r\n   * [m] {number|string|BigNumber} The modulus.\r\n   *\r\n   * '[BigNumber Error] Exponent not an integer: {n}'\r\n   */ P.exponentiatedBy = P.pow = function(n, m) {\n        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;\n        n = new BigNumber(n);\n        // Allow NaN and ±Infinity, but not other non-integers.\n        if (n.c && !n.isInteger()) {\n            throw Error(bignumberError + \"Exponent not an integer: \" + valueOf(n));\n        }\n        if (m != null) m = new BigNumber(m);\n        // Exponent of MAX_SAFE_INTEGER is 15.\n        nIsBig = n.e > 14;\n        // If x is NaN, ±Infinity, ±0 or ±1, or n is ±Infinity, NaN or ±0.\n        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\n            // The sign of the result of pow when x is negative depends on the evenness of n.\n            // If +n overflows to ±Infinity, the evenness of n would be not be known.\n            y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));\n            return m ? y.mod(m) : y;\n        }\n        nIsNeg = n.s < 0;\n        if (m) {\n            // x % m returns NaN if abs(m) is zero, or m is NaN.\n            if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\n            isModExp = !nIsNeg && x.isInteger() && m.isInteger();\n            if (isModExp) x = x.mod(m);\n        // Overflow to ±Infinity: >=2**1e10 or >=1.0000024**1e15.\n        // Underflow to ±0: <=0.79**1e10 or <=0.9999975**1e15.\n        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\n            // If x is negative and n is odd, k = -0, else k = 0.\n            k = x.s < 0 && isOdd(n) ? -0 : 0;\n            // If x >= 1, k = ±Infinity.\n            if (x.e > -1) k = 1 / k;\n            // If n is negative return ±0, else return ±Infinity.\n            return new BigNumber(nIsNeg ? 1 / k : k);\n        } else if (POW_PRECISION) {\n            // Truncating each coefficient array to a length of k after each multiplication\n            // equates to truncating significant digits to POW_PRECISION + [28, 41],\n            // i.e. there will be a minimum of 28 guard digits retained.\n            k = mathceil(POW_PRECISION / LOG_BASE + 2);\n        }\n        if (nIsBig) {\n            half = new BigNumber(0.5);\n            if (nIsNeg) n.s = 1;\n            nIsOdd = isOdd(n);\n        } else {\n            i = Math.abs(+valueOf(n));\n            nIsOdd = i % 2;\n        }\n        y = new BigNumber(ONE);\n        // Performs 54 loop iterations for n of 9007199254740991.\n        for(;;){\n            if (nIsOdd) {\n                y = y.times(x);\n                if (!y.c) break;\n                if (k) {\n                    if (y.c.length > k) y.c.length = k;\n                } else if (isModExp) {\n                    y = y.mod(m); //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\n                }\n            }\n            if (i) {\n                i = mathfloor(i / 2);\n                if (i === 0) break;\n                nIsOdd = i % 2;\n            } else {\n                n = n.times(half);\n                round(n, n.e + 1, 1);\n                if (n.e > 14) {\n                    nIsOdd = isOdd(n);\n                } else {\n                    i = +valueOf(n);\n                    if (i === 0) break;\n                    nIsOdd = i % 2;\n                }\n            }\n            x = x.times(x);\n            if (k) {\n                if (x.c && x.c.length > k) x.c.length = k;\n            } else if (isModExp) {\n                x = x.mod(m); //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\n            }\n        }\n        if (isModExp) return y;\n        if (nIsNeg) y = ONE.div(y);\n        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n   * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n   */ P.integerValue = function(rm) {\n        var n = new BigNumber(this);\n        if (rm == null) rm = ROUNDING_MODE;\n        else intCheck(rm, 0, 8);\n        return round(n, n.e + 1, rm);\n    };\n    /*\r\n   * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isEqualTo = P.eq = function(y, b) {\n        return compare(this, new BigNumber(y, b)) === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n   */ P.isFinite = function() {\n        return !!this.c;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isGreaterThan = P.gt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is greater than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isGreaterThanOrEqualTo = P.gte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n   */ P.isInteger = function() {\n        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n   * otherwise return false.\r\n   */ P.isLessThan = P.lt = function(y, b) {\n        return compare(this, new BigNumber(y, b)) < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is less than or equal to the value of\r\n   * BigNumber(y, b), otherwise return false.\r\n   */ P.isLessThanOrEqualTo = P.lte = function(y, b) {\n        return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n   */ P.isNaN = function() {\n        return !this.s;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is negative, otherwise return false.\r\n   */ P.isNegative = function() {\n        return this.s < 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is positive, otherwise return false.\r\n   */ P.isPositive = function() {\n        return this.s > 0;\n    };\n    /*\r\n   * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n   */ P.isZero = function() {\n        return !!this.c && this.c[0] == 0;\n    };\n    /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n   * BigNumber(y, b).\r\n   */ P.minus = function(y, b) {\n        var i, j, t, xLTy, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.plus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Either Infinity?\n            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\n            // Either zero?\n            if (!xc[0] || !yc[0]) {\n                // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n                return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x : // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\n                ROUNDING_MODE == 3 ? -0 : 0);\n            }\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Determine which is the bigger number.\n        if (a = xe - ye) {\n            if (xLTy = a < 0) {\n                a = -a;\n                t = xc;\n            } else {\n                ye = xe;\n                t = yc;\n            }\n            t.reverse();\n            // Prepend zeros to equalise exponents.\n            for(b = a; b--; t.push(0));\n            t.reverse();\n        } else {\n            // Exponents equal. Check digit by digit.\n            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\n            for(a = b = 0; b < j; b++){\n                if (xc[b] != yc[b]) {\n                    xLTy = xc[b] < yc[b];\n                    break;\n                }\n            }\n        }\n        // x < y? Point xc to the array of the bigger number.\n        if (xLTy) {\n            t = xc;\n            xc = yc;\n            yc = t;\n            y.s = -y.s;\n        }\n        b = (j = yc.length) - (i = xc.length);\n        // Append zeros to xc if shorter.\n        // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\n        if (b > 0) for(; b--; xc[i++] = 0);\n        b = BASE - 1;\n        // Subtract yc from xc.\n        for(; j > a;){\n            if (xc[--j] < yc[j]) {\n                for(i = j; i && !xc[--i]; xc[i] = b);\n                --xc[i];\n                xc[j] += BASE;\n            }\n            xc[j] -= yc[j];\n        }\n        // Remove leading zeros and adjust exponent accordingly.\n        for(; xc[0] == 0; xc.splice(0, 1), --ye);\n        // Zero?\n        if (!xc[0]) {\n            // Following IEEE 754 (2008) 6.3,\n            // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\n            y.s = ROUNDING_MODE == 3 ? -1 : 1;\n            y.c = [\n                y.e = 0\n            ];\n            return y;\n        }\n        // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\n        // for finite x and y.\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n   * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n   */ P.modulo = P.mod = function(y, b) {\n        var q, s, x = this;\n        y = new BigNumber(y, b);\n        // Return NaN if x is Infinity or NaN, or y is NaN or zero.\n        if (!x.c || !y.s || y.c && !y.c[0]) {\n            return new BigNumber(NaN);\n        // Return x if y is Infinity or x is zero.\n        } else if (!y.c || x.c && !x.c[0]) {\n            return new BigNumber(x);\n        }\n        if (MODULO_MODE == 9) {\n            // Euclidian division: q = sign(y) * floor(x / abs(y))\n            // r = x - qy    where  0 <= r < abs(y)\n            s = y.s;\n            y.s = 1;\n            q = div(x, y, 0, 3);\n            y.s = s;\n            q.s *= s;\n        } else {\n            q = div(x, y, 0, MODULO_MODE);\n        }\n        y = x.minus(q.times(y));\n        // To match JavaScript %, ensure sign of zero is sign of dividend.\n        if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\n        return y;\n    };\n    /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n   * of BigNumber(y, b).\r\n   */ P.multipliedBy = P.times = function(y, b) {\n        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber(y, b)).c;\n        // Either NaN, ±Infinity or ±0?\n        if (!xc || !yc || !xc[0] || !yc[0]) {\n            // Return NaN if either is NaN, or one is 0 and the other is Infinity.\n            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\n                y.c = y.e = y.s = null;\n            } else {\n                y.s *= x.s;\n                // Return ±Infinity if either is ±Infinity.\n                if (!xc || !yc) {\n                    y.c = y.e = null;\n                // Return ±0 if either is ±0.\n                } else {\n                    y.c = [\n                        0\n                    ];\n                    y.e = 0;\n                }\n            }\n            return y;\n        }\n        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\n        y.s *= x.s;\n        xcL = xc.length;\n        ycL = yc.length;\n        // Ensure xc points to longer array and xcL to its length.\n        if (xcL < ycL) {\n            zc = xc;\n            xc = yc;\n            yc = zc;\n            i = xcL;\n            xcL = ycL;\n            ycL = i;\n        }\n        // Initialise the result array with zeros.\n        for(i = xcL + ycL, zc = []; i--; zc.push(0));\n        base = BASE;\n        sqrtBase = SQRT_BASE;\n        for(i = ycL; --i >= 0;){\n            c = 0;\n            ylo = yc[i] % sqrtBase;\n            yhi = yc[i] / sqrtBase | 0;\n            for(k = xcL, j = i + k; j > i;){\n                xlo = xc[--k] % sqrtBase;\n                xhi = xc[k] / sqrtBase | 0;\n                m = yhi * xlo + xhi * ylo;\n                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;\n                c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\n                zc[j--] = xlo % base;\n            }\n            zc[j] = c;\n        }\n        if (c) {\n            ++e;\n        } else {\n            zc.splice(0, 1);\n        }\n        return normalise(y, zc, e);\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n   * i.e. multiplied by -1.\r\n   */ P.negated = function() {\n        var x = new BigNumber(this);\n        x.s = -x.s || null;\n        return x;\n    };\n    /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n   * BigNumber(y, b).\r\n   */ P.plus = function(y, b) {\n        var t, x = this, a = x.s;\n        y = new BigNumber(y, b);\n        b = y.s;\n        // Either NaN?\n        if (!a || !b) return new BigNumber(NaN);\n        // Signs differ?\n        if (a != b) {\n            y.s = -b;\n            return x.minus(y);\n        }\n        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;\n        if (!xe || !ye) {\n            // Return ±Infinity if either ±Infinity.\n            if (!xc || !yc) return new BigNumber(a / 0);\n            // Either zero?\n            // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\n            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\n        }\n        xe = bitFloor(xe);\n        ye = bitFloor(ye);\n        xc = xc.slice();\n        // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\n        if (a = xe - ye) {\n            if (a > 0) {\n                ye = xe;\n                t = yc;\n            } else {\n                a = -a;\n                t = xc;\n            }\n            t.reverse();\n            for(; a--; t.push(0));\n            t.reverse();\n        }\n        a = xc.length;\n        b = yc.length;\n        // Point xc to the longer array, and b to the shorter length.\n        if (a - b < 0) {\n            t = yc;\n            yc = xc;\n            xc = t;\n            b = a;\n        }\n        // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\n        for(a = 0; b;){\n            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\n            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\n        }\n        if (a) {\n            xc = [\n                a\n            ].concat(xc);\n            ++ye;\n        }\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n        // ye = MAX_EXP + 1 possible\n        return normalise(y, xc, ye);\n    };\n    /*\r\n   * If sd is undefined or null or true or false, return the number of significant digits of\r\n   * the value of this BigNumber, or null if the value of this BigNumber is ±Infinity or NaN.\r\n   * If sd is true include integer-part trailing zeros in the count.\r\n   *\r\n   * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n   * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n   * ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n   *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.precision = P.sd = function(sd, rm) {\n        var c, n, v, x = this;\n        if (sd != null && sd !== !!sd) {\n            intCheck(sd, 1, MAX);\n            if (rm == null) rm = ROUNDING_MODE;\n            else intCheck(rm, 0, 8);\n            return round(new BigNumber(x), sd, rm);\n        }\n        if (!(c = x.c)) return null;\n        v = c.length - 1;\n        n = v * LOG_BASE + 1;\n        if (v = c[v]) {\n            // Subtract the number of trailing zeros of the last element.\n            for(; v % 10 == 0; v /= 10, n--);\n            // Add the number of digits of the first element.\n            for(v = c[0]; v >= 10; v /= 10, n++);\n        }\n        if (sd && x.e + 1 > n) n = x.e + 1;\n        return n;\n    };\n    /*\r\n   * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n   * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n   *\r\n   * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n   */ P.shiftedBy = function(k) {\n        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\n        return this.times(\"1e\" + k);\n    };\n    /*\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N) =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I) =  I\r\n   *  sqrt(0) =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n   * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n   */ P.squareRoot = P.sqrt = function() {\n        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber(\"0.5\");\n        // Negative/NaN/Infinity/zero?\n        if (s !== 1 || !c || !c[0]) {\n            return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\n        }\n        // Initial estimate.\n        s = Math.sqrt(+valueOf(x));\n        // Math.sqrt underflow/overflow?\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n        if (s == 0 || s == 1 / 0) {\n            n = coeffToString(c);\n            if ((n.length + e) % 2 == 0) n += \"0\";\n            s = Math.sqrt(+n);\n            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\n            if (s == 1 / 0) {\n                n = \"5e\" + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n            }\n            r = new BigNumber(n);\n        } else {\n            r = new BigNumber(s + \"\");\n        }\n        // Check for zero.\n        // r could be zero if MIN_EXP is changed after the this value was created.\n        // This would cause a division by zero (x/t) and hence Infinity below, which would cause\n        // coeffToString to throw.\n        if (r.c[0]) {\n            e = r.e;\n            s = e + dp;\n            if (s < 3) s = 0;\n            // Newton-Raphson iteration.\n            for(;;){\n                t = r;\n                r = half.times(t.plus(div(x, t, dp, 1)));\n                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\n                    // The exponent of r may here be one less than the final result exponent,\n                    // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\n                    // are indexed correctly.\n                    if (r.e < e) --s;\n                    n = n.slice(s - 3, s + 1);\n                    // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\n                    // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\n                    // iteration.\n                    if (n == \"9999\" || !rep && n == \"4999\") {\n                        // On the first iteration only, check to see if rounding up gives the\n                        // exact result as the nines may infinitely repeat.\n                        if (!rep) {\n                            round(t, t.e + DECIMAL_PLACES + 2, 0);\n                            if (t.times(t).eq(x)) {\n                                r = t;\n                                break;\n                            }\n                        }\n                        dp += 4;\n                        s += 4;\n                        rep = 1;\n                    } else {\n                        // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\n                        // result. If not, then there are further digits and m will be truthy.\n                        if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                            // Truncate to the first rounding digit.\n                            round(r, r.e + DECIMAL_PLACES + 2, 1);\n                            m = !r.times(r).eq(x);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in exponential notation and\r\n   * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toExponential = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp++;\n        }\n        return format(this, dp, rm, 1);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n   * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n   *\r\n   * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n   * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   */ P.toFixed = function(dp, rm) {\n        if (dp != null) {\n            intCheck(dp, 0, MAX);\n            dp = dp + this.e + 1;\n        }\n        return format(this, dp, rm);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n   * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n   * of the format or FORMAT object (see BigNumber.set).\r\n   *\r\n   * The formatting object may contain some or all of the properties shown below.\r\n   *\r\n   * FORMAT = {\r\n   *   prefix: '',\r\n   *   groupSize: 3,\r\n   *   secondaryGroupSize: 0,\r\n   *   groupSeparator: ',',\r\n   *   decimalSeparator: '.',\r\n   *   fractionGroupSize: 0,\r\n   *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n   *   suffix: ''\r\n   * };\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   * [format] {object} Formatting options. See FORMAT pbject above.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n   * '[BigNumber Error] Argument not an object: {format}'\r\n   */ P.toFormat = function(dp, rm, format) {\n        var str, x = this;\n        if (format == null) {\n            if (dp != null && rm && typeof rm == \"object\") {\n                format = rm;\n                rm = null;\n            } else if (dp && typeof dp == \"object\") {\n                format = dp;\n                dp = rm = null;\n            } else {\n                format = FORMAT;\n            }\n        } else if (typeof format != \"object\") {\n            throw Error(bignumberError + \"Argument not an object: \" + format);\n        }\n        str = x.toFixed(dp, rm);\n        if (x.c) {\n            var i, arr = str.split(\".\"), g1 = +format.groupSize, g2 = +format.secondaryGroupSize, groupSeparator = format.groupSeparator || \"\", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;\n            if (g2) {\n                i = g1;\n                g1 = g2;\n                g2 = i;\n                len -= i;\n            }\n            if (g1 > 0 && len > 0) {\n                i = len % g1 || g1;\n                intPart = intDigits.substr(0, i);\n                for(; i < len; i += g1)intPart += groupSeparator + intDigits.substr(i, g1);\n                if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\n                if (isNeg) intPart = \"-\" + intPart;\n            }\n            str = fractionPart ? intPart + (format.decimalSeparator || \"\") + ((g2 = +format.fractionGroupSize) ? fractionPart.replace(new RegExp(\"\\\\d{\" + g2 + \"}\\\\B\", \"g\"), \"$&\" + (format.fractionGroupSeparator || \"\")) : fractionPart) : intPart;\n        }\n        return (format.prefix || \"\") + str + (format.suffix || \"\");\n    };\n    /*\r\n   * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n   * fraction with an integer numerator and an integer denominator.\r\n   * The denominator will be a positive non-zero value less than or equal to the specified\r\n   * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n   * the lowest value necessary to represent the number exactly.\r\n   *\r\n   * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n   *\r\n   * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n   */ P.toFraction = function(md) {\n        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;\n        if (md != null) {\n            n = new BigNumber(md);\n            // Throw if md is less than one or is not an integer, unless it is Infinity.\n            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\n                throw Error(bignumberError + \"Argument \" + (n.isInteger() ? \"out of range: \" : \"not an integer: \") + valueOf(n));\n            }\n        }\n        if (!xc) return new BigNumber(x);\n        d = new BigNumber(ONE);\n        n1 = d0 = new BigNumber(ONE);\n        d1 = n0 = new BigNumber(ONE);\n        s = coeffToString(xc);\n        // Determine initial denominator.\n        // d is a power of 10 and the minimum max denominator that specifies the value exactly.\n        e = d.e = s.length - x.e - 1;\n        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\n        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;\n        exp = MAX_EXP;\n        MAX_EXP = 1 / 0;\n        n = new BigNumber(s);\n        // n0 = d1 = 0\n        n0.c[0] = 0;\n        for(;;){\n            q = div(n, d, 0, 1);\n            d2 = d0.plus(q.times(d1));\n            if (d2.comparedTo(md) == 1) break;\n            d0 = d1;\n            d1 = d2;\n            n1 = n0.plus(q.times(d2 = n1));\n            n0 = d2;\n            d = n.minus(q.times(d2 = d));\n            n = d2;\n        }\n        d2 = div(md.minus(d0), d1, 0, 1);\n        n0 = n0.plus(d2.times(n1));\n        d0 = d0.plus(d2.times(d1));\n        n0.s = n1.s = x.s;\n        e = e * 2;\n        // Determine which fraction is closer to x, n0/d0 or n1/d1\n        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [\n            n1,\n            d1\n        ] : [\n            n0,\n            d0\n        ];\n        MAX_EXP = exp;\n        return r;\n    };\n    /*\r\n   * Return the value of this BigNumber converted to a number primitive.\r\n   */ P.toNumber = function() {\n        return +valueOf(this);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n   * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n   * necessary to represent the integer part of the value in fixed-point notation, then use\r\n   * exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n   */ P.toPrecision = function(sd, rm) {\n        if (sd != null) intCheck(sd, 1, MAX);\n        return format(this, sd, rm, 2);\n    };\n    /*\r\n   * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n   * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n   * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n   * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n   * TO_EXP_NEG, return exponential notation.\r\n   *\r\n   * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n   *\r\n   * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n   */ P.toString = function(b) {\n        var str, n = this, s = n.s, e = n.e;\n        // Infinity or NaN?\n        if (e === null) {\n            if (s) {\n                str = \"Infinity\";\n                if (s < 0) str = \"-\" + str;\n            } else {\n                str = \"NaN\";\n            }\n        } else {\n            if (b == null) {\n                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, \"0\");\n            } else if (b === 10 && alphabetHasNormalDecimalDigits) {\n                n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\n                str = toFixedPoint(coeffToString(n.c), n.e, \"0\");\n            } else {\n                intCheck(b, 2, ALPHABET.length, \"Base\");\n                str = convertBase(toFixedPoint(coeffToString(n.c), e, \"0\"), 10, b, s, true);\n            }\n            if (s < 0 && n.c[0]) str = \"-\" + str;\n        }\n        return str;\n    };\n    /*\r\n   * Return as toString, but do not accept a base argument, and include the minus sign for\r\n   * negative zero.\r\n   */ P.valueOf = P.toJSON = function() {\n        return valueOf(this);\n    };\n    P._isBigNumber = true;\n    P[Symbol.toStringTag] = \"BigNumber\";\n    // Node.js v10.12.0+\n    P[Symbol.for(\"nodejs.util.inspect.custom\")] = P.valueOf;\n    if (configObject != null) BigNumber.set(configObject);\n    return BigNumber;\n}\n// PRIVATE HELPER FUNCTIONS\n// These functions don't need access to variables,\n// e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\nfunction bitFloor(n) {\n    var i = n | 0;\n    return n > 0 || n === i ? i : i - 1;\n}\n// Return a coefficient array as a string of base 10 digits.\nfunction coeffToString(a) {\n    var s, z, i = 1, j = a.length, r = a[0] + \"\";\n    for(; i < j;){\n        s = a[i++] + \"\";\n        z = LOG_BASE - s.length;\n        for(; z--; s = \"0\" + s);\n        r += s;\n    }\n    // Determine trailing zeros.\n    for(j = r.length; r.charCodeAt(--j) === 48;);\n    return r.slice(0, j + 1 || 1);\n}\n// Compare the value of BigNumbers x and y.\nfunction compare(x, y) {\n    var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;\n    // Either NaN?\n    if (!i || !j) return null;\n    a = xc && !xc[0];\n    b = yc && !yc[0];\n    // Either zero?\n    if (a || b) return a ? b ? 0 : -j : i;\n    // Signs differ?\n    if (i != j) return i;\n    a = i < 0;\n    b = k == l;\n    // Either Infinity?\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\n    // Compare exponents.\n    if (!b) return k > l ^ a ? 1 : -1;\n    j = (k = xc.length) < (l = yc.length) ? k : l;\n    // Compare digit by digit.\n    for(i = 0; i < j; i++)if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\n    // Compare lengths.\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\n}\n/*\r\n * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n */ function intCheck(n, min, max, name) {\n    if (n < min || n > max || n !== mathfloor(n)) {\n        throw Error(bignumberError + (name || \"Argument\") + (typeof n == \"number\" ? n < min || n > max ? \" out of range: \" : \" not an integer: \" : \" not a primitive number: \") + String(n));\n    }\n}\n// Assumes finite n.\nfunction isOdd(n) {\n    var k = n.c.length - 1;\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\n}\nfunction toExponential(str, e) {\n    return (str.length > 1 ? str.charAt(0) + \".\" + str.slice(1) : str) + (e < 0 ? \"e\" : \"e+\") + e;\n}\nfunction toFixedPoint(str, e, z) {\n    var len, zs;\n    // Negative exponent?\n    if (e < 0) {\n        // Prepend zeros.\n        for(zs = z + \".\"; ++e; zs += z);\n        str = zs + str;\n    // Positive exponent\n    } else {\n        len = str.length;\n        // Append zeros.\n        if (++e > len) {\n            for(zs = z, e -= len; --e; zs += z);\n            str += zs;\n        } else if (e < len) {\n            str = str.slice(0, e) + \".\" + str.slice(e);\n        }\n    }\n    return str;\n}\n// EXPORT\nvar BigNumber = clone();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BigNumber);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYmlnbnVtYmVyLmpzQDkuMy4xL25vZGVfbW9kdWxlcy9iaWdudW1iZXIuanMvYmlnbnVtYmVyLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2Q0MsR0FHRCxJQUNFQSxZQUFZLDhDQUNaQyxXQUFXQyxLQUFLQyxJQUFJLEVBQ3BCQyxZQUFZRixLQUFLRyxLQUFLLEVBRXRCQyxpQkFBaUIsc0JBQ2pCQyxnQkFBZ0JELGlCQUFpQiwwREFFakNFLE9BQU8sTUFDUEMsV0FBVyxJQUNYQyxtQkFBbUIsa0JBQ25CLHdEQUF3RDtBQUN4REMsV0FBVztJQUFDO0lBQUc7SUFBSTtJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBSztJQUFLO0lBQUs7SUFBTTtJQUFNO0lBQU07Q0FBSyxFQUNsRkMsWUFBWSxLQUVaLFdBQVc7QUFDWCwwRkFBMEY7QUFDMUYsc0VBQXNFO0FBQ3RFQyxNQUFNLEtBQXVDLGlCQUFpQjtBQUdoRTs7Q0FFQyxHQUNELFNBQVNDLE1BQU1DLFlBQVk7SUFDekIsSUFBSUMsS0FBS0MsYUFBYUMsY0FDcEJDLElBQUlDLFVBQVVDLFNBQVMsR0FBRztRQUFFQyxhQUFhRjtRQUFXRyxVQUFVO1FBQU1DLFNBQVM7SUFBSyxHQUNsRkMsTUFBTSxJQUFJTCxVQUFVLElBR3BCLHdGQUF3RjtJQUd4RixnRkFBZ0Y7SUFDaEYsa0VBQWtFO0lBRWxFLDBFQUEwRTtJQUMxRU0saUJBQWlCLElBRWpCLG1GQUFtRjtJQUNuRiwrRUFBK0U7SUFDL0UsK0JBQStCO0lBQy9CLDZCQUE2QjtJQUM3QixrQ0FBa0M7SUFDbEMsa0NBQWtDO0lBQ2xDLDhEQUE4RDtJQUM5RCxnRUFBZ0U7SUFDaEUsa0ZBQWtGO0lBQ2xGLDZFQUE2RTtJQUM3RSw2RUFBNkU7SUFDN0VDLGdCQUFnQixHQUVoQiw2Q0FBNkM7SUFFN0MsaUZBQWlGO0lBQ2pGLGtCQUFr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dEUsRUFBRS9DLENBQUMsR0FBRzFDLGFBQWF1RyxLQUFLZCxFQUFFakQsQ0FBQyxDQUFDK0QsRUFBRSxHQUFHLEtBQUs7QUFDeEQ7QUFHQSxTQUFTNkQsY0FBY3RILEdBQUcsRUFBRUosQ0FBQztJQUMzQixPQUFPLENBQUNJLElBQUlZLE1BQU0sR0FBRyxJQUFJWixJQUFJaUIsTUFBTSxDQUFDLEtBQUssTUFBTWpCLElBQUlJLEtBQUssQ0FBQyxLQUFLSixHQUFFLElBQzlESixDQUFBQSxJQUFJLElBQUksTUFBTSxJQUFHLElBQUtBO0FBQzFCO0FBR0EsU0FBU3FGLGFBQWFqRixHQUFHLEVBQUVKLENBQUMsRUFBRW9OLENBQUM7SUFDN0IsSUFBSWpOLEtBQUtvTjtJQUVULHFCQUFxQjtJQUNyQixJQUFJdk4sSUFBSSxHQUFHO1FBRVQsaUJBQWlCO1FBQ2pCLElBQUt1TixLQUFLSCxJQUFJLEtBQUssRUFBRXBOLEdBQUd1TixNQUFNSDtRQUM5QmhOLE1BQU1tTixLQUFLbk47SUFFYixvQkFBb0I7SUFDcEIsT0FBTztRQUNMRCxNQUFNQyxJQUFJWSxNQUFNO1FBRWhCLGdCQUFnQjtRQUNoQixJQUFJLEVBQUVoQixJQUFJRyxLQUFLO1lBQ2IsSUFBS29OLEtBQUtILEdBQUdwTixLQUFLRyxLQUFLLEVBQUVILEdBQUd1TixNQUFNSDtZQUNsQ2hOLE9BQU9tTjtRQUNULE9BQU8sSUFBSXZOLElBQUlHLEtBQUs7WUFDbEJDLE1BQU1BLElBQUlJLEtBQUssQ0FBQyxHQUFHUixLQUFLLE1BQU1JLElBQUlJLEtBQUssQ0FBQ1I7UUFDMUM7SUFDRjtJQUVBLE9BQU9JO0FBQ1Q7QUFHQSxTQUFTO0FBR0YsSUFBSW5DLFlBQVlOLFFBQVE7QUFFL0IsaUVBQWVNLFNBQVNBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVzYWxlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9iaWdudW1iZXIuanNAOS4zLjEvbm9kZV9tb2R1bGVzL2JpZ251bWJlci5qcy9iaWdudW1iZXIubWpzP2ZmOTgiXSwic291cmNlc0NvbnRlbnQiOlsiLypcclxuICogICAgICBiaWdudW1iZXIuanMgdjkuMy4xXHJcbiAqICAgICAgQSBKYXZhU2NyaXB0IGxpYnJhcnkgZm9yIGFyYml0cmFyeS1wcmVjaXNpb24gYXJpdGhtZXRpYy5cclxuICogICAgICBodHRwczovL2dpdGh1Yi5jb20vTWlrZU1jbC9iaWdudW1iZXIuanNcclxuICogICAgICBDb3B5cmlnaHQgKGMpIDIwMjUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICogICAgICBNSVQgTGljZW5zZWQuXHJcbiAqXHJcbiAqICAgICAgQmlnTnVtYmVyLnByb3RvdHlwZSBtZXRob2RzICAgICB8ICBCaWdOdW1iZXIgbWV0aG9kc1xyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGFic29sdXRlVmFsdWUgICAgICAgICAgICBhYnMgICAgfCAgY2xvbmVcclxuICogICAgICBjb21wYXJlZFRvICAgICAgICAgICAgICAgICAgICAgIHwgIGNvbmZpZyAgICAgICAgICAgICAgIHNldFxyXG4gKiAgICAgIGRlY2ltYWxQbGFjZXMgICAgICAgICAgICBkcCAgICAgfCAgICAgIERFQ0lNQUxfUExBQ0VTXHJcbiAqICAgICAgZGl2aWRlZEJ5ICAgICAgICAgICAgICAgIGRpdiAgICB8ICAgICAgUk9VTkRJTkdfTU9ERVxyXG4gKiAgICAgIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICBpZGl2ICAgfCAgICAgIEVYUE9ORU5USUFMX0FUXHJcbiAqICAgICAgZXhwb25lbnRpYXRlZEJ5ICAgICAgICAgIHBvdyAgICB8ICAgICAgUkFOR0VcclxuICogICAgICBpbnRlZ2VyVmFsdWUgICAgICAgICAgICAgICAgICAgIHwgICAgICBDUllQVE9cclxuICogICAgICBpc0VxdWFsVG8gICAgICAgICAgICAgICAgZXEgICAgIHwgICAgICBNT0RVTE9fTU9ERVxyXG4gKiAgICAgIGlzRmluaXRlICAgICAgICAgICAgICAgICAgICAgICAgfCAgICAgIFBPV19QUkVDSVNJT05cclxuICogICAgICBpc0dyZWF0ZXJUaGFuICAgICAgICAgICAgZ3QgICAgIHwgICAgICBGT1JNQVRcclxuICogICAgICBpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvICAgZ3RlICAgIHwgICAgICBBTFBIQUJFVFxyXG4gKiAgICAgIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgICAgICAgfCAgaXNCaWdOdW1iZXJcclxuICogICAgICBpc0xlc3NUaGFuICAgICAgICAgICAgICAgbHQgICAgIHwgIG1heGltdW0gICAgICAgICAgICAgIG1heFxyXG4gKiAgICAgIGlzTGVzc1RoYW5PckVxdWFsVG8gICAgICBsdGUgICAgfCAgbWluaW11bSAgICAgICAgICAgICAgbWluXHJcbiAqICAgICAgaXNOYU4gICAgICAgICAgICAgICAgICAgICAgICAgICB8ICByYW5kb21cclxuICogICAgICBpc05lZ2F0aXZlICAgICAgICAgICAgICAgICAgICAgIHwgIHN1bVxyXG4gKiAgICAgIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIGlzWmVybyAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1pbnVzICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIG1vZHVsbyAgICAgICAgICAgICAgICAgICBtb2QgICAgfFxyXG4gKiAgICAgIG11bHRpcGxpZWRCeSAgICAgICAgICAgICB0aW1lcyAgfFxyXG4gKiAgICAgIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHBsdXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHByZWNpc2lvbiAgICAgICAgICAgICAgICBzZCAgICAgfFxyXG4gKiAgICAgIHNoaWZ0ZWRCeSAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHNxdWFyZVJvb3QgICAgICAgICAgICAgICBzcXJ0ICAgfFxyXG4gKiAgICAgIHRvRXhwb25lbnRpYWwgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRml4ZWQgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRm9ybWF0ICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvRnJhY3Rpb24gICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvSlNPTiAgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvTnVtYmVyICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvUHJlY2lzaW9uICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHRvU3RyaW5nICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKiAgICAgIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgICAgICAgfFxyXG4gKlxyXG4gKi9cclxuXHJcblxyXG52YXJcclxuICBpc051bWVyaWMgPSAvXi0/KD86XFxkKyg/OlxcLlxcZCopP3xcXC5cXGQrKSg/OmVbKy1dP1xcZCspPyQvaSxcclxuICBtYXRoY2VpbCA9IE1hdGguY2VpbCxcclxuICBtYXRoZmxvb3IgPSBNYXRoLmZsb29yLFxyXG5cclxuICBiaWdudW1iZXJFcnJvciA9ICdbQmlnTnVtYmVyIEVycm9yXSAnLFxyXG4gIHRvb01hbnlEaWdpdHMgPSBiaWdudW1iZXJFcnJvciArICdOdW1iZXIgcHJpbWl0aXZlIGhhcyBtb3JlIHRoYW4gMTUgc2lnbmlmaWNhbnQgZGlnaXRzOiAnLFxyXG5cclxuICBCQVNFID0gMWUxNCxcclxuICBMT0dfQkFTRSA9IDE0LFxyXG4gIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFmZmZmZmZmZmZmZmZmLCAgICAgICAgIC8vIDJeNTMgLSAxXHJcbiAgLy8gTUFYX0lOVDMyID0gMHg3ZmZmZmZmZiwgICAgICAgICAgICAgICAgICAgLy8gMl4zMSAtIDFcclxuICBQT1dTX1RFTiA9IFsxLCAxMCwgMTAwLCAxZTMsIDFlNCwgMWU1LCAxZTYsIDFlNywgMWU4LCAxZTksIDFlMTAsIDFlMTEsIDFlMTIsIDFlMTNdLFxyXG4gIFNRUlRfQkFTRSA9IDFlNyxcclxuXHJcbiAgLy8gRURJVEFCTEVcclxuICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIERFQ0lNQUxfUExBQ0VTLCBUT19FWFBfTkVHLCBUT19FWFBfUE9TLCBNSU5fRVhQLCBNQVhfRVhQLCBhbmRcclxuICAvLyB0aGUgYXJndW1lbnRzIHRvIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0LCBhbmQgdG9QcmVjaXNpb24uXHJcbiAgTUFYID0gMUU5OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhfSU5UMzJcclxuXHJcblxyXG4vKlxyXG4gKiBDcmVhdGUgYW5kIHJldHVybiBhIEJpZ051bWJlciBjb25zdHJ1Y3Rvci5cclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKGNvbmZpZ09iamVjdCkge1xyXG4gIHZhciBkaXYsIGNvbnZlcnRCYXNlLCBwYXJzZU51bWVyaWMsXHJcbiAgICBQID0gQmlnTnVtYmVyLnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IEJpZ051bWJlciwgdG9TdHJpbmc6IG51bGwsIHZhbHVlT2Y6IG51bGwgfSxcclxuICAgIE9ORSA9IG5ldyBCaWdOdW1iZXIoMSksXHJcblxyXG5cclxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRURJVEFCTEUgQ09ORklHIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcblxyXG4gICAgLy8gVGhlIGRlZmF1bHQgdmFsdWVzIGJlbG93IG11c3QgYmUgaW50ZWdlcnMgd2l0aGluIHRoZSBpbmNsdXNpdmUgcmFuZ2VzIHN0YXRlZC5cclxuICAgIC8vIFRoZSB2YWx1ZXMgY2FuIGFsc28gYmUgY2hhbmdlZCBhdCBydW4tdGltZSB1c2luZyBCaWdOdW1iZXIuc2V0LlxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBmb3Igb3BlcmF0aW9ucyBpbnZvbHZpbmcgZGl2aXNpb24uXHJcbiAgICBERUNJTUFMX1BMQUNFUyA9IDIwLCAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gTUFYXHJcblxyXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIHRoZSBhYm92ZSBkZWNpbWFsIHBsYWNlcywgYW5kIHdoZW4gdXNpbmdcclxuICAgIC8vIHRvRXhwb25lbnRpYWwsIHRvRml4ZWQsIHRvRm9ybWF0IGFuZCB0b1ByZWNpc2lvbiwgYW5kIHJvdW5kIChkZWZhdWx0IHZhbHVlKS5cclxuICAgIC8vIFVQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgIC8vIERPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAvLyBDRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBGTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAvLyBIQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgLy8gSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgLy8gSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgLy8gSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIEhBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICBST1VORElOR19NT0RFID0gNCwgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgIC8vIEVYUE9ORU5USUFMX0FUIDogW1RPX0VYUF9ORUcgLCBUT19FWFBfUE9TXVxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYmVuZWF0aCB3aGljaCB0b1N0cmluZyByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IC03XHJcbiAgICBUT19FWFBfTkVHID0gLTcsICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLU1BWFxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggdG9TdHJpbmcgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIE51bWJlciB0eXBlOiAyMVxyXG4gICAgVE9fRVhQX1BPUyA9IDIxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIE1BWFxyXG5cclxuICAgIC8vIFJBTkdFIDogW01JTl9FWFAsIE1BWF9FWFBdXHJcblxyXG4gICAgLy8gVGhlIG1pbmltdW0gZXhwb25lbnQgdmFsdWUsIGJlbmVhdGggd2hpY2ggdW5kZXJmbG93IHRvIHplcm8gb2NjdXJzLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICBNSU5fRVhQID0gLTFlNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0xIHRvIC1NQVhcclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgLy8gTnVtYmVyIHR5cGU6ICAzMDggICgxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOClcclxuICAgIC8vIEZvciBNQVhfRVhQID4gMWU3LCBlLmcuIG5ldyBCaWdOdW1iZXIoJzFlMTAwMDAwMDAwJykucGx1cygxKSBtYXkgYmUgc2xvdy5cclxuICAgIE1BWF9FWFAgPSAxZTcsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhcclxuXHJcbiAgICAvLyBXaGV0aGVyIHRvIHVzZSBjcnlwdG9ncmFwaGljYWxseS1zZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uLCBpZiBhdmFpbGFibGUuXHJcbiAgICBDUllQVE8gPSBmYWxzZSwgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUgb3IgZmFsc2VcclxuXHJcbiAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgLy8gVGhlIHF1b3RpZW50IChxID0gYSAvIG4pIGlzIGNhbGN1bGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJvdW5kaW5nIG1vZGUuXHJcbiAgICAvLyBUaGUgcmVtYWluZGVyIChyKSBpcyBjYWxjdWxhdGVkIGFzOiByID0gYSAtIG4gKiBxLlxyXG4gICAgLy9cclxuICAgIC8vIFVQICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgLy8gRE9XTiAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQuXHJcbiAgICAvLyAgICAgICAgICAgICBUaGlzIG1vZHVsbyBtb2RlIGlzIGNvbW1vbmx5IGtub3duIGFzICd0cnVuY2F0ZWQgZGl2aXNpb24nIGFuZCBpc1xyXG4gICAgLy8gICAgICAgICAgICAgZXF1aXZhbGVudCB0byAoYSAlIG4pIGluIEphdmFTY3JpcHQuXHJcbiAgICAvLyBGTE9PUiAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAvLyBIQUxGX0VWRU4gNiBUaGlzIG1vZHVsbyBtb2RlIGltcGxlbWVudHMgdGhlIElFRUUgNzU0IHJlbWFpbmRlciBmdW5jdGlvbi5cclxuICAgIC8vIEVVQ0xJRCAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS5cclxuICAgIC8vICAgICAgICAgICAgIFRoZSByZW1haW5kZXIgaXMgYWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgLy9cclxuICAgIC8vIFRoZSB0cnVuY2F0ZWQgZGl2aXNpb24sIGZsb29yZWQgZGl2aXNpb24sIEV1Y2xpZGlhbiBkaXZpc2lvbiBhbmQgSUVFRSA3NTQgcmVtYWluZGVyXHJcbiAgICAvLyBtb2RlcyBhcmUgY29tbW9ubHkgdXNlZCBmb3IgdGhlIG1vZHVsdXMgb3BlcmF0aW9uLlxyXG4gICAgLy8gQWx0aG91Z2ggdGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvIGJlIHVzZWQsIHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgTU9EVUxPX01PREUgPSAxLCAgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDlcclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgdGhlIGV4cG9uZW50aWF0ZWRCeSBvcGVyYXRpb24uXHJcbiAgICAvLyBJZiBQT1dfUFJFQ0lTSU9OIGlzIDAsIHRoZXJlIHdpbGwgYmUgdW5saW1pdGVkIHNpZ25pZmljYW50IGRpZ2l0cy5cclxuICAgIFBPV19QUkVDSVNJT04gPSAwLCAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBNQVhcclxuXHJcbiAgICAvLyBUaGUgZm9ybWF0IHNwZWNpZmljYXRpb24gdXNlZCBieSB0aGUgQmlnTnVtYmVyLnByb3RvdHlwZS50b0Zvcm1hdCBtZXRob2QuXHJcbiAgICBGT1JNQVQgPSB7XHJcbiAgICAgIHByZWZpeDogJycsXHJcbiAgICAgIGdyb3VwU2l6ZTogMyxcclxuICAgICAgc2Vjb25kYXJ5R3JvdXBTaXplOiAwLFxyXG4gICAgICBncm91cFNlcGFyYXRvcjogJywnLFxyXG4gICAgICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICAgIGZyYWN0aW9uR3JvdXBTaXplOiAwLFxyXG4gICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yOiAnXFx4QTAnLCAgICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICAgIHN1ZmZpeDogJydcclxuICAgIH0sXHJcblxyXG4gICAgLy8gVGhlIGFscGhhYmV0IHVzZWQgZm9yIGJhc2UgY29udmVyc2lvbi4gSXQgbXVzdCBiZSBhdCBsZWFzdCAyIGNoYXJhY3RlcnMgbG9uZywgd2l0aCBubyAnKycsXHJcbiAgICAvLyAnLScsICcuJywgd2hpdGVzcGFjZSwgb3IgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgLy8gJzAxMjM0NTY3ODlhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ekFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaJF8nXHJcbiAgICBBTFBIQUJFVCA9ICcwMTIzNDU2Nzg5YWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXonLFxyXG4gICAgYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzID0gdHJ1ZTtcclxuXHJcblxyXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblxyXG5cclxuICAvLyBDT05TVFJVQ1RPUlxyXG5cclxuXHJcbiAgLypcclxuICAgKiBUaGUgQmlnTnVtYmVyIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgKiBDcmVhdGUgYW5kIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJpZ051bWJlciBvYmplY3QuXHJcbiAgICpcclxuICAgKiB2IHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gQSBudW1lcmljIHZhbHVlLlxyXG4gICAqIFtiXSB7bnVtYmVyfSBUaGUgYmFzZSBvZiB2LiBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gQmlnTnVtYmVyKHYsIGIpIHtcclxuICAgIHZhciBhbHBoYWJldCwgYywgY2FzZUNoYW5nZWQsIGUsIGksIGlzTnVtLCBsZW4sIHN0cixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgLy8gRW5hYmxlIGNvbnN0cnVjdG9yIGNhbGwgd2l0aG91dCBgbmV3YC5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBCaWdOdW1iZXIpKSByZXR1cm4gbmV3IEJpZ051bWJlcih2LCBiKTtcclxuXHJcbiAgICBpZiAoYiA9PSBudWxsKSB7XHJcblxyXG4gICAgICBpZiAodiAmJiB2Ll9pc0JpZ051bWJlciA9PT0gdHJ1ZSkge1xyXG4gICAgICAgIHgucyA9IHYucztcclxuXHJcbiAgICAgICAgaWYgKCF2LmMgfHwgdi5lID4gTUFYX0VYUCkge1xyXG4gICAgICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgICAgICB9IGVsc2UgaWYgKHYuZSA8IE1JTl9FWFApIHtcclxuICAgICAgICAgIHguYyA9IFt4LmUgPSAwXTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gdi5lO1xyXG4gICAgICAgICAgeC5jID0gdi5jLnNsaWNlKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICgoaXNOdW0gPSB0eXBlb2YgdiA9PSAnbnVtYmVyJykgJiYgdiAqIDAgPT0gMCkge1xyXG5cclxuICAgICAgICAvLyBVc2UgYDEgLyBuYCB0byBoYW5kbGUgbWludXMgemVybyBhbHNvLlxyXG4gICAgICAgIHgucyA9IDEgLyB2IDwgMCA/ICh2ID0gLXYsIC0xKSA6IDE7XHJcblxyXG4gICAgICAgIC8vIEZhc3QgcGF0aCBmb3IgaW50ZWdlcnMsIHdoZXJlIG4gPCAyMTQ3NDgzNjQ4ICgyKiozMSkuXHJcbiAgICAgICAgaWYgKHYgPT09IH5+dikge1xyXG4gICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTAsIGUrKyk7XHJcblxyXG4gICAgICAgICAgaWYgKGUgPiBNQVhfRVhQKSB7XHJcbiAgICAgICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgICB4LmMgPSBbdl07XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBpZiAoIWlzTnVtZXJpYy50ZXN0KHN0ciA9IFN0cmluZyh2KSkpIHJldHVybiBwYXJzZU51bWVyaWMoeCwgc3RyLCBpc051bSk7XHJcblxyXG4gICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09IDQ1ID8gKHN0ciA9IHN0ci5zbGljZSgxKSwgLTEpIDogMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgICAvLyBFeHBvbmVudGlhbCBmb3JtP1xyXG4gICAgICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICAgIGlmIChlIDwgMCkgZSA9IGk7XHJcbiAgICAgICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcblxyXG4gICAgICAgIC8vIEludGVnZXIuXHJcbiAgICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIEJhc2Uge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge2J9J1xyXG4gICAgICBpbnRDaGVjayhiLCAyLCBBTFBIQUJFVC5sZW5ndGgsICdCYXNlJyk7XHJcblxyXG4gICAgICAvLyBBbGxvdyBleHBvbmVudGlhbCBub3RhdGlvbiB0byBiZSB1c2VkIHdpdGggYmFzZSAxMCBhcmd1bWVudCwgd2hpbGVcclxuICAgICAgLy8gYWxzbyByb3VuZGluZyB0byBERUNJTUFMX1BMQUNFUyBhcyB3aXRoIG90aGVyIGJhc2VzLlxyXG4gICAgICBpZiAoYiA9PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICB4ID0gbmV3IEJpZ051bWJlcih2KTtcclxuICAgICAgICByZXR1cm4gcm91bmQoeCwgREVDSU1BTF9QTEFDRVMgKyB4LmUgKyAxLCBST1VORElOR19NT0RFKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gU3RyaW5nKHYpO1xyXG5cclxuICAgICAgaWYgKGlzTnVtID0gdHlwZW9mIHYgPT0gJ251bWJlcicpIHtcclxuXHJcbiAgICAgICAgLy8gQXZvaWQgcG90ZW50aWFsIGludGVycHJldGF0aW9uIG9mIEluZmluaXR5IGFuZCBOYU4gYXMgYmFzZSA0NCsgdmFsdWVzLlxyXG4gICAgICAgIGlmICh2ICogMCAhPSAwKSByZXR1cm4gcGFyc2VOdW1lcmljKHgsIHN0ciwgaXNOdW0sIGIpO1xyXG5cclxuICAgICAgICB4LnMgPSAxIC8gdiA8IDAgPyAoc3RyID0gc3RyLnNsaWNlKDEpLCAtMSkgOiAxO1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICAgIGlmIChCaWdOdW1iZXIuREVCVUcgJiYgc3RyLnJlcGxhY2UoL14wXFwuMCp8XFwuLywgJycpLmxlbmd0aCA+IDE1KSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICh0b29NYW55RGlnaXRzICsgdik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgucyA9IHN0ci5jaGFyQ29kZUF0KDApID09PSA0NSA/IChzdHIgPSBzdHIuc2xpY2UoMSksIC0xKSA6IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFscGhhYmV0ID0gQUxQSEFCRVQuc2xpY2UoMCwgYik7XHJcbiAgICAgIGUgPSBpID0gMDtcclxuXHJcbiAgICAgIC8vIENoZWNrIHRoYXQgc3RyIGlzIGEgdmFsaWQgYmFzZSBiIG51bWJlci5cclxuICAgICAgLy8gRG9uJ3QgdXNlIFJlZ0V4cCwgc28gYWxwaGFiZXQgY2FuIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzLlxyXG4gICAgICBmb3IgKGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmIChhbHBoYWJldC5pbmRleE9mKGMgPSBzdHIuY2hhckF0KGkpKSA8IDApIHtcclxuICAgICAgICAgIGlmIChjID09ICcuJykge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgJy4nIGlzIG5vdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCBpdCBoYXMgbm90IGJlIGZvdW5kIGJlZm9yZS5cclxuICAgICAgICAgICAgaWYgKGkgPiBlKSB7XHJcbiAgICAgICAgICAgICAgZSA9IGxlbjtcclxuICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIGlmICghY2FzZUNoYW5nZWQpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIEFsbG93IGUuZy4gaGV4YWRlY2ltYWwgJ0ZGJyBhcyB3ZWxsIGFzICdmZicuXHJcbiAgICAgICAgICAgIGlmIChzdHIgPT0gc3RyLnRvVXBwZXJDYXNlKCkgJiYgKHN0ciA9IHN0ci50b0xvd2VyQ2FzZSgpKSB8fFxyXG4gICAgICAgICAgICAgICAgc3RyID09IHN0ci50b0xvd2VyQ2FzZSgpICYmIChzdHIgPSBzdHIudG9VcHBlckNhc2UoKSkpIHtcclxuICAgICAgICAgICAgICBjYXNlQ2hhbmdlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgaSA9IC0xO1xyXG4gICAgICAgICAgICAgIGUgPSAwO1xyXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHBhcnNlTnVtZXJpYyh4LCBTdHJpbmcodiksIGlzTnVtLCBiKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFByZXZlbnQgbGF0ZXIgY2hlY2sgZm9yIGxlbmd0aCBvbiBjb252ZXJ0ZWQgbnVtYmVyLlxyXG4gICAgICBpc051bSA9IGZhbHNlO1xyXG4gICAgICBzdHIgPSBjb252ZXJ0QmFzZShzdHIsIGIsIDEwLCB4LnMpO1xyXG5cclxuICAgICAgLy8gRGVjaW1hbCBwb2ludD9cclxuICAgICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcbiAgICAgIGVsc2UgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdCgtLWxlbikgPT09IDQ4Oyk7XHJcblxyXG4gICAgaWYgKHN0ciA9IHN0ci5zbGljZShpLCArK2xlbikpIHtcclxuICAgICAgbGVuIC09IGk7XHJcblxyXG4gICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTnVtYmVyIHByaW1pdGl2ZSBoYXMgbW9yZSB0aGFuIDE1IHNpZ25pZmljYW50IGRpZ2l0czoge259J1xyXG4gICAgICBpZiAoaXNOdW0gJiYgQmlnTnVtYmVyLkRFQlVHICYmXHJcbiAgICAgICAgbGVuID4gMTUgJiYgKHYgPiBNQVhfU0FGRV9JTlRFR0VSIHx8IHYgIT09IG1hdGhmbG9vcih2KSkpIHtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKHRvb01hbnlEaWdpdHMgKyAoeC5zICogdikpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgIGlmICgoZSA9IGUgLSBpIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIHguYyA9IHguZSA9IG51bGw7XHJcblxyXG4gICAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICAgIH0gZWxzZSBpZiAoZSA8IE1JTl9FWFApIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeC5lID0gZTtcclxuICAgICAgICB4LmMgPSBbXTtcclxuXHJcbiAgICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgICAgICAvLyBpIGlzIHdoZXJlIHRvIHNsaWNlIHN0ciB0byBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgb2YgdGhlIGNvZWZmaWNpZW50IGFycmF5LlxyXG4gICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgaWYgKGUgPCAwKSBpICs9IExPR19CQVNFOyAgLy8gaSA8IDFcclxuXHJcbiAgICAgICAgaWYgKGkgPCBsZW4pIHtcclxuICAgICAgICAgIGlmIChpKSB4LmMucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuXHJcbiAgICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHtcclxuICAgICAgICAgICAgeC5jLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaSA9IExPR19CQVNFIC0gKHN0ciA9IHN0ci5zbGljZShpKSkubGVuZ3RoO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpIC09IGxlbjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgIHguYy5wdXNoKCtzdHIpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgLy8gWmVyby5cclxuICAgICAgeC5jID0gW3guZSA9IDBdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIENPTlNUUlVDVE9SIFBST1BFUlRJRVNcclxuXHJcblxyXG4gIEJpZ051bWJlci5jbG9uZSA9IGNsb25lO1xyXG5cclxuICBCaWdOdW1iZXIuUk9VTkRfVVAgPSAwO1xyXG4gIEJpZ051bWJlci5ST1VORF9ET1dOID0gMTtcclxuICBCaWdOdW1iZXIuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0ZMT09SID0gMztcclxuICBCaWdOdW1iZXIuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgQmlnTnVtYmVyLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gIEJpZ051bWJlci5FVUNMSUQgPSA5O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBDb25maWd1cmUgaW5mcmVxdWVudGx5LWNoYW5naW5nIGxpYnJhcnktd2lkZSBzZXR0aW5ncy5cclxuICAgKlxyXG4gICAqIEFjY2VwdCBhbiBvYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIG9wdGlvbmFsIHByb3BlcnRpZXMgKGlmIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IGlzXHJcbiAgICogYSBudW1iZXIsIGl0IG11c3QgYmUgYW4gaW50ZWdlciB3aXRoaW4gdGhlIGluY2x1c2l2ZSByYW5nZSBzdGF0ZWQpOlxyXG4gICAqXHJcbiAgICogICBERUNJTUFMX1BMQUNFUyAgIHtudW1iZXJ9ICAgICAgICAgICAwIHRvIE1BWFxyXG4gICAqICAgUk9VTkRJTkdfTU9ERSAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byA4XHJcbiAgICogICBFWFBPTkVOVElBTF9BVCAgIHtudW1iZXJ8bnVtYmVyW119ICAtTUFYIHRvIE1BWCAgb3IgIFstTUFYIHRvIDAsIDAgdG8gTUFYXVxyXG4gICAqICAgUkFOR0UgICAgICAgICAgICB7bnVtYmVyfG51bWJlcltdfSAgLU1BWCB0byBNQVggKG5vdCB6ZXJvKSAgb3IgIFstTUFYIHRvIC0xLCAxIHRvIE1BWF1cclxuICAgKiAgIENSWVBUTyAgICAgICAgICAge2Jvb2xlYW59ICAgICAgICAgIHRydWUgb3IgZmFsc2VcclxuICAgKiAgIE1PRFVMT19NT0RFICAgICAge251bWJlcn0gICAgICAgICAgIDAgdG8gOVxyXG4gICAqICAgUE9XX1BSRUNJU0lPTiAgICAgICB7bnVtYmVyfSAgICAgICAgICAgMCB0byBNQVhcclxuICAgKiAgIEFMUEhBQkVUICAgICAgICAge3N0cmluZ30gICAgICAgICAgIEEgc3RyaW5nIG9mIHR3byBvciBtb3JlIHVuaXF1ZSBjaGFyYWN0ZXJzIHdoaWNoIGRvZXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdCBjb250YWluICcuJy5cclxuICAgKiAgIEZPUk1BVCAgICAgICAgICAge29iamVjdH0gICAgICAgICAgIEFuIG9iamVjdCB3aXRoIHNvbWUgb2YgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxyXG4gICAqICAgICBwcmVmaXggICAgICAgICAgICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGdyb3VwU2l6ZSAgICAgICAgICAgICAge251bWJlcn1cclxuICAgKiAgICAgc2Vjb25kYXJ5R3JvdXBTaXplICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBncm91cFNlcGFyYXRvciAgICAgICAgIHtzdHJpbmd9XHJcbiAgICogICAgIGRlY2ltYWxTZXBhcmF0b3IgICAgICAge3N0cmluZ31cclxuICAgKiAgICAgZnJhY3Rpb25Hcm91cFNpemUgICAgICB7bnVtYmVyfVxyXG4gICAqICAgICBmcmFjdGlvbkdyb3VwU2VwYXJhdG9yIHtzdHJpbmd9XHJcbiAgICogICAgIHN1ZmZpeCAgICAgICAgICAgICAgICAge3N0cmluZ31cclxuICAgKlxyXG4gICAqIChUaGUgdmFsdWVzIGFzc2lnbmVkIHRvIHRoZSBhYm92ZSBGT1JNQVQgb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdCBjaGVja2VkIGZvciB2YWxpZGl0eS4pXHJcbiAgICpcclxuICAgKiBFLmcuXHJcbiAgICogQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTIDogMjAsIFJPVU5ESU5HX01PREUgOiA0IH0pXHJcbiAgICpcclxuICAgKiBJZ25vcmUgcHJvcGVydGllcy9wYXJhbWV0ZXJzIHNldCB0byBudWxsIG9yIHVuZGVmaW5lZCwgZXhjZXB0IGZvciBBTFBIQUJFVC5cclxuICAgKlxyXG4gICAqIFJldHVybiBhbiBvYmplY3Qgd2l0aCB0aGUgcHJvcGVydGllcyBjdXJyZW50IHZhbHVlcy5cclxuICAgKi9cclxuICBCaWdOdW1iZXIuY29uZmlnID0gQmlnTnVtYmVyLnNldCA9IGZ1bmN0aW9uIChvYmopIHtcclxuICAgIHZhciBwLCB2O1xyXG5cclxuICAgIGlmIChvYmogIT0gbnVsbCkge1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvYmogPT0gJ29iamVjdCcpIHtcclxuXHJcbiAgICAgICAgLy8gREVDSU1BTF9QTEFDRVMge251bWJlcn0gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBERUNJTUFMX1BMQUNFUyB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0RFQ0lNQUxfUExBQ0VTJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgREVDSU1BTF9QTEFDRVMgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUk9VTkRJTkdfTU9ERSB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBST1VORElOR19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnUk9VTkRJTkdfTU9ERScpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaW50Q2hlY2sodiwgMCwgOCwgcCk7XHJcbiAgICAgICAgICBST1VORElOR19NT0RFID0gdjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVYUE9ORU5USUFMX0FUIHtudW1iZXJ8bnVtYmVyW119XHJcbiAgICAgICAgLy8gSW50ZWdlciwgLU1BWCB0byBNQVggaW5jbHVzaXZlIG9yXHJcbiAgICAgICAgLy8gW2ludGVnZXIgLU1BWCB0byAwIGluY2x1c2l2ZSwgMCB0byBNQVggaW5jbHVzaXZlXS5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRVhQT05FTlRJQUxfQVQge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdFWFBPTkVOVElBTF9BVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgJiYgdi5wb3ApIHtcclxuICAgICAgICAgICAgaW50Q2hlY2sodlswXSwgLU1BWCwgMCwgcCk7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDAsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSB2WzBdO1xyXG4gICAgICAgICAgICBUT19FWFBfUE9TID0gdlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIFRPX0VYUF9ORUcgPSAtKFRPX0VYUF9QT1MgPSB2IDwgMCA/IC12IDogdik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSQU5HRSB7bnVtYmVyfG51bWJlcltdfSBOb24temVybyBpbnRlZ2VyLCAtTUFYIHRvIE1BWCBpbmNsdXNpdmUgb3JcclxuICAgICAgICAvLyBbaW50ZWdlciAtTUFYIHRvIC0xIGluY2x1c2l2ZSwgaW50ZWdlciAxIHRvIE1BWCBpbmNsdXNpdmVdLlxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBSQU5HRSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V8Y2Fubm90IGJlIHplcm99OiB7dn0nXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ1JBTkdFJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodiAmJiB2LnBvcCkge1xyXG4gICAgICAgICAgICBpbnRDaGVjayh2WzBdLCAtTUFYLCAtMSwgcCk7XHJcbiAgICAgICAgICAgIGludENoZWNrKHZbMV0sIDEsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIE1JTl9FWFAgPSB2WzBdO1xyXG4gICAgICAgICAgICBNQVhfRVhQID0gdlsxXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGludENoZWNrKHYsIC1NQVgsIE1BWCwgcCk7XHJcbiAgICAgICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICAgICAgTUlOX0VYUCA9IC0oTUFYX0VYUCA9IHYgPCAwID8gLXYgOiB2KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyBwICsgJyBjYW5ub3QgYmUgemVybzogJyArIHYpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBDUllQVE8ge2Jvb2xlYW59IHRydWUgb3IgZmFsc2UuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIENSWVBUTyBub3QgdHJ1ZSBvciBmYWxzZToge3Z9J1xyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBjcnlwdG8gdW5hdmFpbGFibGUnXHJcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwID0gJ0NSWVBUTycpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG4gICAgICAgICAgaWYgKHYgPT09ICEhdikge1xyXG4gICAgICAgICAgICBpZiAodikge1xyXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvICE9ICd1bmRlZmluZWQnICYmIGNyeXB0byAmJlxyXG4gICAgICAgICAgICAgICAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB8fCBjcnlwdG8ucmFuZG9tQnl0ZXMpKSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBDUllQVE8gPSAhdjtcclxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBDUllQVE8gPSB2O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IHRydWUgb3IgZmFsc2U6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1PRFVMT19NT0RFIHtudW1iZXJ9IEludGVnZXIsIDAgdG8gOSBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIE1PRFVMT19NT0RFIHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnTU9EVUxPX01PREUnKSkge1xyXG4gICAgICAgICAgdiA9IG9ialtwXTtcclxuICAgICAgICAgIGludENoZWNrKHYsIDAsIDksIHApO1xyXG4gICAgICAgICAgTU9EVUxPX01PREUgPSB2O1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gUE9XX1BSRUNJU0lPTiB7bnVtYmVyfSBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICAgICAgLy8gJ1tCaWdOdW1iZXIgRXJyb3JdIFBPV19QUkVDSVNJT04ge25vdCBhIHByaW1pdGl2ZSBudW1iZXJ8bm90IGFuIGludGVnZXJ8b3V0IG9mIHJhbmdlfToge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdQT1dfUFJFQ0lTSU9OJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpbnRDaGVjayh2LCAwLCBNQVgsIHApO1xyXG4gICAgICAgICAgUE9XX1BSRUNJU0lPTiA9IHY7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGT1JNQVQge29iamVjdH1cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gRk9STUFUIG5vdCBhbiBvYmplY3Q6IHt2fSdcclxuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHAgPSAnRk9STUFUJykpIHtcclxuICAgICAgICAgIHYgPSBvYmpbcF07XHJcbiAgICAgICAgICBpZiAodHlwZW9mIHYgPT0gJ29iamVjdCcpIEZPUk1BVCA9IHY7XHJcbiAgICAgICAgICBlbHNlIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgcCArICcgbm90IGFuIG9iamVjdDogJyArIHYpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQUxQSEFCRVQge3N0cmluZ31cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gQUxQSEFCRVQgaW52YWxpZDoge3Z9J1xyXG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkocCA9ICdBTFBIQUJFVCcpKSB7XHJcbiAgICAgICAgICB2ID0gb2JqW3BdO1xyXG5cclxuICAgICAgICAgIC8vIERpc2FsbG93IGlmIGxlc3MgdGhhbiB0d28gY2hhcmFjdGVycyxcclxuICAgICAgICAgIC8vIG9yIGlmIGl0IGNvbnRhaW5zICcrJywgJy0nLCAnLicsIHdoaXRlc3BhY2UsIG9yIGEgcmVwZWF0ZWQgY2hhcmFjdGVyLlxyXG4gICAgICAgICAgaWYgKHR5cGVvZiB2ID09ICdzdHJpbmcnICYmICEvXi4/JHxbK1xcLS5cXHNdfCguKS4qXFwxLy50ZXN0KHYpKSB7XHJcbiAgICAgICAgICAgIGFscGhhYmV0SGFzTm9ybWFsRGVjaW1hbERpZ2l0cyA9IHYuc2xpY2UoMCwgMTApID09ICcwMTIzNDU2Nzg5JztcclxuICAgICAgICAgICAgQUxQSEFCRVQgPSB2O1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgIChiaWdudW1iZXJFcnJvciArIHAgKyAnIGludmFsaWQ6ICcgKyB2KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gT2JqZWN0IGV4cGVjdGVkOiB7dn0nXHJcbiAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ09iamVjdCBleHBlY3RlZDogJyArIG9iaik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBERUNJTUFMX1BMQUNFUzogREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgIFJPVU5ESU5HX01PREU6IFJPVU5ESU5HX01PREUsXHJcbiAgICAgIEVYUE9ORU5USUFMX0FUOiBbVE9fRVhQX05FRywgVE9fRVhQX1BPU10sXHJcbiAgICAgIFJBTkdFOiBbTUlOX0VYUCwgTUFYX0VYUF0sXHJcbiAgICAgIENSWVBUTzogQ1JZUFRPLFxyXG4gICAgICBNT0RVTE9fTU9ERTogTU9EVUxPX01PREUsXHJcbiAgICAgIFBPV19QUkVDSVNJT046IFBPV19QUkVDSVNJT04sXHJcbiAgICAgIEZPUk1BVDogRk9STUFULFxyXG4gICAgICBBTFBIQUJFVDogQUxQSEFCRVRcclxuICAgIH07XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdiBpcyBhIEJpZ051bWJlciBpbnN0YW5jZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqIElmIEJpZ051bWJlci5ERUJVRyBpcyB0cnVlLCB0aHJvdyBpZiBhIEJpZ051bWJlciBpbnN0YW5jZSBpcyBub3Qgd2VsbC1mb3JtZWQuXHJcbiAgICpcclxuICAgKiB2IHthbnl9XHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gSW52YWxpZCBCaWdOdW1iZXI6IHt2fSdcclxuICAgKi9cclxuICBCaWdOdW1iZXIuaXNCaWdOdW1iZXIgPSBmdW5jdGlvbiAodikge1xyXG4gICAgaWYgKCF2IHx8IHYuX2lzQmlnTnVtYmVyICE9PSB0cnVlKSByZXR1cm4gZmFsc2U7XHJcbiAgICBpZiAoIUJpZ051bWJlci5ERUJVRykgcmV0dXJuIHRydWU7XHJcblxyXG4gICAgdmFyIGksIG4sXHJcbiAgICAgIGMgPSB2LmMsXHJcbiAgICAgIGUgPSB2LmUsXHJcbiAgICAgIHMgPSB2LnM7XHJcblxyXG4gICAgb3V0OiBpZiAoe30udG9TdHJpbmcuY2FsbChjKSA9PSAnW29iamVjdCBBcnJheV0nKSB7XHJcblxyXG4gICAgICBpZiAoKHMgPT09IDEgfHwgcyA9PT0gLTEpICYmIGUgPj0gLU1BWCAmJiBlIDw9IE1BWCAmJiBlID09PSBtYXRoZmxvb3IoZSkpIHtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGZpcnN0IGVsZW1lbnQgaXMgemVybywgdGhlIEJpZ051bWJlciB2YWx1ZSBtdXN0IGJlIHplcm8uXHJcbiAgICAgICAgaWYgKGNbMF0gPT09IDApIHtcclxuICAgICAgICAgIGlmIChlID09PSAwICYmIGMubGVuZ3RoID09PSAxKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENhbGN1bGF0ZSBudW1iZXIgb2YgZGlnaXRzIHRoYXQgY1swXSBzaG91bGQgaGF2ZSwgYmFzZWQgb24gdGhlIGV4cG9uZW50LlxyXG4gICAgICAgIGkgPSAoZSArIDEpICUgTE9HX0JBU0U7XHJcbiAgICAgICAgaWYgKGkgPCAxKSBpICs9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAvLyBDYWxjdWxhdGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBjWzBdLlxyXG4gICAgICAgIC8vaWYgKE1hdGguY2VpbChNYXRoLmxvZyhjWzBdICsgMSkgLyBNYXRoLkxOMTApID09IGkpIHtcclxuICAgICAgICBpZiAoU3RyaW5nKGNbMF0pLmxlbmd0aCA9PSBpKSB7XHJcblxyXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgbiA9IGNbaV07XHJcbiAgICAgICAgICAgIGlmIChuIDwgMCB8fCBuID49IEJBU0UgfHwgbiAhPT0gbWF0aGZsb29yKG4pKSBicmVhayBvdXQ7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgLy8gTGFzdCBlbGVtZW50IGNhbm5vdCBiZSB6ZXJvLCB1bmxlc3MgaXQgaXMgdGhlIG9ubHkgZWxlbWVudC5cclxuICAgICAgICAgIGlmIChuICE9PSAwKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAvLyBJbmZpbml0eS9OYU5cclxuICAgIH0gZWxzZSBpZiAoYyA9PT0gbnVsbCAmJiBlID09PSBudWxsICYmIChzID09PSBudWxsIHx8IHMgPT09IDEgfHwgcyA9PT0gLTEpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IEVycm9yXHJcbiAgICAgIChiaWdudW1iZXJFcnJvciArICdJbnZhbGlkIEJpZ051bWJlcjogJyArIHYpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLm1heGltdW0gPSBCaWdOdW1iZXIubWF4ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgLTEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLm1pbmltdW0gPSBCaWdOdW1iZXIubWluID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIG1heE9yTWluKGFyZ3VtZW50cywgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSxcclxuICAgKiBhbmQgd2l0aCBkcCwgb3IgREVDSU1BTF9QTEFDRVMgaWYgZHAgaXMgb21pdHRlZCwgZGVjaW1hbCBwbGFjZXMgKG9yIGxlc3MgaWYgdHJhaWxpbmdcclxuICAgKiB6ZXJvcyBhcmUgcHJvZHVjZWQpLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcH0nXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIGNyeXB0byB1bmF2YWlsYWJsZSdcclxuICAgKi9cclxuICBCaWdOdW1iZXIucmFuZG9tID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwb3cyXzUzID0gMHgyMDAwMDAwMDAwMDAwMDtcclxuXHJcbiAgICAvLyBSZXR1cm4gYSA1MyBiaXQgaW50ZWdlciBuLCB3aGVyZSAwIDw9IG4gPCA5MDA3MTk5MjU0NzQwOTkyLlxyXG4gICAgLy8gQ2hlY2sgaWYgTWF0aC5yYW5kb20oKSBwcm9kdWNlcyBtb3JlIHRoYW4gMzIgYml0cyBvZiByYW5kb21uZXNzLlxyXG4gICAgLy8gSWYgaXQgZG9lcywgYXNzdW1lIGF0IGxlYXN0IDUzIGJpdHMgYXJlIHByb2R1Y2VkLCBvdGhlcndpc2UgYXNzdW1lIGF0IGxlYXN0IDMwIGJpdHMuXHJcbiAgICAvLyAweDQwMDAwMDAwIGlzIDJeMzAsIDB4ODAwMDAwIGlzIDJeMjMsIDB4MWZmZmZmIGlzIDJeMjEgLSAxLlxyXG4gICAgdmFyIHJhbmRvbTUzYml0SW50ID0gKE1hdGgucmFuZG9tKCkgKiBwb3cyXzUzKSAmIDB4MWZmZmZmXHJcbiAgICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBtYXRoZmxvb3IoTWF0aC5yYW5kb20oKSAqIHBvdzJfNTMpOyB9XHJcbiAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiAoKE1hdGgucmFuZG9tKCkgKiAweDQwMDAwMDAwIHwgMCkgKiAweDgwMDAwMCkgK1xyXG4gICAgICAgKE1hdGgucmFuZG9tKCkgKiAweDgwMDAwMCB8IDApOyB9O1xyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoZHApIHtcclxuICAgICAgdmFyIGEsIGIsIGUsIGssIHYsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgYyA9IFtdLFxyXG4gICAgICAgIHJhbmQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgICBpZiAoZHAgPT0gbnVsbCkgZHAgPSBERUNJTUFMX1BMQUNFUztcclxuICAgICAgZWxzZSBpbnRDaGVjayhkcCwgMCwgTUFYKTtcclxuXHJcbiAgICAgIGsgPSBtYXRoY2VpbChkcCAvIExPR19CQVNFKTtcclxuXHJcbiAgICAgIGlmIChDUllQVE8pIHtcclxuXHJcbiAgICAgICAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gICAgICAgIGlmIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKSB7XHJcblxyXG4gICAgICAgICAgYSA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGsgKj0gMikpO1xyXG5cclxuICAgICAgICAgIGZvciAoOyBpIDwgazspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIDUzIGJpdHM6XHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgKiBNYXRoLnBvdygyLCAyMSkpLnRvU3RyaW5nKDIpXHJcbiAgICAgICAgICAgIC8vIDExMTExIDExMTExMTExIDExMTExMTExIDExMTExMTExIDExMTAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwXHJcbiAgICAgICAgICAgIC8vICgoTWF0aC5wb3coMiwgMzIpIC0gMSkgPj4+IDExKS50b1N0cmluZygyKVxyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAxMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAweDIwMDAwIGlzIDJeMjEuXHJcbiAgICAgICAgICAgIHYgPSBhW2ldICogMHgyMDAwMCArIChhW2kgKyAxXSA+Pj4gMTEpO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVqZWN0aW9uIHNhbXBsaW5nOlxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIC8vIFByb2JhYmlsaXR5IHRoYXQgdiA+PSA5ZTE1LCBpc1xyXG4gICAgICAgICAgICAvLyA3MTk5MjU0NzQwOTkyIC8gOTAwNzE5OTI1NDc0MDk5MiB+PSAwLjAwMDgsIGkuZS4gMSBpbiAxMjUxXHJcbiAgICAgICAgICAgIGlmICh2ID49IDllMTUpIHtcclxuICAgICAgICAgICAgICBiID0gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMikpO1xyXG4gICAgICAgICAgICAgIGFbaV0gPSBiWzBdO1xyXG4gICAgICAgICAgICAgIGFbaSArIDFdID0gYlsxXTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gMCA8PSB2IDw9IDg5OTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gMjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyAyO1xyXG5cclxuICAgICAgICAvLyBOb2RlLmpzIHN1cHBvcnRpbmcgY3J5cHRvLnJhbmRvbUJ5dGVzLlxyXG4gICAgICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAgICAgLy8gYnVmZmVyXHJcbiAgICAgICAgICBhID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGsgKj0gNyk7XHJcblxyXG4gICAgICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAgICAgLy8gMHgxMDAwMDAwMDAwMDAwIGlzIDJeNDgsIDB4MTAwMDAwMDAwMDAgaXMgMl40MFxyXG4gICAgICAgICAgICAvLyAweDEwMDAwMDAwMCBpcyAyXjMyLCAweDEwMDAwMDAgaXMgMl4yNFxyXG4gICAgICAgICAgICAvLyAxMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMSAxMTExMTExMVxyXG4gICAgICAgICAgICAvLyAwIDw9IHYgPCA5MDA3MTk5MjU0NzQwOTkyXHJcbiAgICAgICAgICAgIHYgPSAoKGFbaV0gJiAzMSkgKiAweDEwMDAwMDAwMDAwMDApICsgKGFbaSArIDFdICogMHgxMDAwMDAwMDAwMCkgK1xyXG4gICAgICAgICAgICAgICAoYVtpICsgMl0gKiAweDEwMDAwMDAwMCkgKyAoYVtpICsgM10gKiAweDEwMDAwMDApICtcclxuICAgICAgICAgICAgICAgKGFbaSArIDRdIDw8IDE2KSArIChhW2kgKyA1XSA8PCA4KSArIGFbaSArIDZdO1xyXG5cclxuICAgICAgICAgICAgaWYgKHYgPj0gOWUxNSkge1xyXG4gICAgICAgICAgICAgIGNyeXB0by5yYW5kb21CeXRlcyg3KS5jb3B5KGEsIGkpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgICAvLyAwIDw9ICh2ICUgMWUxNCkgPD0gOTk5OTk5OTk5OTk5OTlcclxuICAgICAgICAgICAgICBjLnB1c2godiAlIDFlMTQpO1xyXG4gICAgICAgICAgICAgIGkgKz0gNztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgaSA9IGsgLyA3O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBDUllQVE8gPSBmYWxzZTtcclxuICAgICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gVXNlIE1hdGgucmFuZG9tLlxyXG4gICAgICBpZiAoIUNSWVBUTykge1xyXG5cclxuICAgICAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgICAgICB2ID0gcmFuZG9tNTNiaXRJbnQoKTtcclxuICAgICAgICAgIGlmICh2IDwgOWUxNSkgY1tpKytdID0gdiAlIDFlMTQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBrID0gY1stLWldO1xyXG4gICAgICBkcCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgdHJhaWxpbmcgZGlnaXRzIHRvIHplcm9zIGFjY29yZGluZyB0byBkcC5cclxuICAgICAgaWYgKGsgJiYgZHApIHtcclxuICAgICAgICB2ID0gUE9XU19URU5bTE9HX0JBU0UgLSBkcF07XHJcbiAgICAgICAgY1tpXSA9IG1hdGhmbG9vcihrIC8gdikgKiB2O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgZWxlbWVudHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICAgIGZvciAoOyBjW2ldID09PSAwOyBjLnBvcCgpLCBpLS0pO1xyXG5cclxuICAgICAgLy8gWmVybz9cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgYyA9IFtlID0gMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGVsZW1lbnRzIHdoaWNoIGFyZSB6ZXJvIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgZm9yIChlID0gLTEgOyBjWzBdID09PSAwOyBjLnNwbGljZSgwLCAxKSwgZSAtPSBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgIC8vIENvdW50IHRoZSBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYyB0byBkZXRlcm1pbmUgbGVhZGluZyB6ZXJvcywgYW5kLi4uXHJcbiAgICAgICAgZm9yIChpID0gMSwgdiA9IGNbMF07IHYgPj0gMTA7IHYgLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgICAgIC8vIGFkanVzdCB0aGUgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgICAgICAgaWYgKGkgPCBMT0dfQkFTRSkgZSAtPSBMT0dfQkFTRSAtIGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJhbmQuZSA9IGU7XHJcbiAgICAgIHJhbmQuYyA9IGM7XHJcbiAgICAgIHJldHVybiByYW5kO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgIC8qXHJcbiAgICogUmV0dXJuIGEgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9XHJcbiAgICovXHJcbiAgQmlnTnVtYmVyLnN1bSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgYXJncyA9IGFyZ3VtZW50cyxcclxuICAgICAgc3VtID0gbmV3IEJpZ051bWJlcihhcmdzWzBdKTtcclxuICAgIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7KSBzdW0gPSBzdW0ucGx1cyhhcmdzW2krK10pO1xyXG4gICAgcmV0dXJuIHN1bTtcclxuICB9O1xyXG5cclxuXHJcbiAgLy8gUFJJVkFURSBGVU5DVElPTlNcclxuXHJcblxyXG4gIC8vIENhbGxlZCBieSBCaWdOdW1iZXIgYW5kIEJpZ051bWJlci5wcm90b3R5cGUudG9TdHJpbmcuXHJcbiAgY29udmVydEJhc2UgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGRlY2ltYWwgPSAnMDEyMzQ1Njc4OSc7XHJcblxyXG4gICAgLypcclxuICAgICAqIENvbnZlcnQgc3RyaW5nIG9mIGJhc2VJbiB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGJhc2VPdXQuXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgICAgKiBFZy4gdG9CYXNlT3V0KCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHRvQmFzZU91dChzdHIsIGJhc2VJbiwgYmFzZU91dCwgYWxwaGFiZXQpIHtcclxuICAgICAgdmFyIGosXHJcbiAgICAgICAgYXJyID0gWzBdLFxyXG4gICAgICAgIGFyckwsXHJcbiAgICAgICAgaSA9IDAsXHJcbiAgICAgICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgbGVuOykge1xyXG4gICAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTsgYXJyW2FyckxdICo9IGJhc2VJbik7XHJcblxyXG4gICAgICAgIGFyclswXSArPSBhbHBoYWJldC5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcblxyXG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuXHJcbiAgICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgICAgaWYgKGFycltqICsgMV0gPT0gbnVsbCkgYXJyW2ogKyAxXSA9IDA7XHJcbiAgICAgICAgICAgIGFycltqICsgMV0gKz0gYXJyW2pdIC8gYmFzZU91dCB8IDA7XHJcbiAgICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGFyci5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VJbiB0byBhIG51bWVyaWMgc3RyaW5nIG9mIGJhc2VPdXQuXHJcbiAgICAvLyBJZiB0aGUgY2FsbGVyIGlzIHRvU3RyaW5nLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2UgMTAgdG8gYmFzZU91dC5cclxuICAgIC8vIElmIHRoZSBjYWxsZXIgaXMgQmlnTnVtYmVyLCB3ZSBhcmUgY29udmVydGluZyBmcm9tIGJhc2VJbiB0byBiYXNlIDEwLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdHIsIGJhc2VJbiwgYmFzZU91dCwgc2lnbiwgY2FsbGVySXNUb1N0cmluZykge1xyXG4gICAgICB2YXIgYWxwaGFiZXQsIGQsIGUsIGssIHIsIHgsIHhjLCB5LFxyXG4gICAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpLFxyXG4gICAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMsXHJcbiAgICAgICAgcm0gPSBST1VORElOR19NT0RFO1xyXG5cclxuICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBrID0gUE9XX1BSRUNJU0lPTjtcclxuXHJcbiAgICAgICAgLy8gVW5saW1pdGVkIHByZWNpc2lvbi5cclxuICAgICAgICBQT1dfUFJFQ0lTSU9OID0gMDtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB5ID0gbmV3IEJpZ051bWJlcihiYXNlSW4pO1xyXG4gICAgICAgIHggPSB5LnBvdyhzdHIubGVuZ3RoIC0gaSk7XHJcbiAgICAgICAgUE9XX1BSRUNJU0lPTiA9IGs7XHJcblxyXG4gICAgICAgIC8vIENvbnZlcnQgc3RyIGFzIGlmIGFuIGludGVnZXIsIHRoZW4gcmVzdG9yZSB0aGUgZnJhY3Rpb24gcGFydCBieSBkaXZpZGluZyB0aGVcclxuICAgICAgICAvLyByZXN1bHQgYnkgaXRzIGJhc2UgcmFpc2VkIHRvIGEgcG93ZXIuXHJcblxyXG4gICAgICAgIHkuYyA9IHRvQmFzZU91dCh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyh4LmMpLCB4LmUsICcwJyksXHJcbiAgICAgICAgIDEwLCBiYXNlT3V0LCBkZWNpbWFsKTtcclxuICAgICAgICB5LmUgPSB5LmMubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgaW50ZWdlci5cclxuXHJcbiAgICAgIHhjID0gdG9CYXNlT3V0KHN0ciwgYmFzZUluLCBiYXNlT3V0LCBjYWxsZXJJc1RvU3RyaW5nXHJcbiAgICAgICA/IChhbHBoYWJldCA9IEFMUEhBQkVULCBkZWNpbWFsKVxyXG4gICAgICAgOiAoYWxwaGFiZXQgPSBkZWNpbWFsLCBBTFBIQUJFVCkpO1xyXG5cclxuICAgICAgLy8geGMgbm93IHJlcHJlc2VudHMgc3RyIGFzIGFuIGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBiYXNlT3V0LiBlIGlzIHRoZSBleHBvbmVudC5cclxuICAgICAgZSA9IGsgPSB4Yy5sZW5ndGg7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgIGZvciAoOyB4Y1stLWtdID09IDA7IHhjLnBvcCgpKTtcclxuXHJcbiAgICAgIC8vIFplcm8/XHJcbiAgICAgIGlmICgheGNbMF0pIHJldHVybiBhbHBoYWJldC5jaGFyQXQoMCk7XHJcblxyXG4gICAgICAvLyBEb2VzIHN0ciByZXByZXNlbnQgYW4gaW50ZWdlcj8gSWYgc28sIG5vIG5lZWQgZm9yIHRoZSBkaXZpc2lvbi5cclxuICAgICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgICAgLS1lO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHguYyA9IHhjO1xyXG4gICAgICAgIHguZSA9IGU7XHJcblxyXG4gICAgICAgIC8vIFRoZSBzaWduIGlzIG5lZWRlZCBmb3IgY29ycmVjdCByb3VuZGluZy5cclxuICAgICAgICB4LnMgPSBzaWduO1xyXG4gICAgICAgIHggPSBkaXYoeCwgeSwgZHAsIHJtLCBiYXNlT3V0KTtcclxuICAgICAgICB4YyA9IHguYztcclxuICAgICAgICByID0geC5yO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHhjIG5vdyByZXByZXNlbnRzIHN0ciBjb252ZXJ0ZWQgdG8gYmFzZU91dC5cclxuXHJcbiAgICAgIC8vIFRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGQgPSBlICsgZHAgKyAxO1xyXG5cclxuICAgICAgLy8gVGhlIHJvdW5kaW5nIGRpZ2l0OiB0aGUgZGlnaXQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICBpID0geGNbZF07XHJcblxyXG4gICAgICAvLyBMb29rIGF0IHRoZSByb3VuZGluZyBkaWdpdHMgYW5kIG1vZGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcm91bmQgdXAuXHJcblxyXG4gICAgICBrID0gYmFzZU91dCAvIDI7XHJcbiAgICAgIHIgPSByIHx8IGQgPCAwIHx8IHhjW2QgKyAxXSAhPSBudWxsO1xyXG5cclxuICAgICAgciA9IHJtIDwgNCA/IChpICE9IG51bGwgfHwgcikgJiYgKHJtID09IDAgfHwgcm0gPT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICAgIDogaSA+IGsgfHwgaSA9PSBrICYmKHJtID09IDQgfHwgciB8fCBybSA9PSA2ICYmIHhjW2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBpbmRleCBvZiB0aGUgcm91bmRpbmcgZGlnaXQgaXMgbm90IGdyZWF0ZXIgdGhhbiB6ZXJvLCBvciB4YyByZXByZXNlbnRzXHJcbiAgICAgIC8vIHplcm8sIHRoZW4gdGhlIHJlc3VsdCBvZiB0aGUgYmFzZSBjb252ZXJzaW9uIGlzIHplcm8gb3IsIGlmIHJvdW5kaW5nIHVwLCBhIHZhbHVlXHJcbiAgICAgIC8vIHN1Y2ggYXMgMC4wMDAwMS5cclxuICAgICAgaWYgKGQgPCAxIHx8ICF4Y1swXSkge1xyXG5cclxuICAgICAgICAvLyAxXi1kcCBvciAwXHJcbiAgICAgICAgc3RyID0gciA/IHRvRml4ZWRQb2ludChhbHBoYWJldC5jaGFyQXQoMSksIC1kcCwgYWxwaGFiZXQuY2hhckF0KDApKSA6IGFscGhhYmV0LmNoYXJBdCgwKTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVHJ1bmNhdGUgeGMgdG8gdGhlIHJlcXVpcmVkIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcy5cclxuICAgICAgICB4Yy5sZW5ndGggPSBkO1xyXG5cclxuICAgICAgICAvLyBSb3VuZCB1cD9cclxuICAgICAgICBpZiAocikge1xyXG5cclxuICAgICAgICAgIC8vIFJvdW5kaW5nIHVwIG1heSBtZWFuIHRoZSBwcmV2aW91cyBkaWdpdCBoYXMgdG8gYmUgcm91bmRlZCB1cCBhbmQgc28gb24uXHJcbiAgICAgICAgICBmb3IgKC0tYmFzZU91dDsgKyt4Y1stLWRdID4gYmFzZU91dDspIHtcclxuICAgICAgICAgICAgeGNbZF0gPSAwO1xyXG5cclxuICAgICAgICAgICAgaWYgKCFkKSB7XHJcbiAgICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICAgIHhjID0gWzFdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIERldGVybWluZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgICBmb3IgKGsgPSB4Yy5sZW5ndGg7ICF4Y1stLWtdOyk7XHJcblxyXG4gICAgICAgIC8vIEUuZy4gWzQsIDExLCAxNV0gYmVjb21lcyA0YmYuXHJcbiAgICAgICAgZm9yIChpID0gMCwgc3RyID0gJyc7IGkgPD0gazsgc3RyICs9IGFscGhhYmV0LmNoYXJBdCh4Y1tpKytdKSk7XHJcblxyXG4gICAgICAgIC8vIEFkZCBsZWFkaW5nIHplcm9zLCBkZWNpbWFsIHBvaW50IGFuZCB0cmFpbGluZyB6ZXJvcyBhcyByZXF1aXJlZC5cclxuICAgICAgICBzdHIgPSB0b0ZpeGVkUG9pbnQoc3RyLCBlLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUaGUgY2FsbGVyIHdpbGwgYWRkIHRoZSBzaWduLlxyXG4gICAgICByZXR1cm4gc3RyO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLy8gUGVyZm9ybSBkaXZpc2lvbiBpbiB0aGUgc3BlY2lmaWVkIGJhc2UuIENhbGxlZCBieSBkaXYgYW5kIGNvbnZlcnRCYXNlLlxyXG4gIGRpdiA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgLy8gQXNzdW1lIG5vbi16ZXJvIHggYW5kIGsuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseSh4LCBrLCBiYXNlKSB7XHJcbiAgICAgIHZhciBtLCB0ZW1wLCB4bG8sIHhoaSxcclxuICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgaSA9IHgubGVuZ3RoLFxyXG4gICAgICAgIGtsbyA9IGsgJSBTUVJUX0JBU0UsXHJcbiAgICAgICAga2hpID0gayAvIFNRUlRfQkFTRSB8IDA7XHJcblxyXG4gICAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgICB4bG8gPSB4W2ldICUgU1FSVF9CQVNFO1xyXG4gICAgICAgIHhoaSA9IHhbaV0gLyBTUVJUX0JBU0UgfCAwO1xyXG4gICAgICAgIG0gPSBraGkgKiB4bG8gKyB4aGkgKiBrbG87XHJcbiAgICAgICAgdGVtcCA9IGtsbyAqIHhsbyArICgobSAlIFNRUlRfQkFTRSkgKiBTUVJUX0JBU0UpICsgY2Fycnk7XHJcbiAgICAgICAgY2FycnkgPSAodGVtcCAvIGJhc2UgfCAwKSArIChtIC8gU1FSVF9CQVNFIHwgMCkgKyBraGkgKiB4aGk7XHJcbiAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoY2FycnkpIHggPSBbY2FycnldLmNvbmNhdCh4KTtcclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICAgIHZhciBpLCBjbXA7XHJcblxyXG4gICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICBjbXAgPSBhTCA+IGJMID8gMSA6IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICBmb3IgKGkgPSBjbXAgPSAwOyBpIDwgYUw7IGkrKykge1xyXG5cclxuICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgY21wID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGNtcDtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdChhLCBiLCBhTCwgYmFzZSkge1xyXG4gICAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCBiIGZyb20gYS5cclxuICAgICAgZm9yICg7IGFMLS07KSB7XHJcbiAgICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgICBpID0gYVthTF0gPCBiW2FMXSA/IDEgOiAwO1xyXG4gICAgICAgIGFbYUxdID0gaSAqIGJhc2UgKyBhW2FMXSAtIGJbYUxdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgZm9yICg7ICFhWzBdICYmIGEubGVuZ3RoID4gMTsgYS5zcGxpY2UoMCwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHg6IGRpdmlkZW5kLCB5OiBkaXZpc29yLlxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBkcCwgcm0sIGJhc2UpIHtcclxuICAgICAgdmFyIGNtcCwgZSwgaSwgbW9yZSwgbiwgcHJvZCwgcHJvZEwsIHEsIHFjLCByZW0sIHJlbUwsIHJlbTAsIHhpLCB4TCwgeWMwLFxyXG4gICAgICAgIHlMLCB5eixcclxuICAgICAgICBzID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICB4YyA9IHguYyxcclxuICAgICAgICB5YyA9IHkuYztcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgIGlmICgheGMgfHwgIXhjWzBdIHx8ICF5YyB8fCAheWNbMF0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoXHJcblxyXG4gICAgICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBOYU4sIG9yIGJvdGggSW5maW5pdHkgb3IgMC5cclxuICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4YyA/IHljICYmIHhjWzBdID09IHljWzBdIDogIXljKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIMKxMCBvciB5IGlzIMKxSW5maW5pdHksIG9yIHJldHVybiDCsUluZmluaXR5IGFzIHkgaXMgwrEwLlxyXG4gICAgICAgICAgeGMgJiYgeGNbMF0gPT0gMCB8fCAheWMgPyBzICogMCA6IHMgLyAwXHJcbiAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBxID0gbmV3IEJpZ051bWJlcihzKTtcclxuICAgICAgcWMgPSBxLmMgPSBbXTtcclxuICAgICAgZSA9IHguZSAtIHkuZTtcclxuICAgICAgcyA9IGRwICsgZSArIDE7XHJcblxyXG4gICAgICBpZiAoIWJhc2UpIHtcclxuICAgICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgICBlID0gYml0Rmxvb3IoeC5lIC8gTE9HX0JBU0UpIC0gYml0Rmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgICAgIHMgPSBzIC8gTE9HX0JBU0UgfCAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZXN1bHQgZXhwb25lbnQgbWF5IGJlIG9uZSBsZXNzIHRoZW4gdGhlIGN1cnJlbnQgdmFsdWUgb2YgZS5cclxuICAgICAgLy8gVGhlIGNvZWZmaWNpZW50cyBvZiB0aGUgQmlnTnVtYmVycyBmcm9tIGNvbnZlcnRCYXNlIG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSAwOyB5Y1tpXSA9PSAoeGNbaV0gfHwgMCk7IGkrKyk7XHJcblxyXG4gICAgICBpZiAoeWNbaV0gPiAoeGNbaV0gfHwgMCkpIGUtLTtcclxuXHJcbiAgICAgIGlmIChzIDwgMCkge1xyXG4gICAgICAgIHFjLnB1c2goMSk7XHJcbiAgICAgICAgbW9yZSA9IHRydWU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeEwgPSB4Yy5sZW5ndGg7XHJcbiAgICAgICAgeUwgPSB5Yy5sZW5ndGg7XHJcbiAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgcyArPSAyO1xyXG5cclxuICAgICAgICAvLyBOb3JtYWxpc2UgeGMgYW5kIHljIHNvIGhpZ2hlc3Qgb3JkZXIgZGlnaXQgb2YgeWMgaXMgPj0gYmFzZSAvIDIuXHJcblxyXG4gICAgICAgIG4gPSBtYXRoZmxvb3IoYmFzZSAvICh5Y1swXSArIDEpKTtcclxuXHJcbiAgICAgICAgLy8gTm90IG5lY2Vzc2FyeSwgYnV0IHRvIGhhbmRsZSBvZGQgYmFzZXMgd2hlcmUgeWNbMF0gPT0gKGJhc2UgLyAyKSAtIDEuXHJcbiAgICAgICAgLy8gaWYgKG4gPiAxIHx8IG4rKyA9PSAxICYmIHljWzBdIDwgYmFzZSAvIDIpIHtcclxuICAgICAgICBpZiAobiA+IDEpIHtcclxuICAgICAgICAgIHljID0gbXVsdGlwbHkoeWMsIG4sIGJhc2UpO1xyXG4gICAgICAgICAgeGMgPSBtdWx0aXBseSh4YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICB5TCA9IHljLmxlbmd0aDtcclxuICAgICAgICAgIHhMID0geGMubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICByZW0gPSB4Yy5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDsgcmVtW3JlbUwrK10gPSAwKTtcclxuICAgICAgICB5eiA9IHljLnNsaWNlKCk7XHJcbiAgICAgICAgeXogPSBbMF0uY29uY2F0KHl6KTtcclxuICAgICAgICB5YzAgPSB5Y1swXTtcclxuICAgICAgICBpZiAoeWNbMV0gPj0gYmFzZSAvIDIpIHljMCsrO1xyXG4gICAgICAgIC8vIE5vdCBuZWNlc3NhcnksIGJ1dCB0byBwcmV2ZW50IHRyaWFsIGRpZ2l0IG4gPiBiYXNlLCB3aGVuIHVzaW5nIGJhc2UgMy5cclxuICAgICAgICAvLyBlbHNlIGlmIChiYXNlID09IDMgJiYgeWMwID09IDEpIHljMCA9IDEgKyAxZS0xNTtcclxuXHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgbiA9IDA7XHJcblxyXG4gICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICBjbXAgPSBjb21wYXJlKHljLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgaWYgKGNtcCA8IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0cmlhbCBkaWdpdCwgbi5cclxuXHJcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gbiBpcyBob3cgbWFueSB0aW1lcyB0aGUgZGl2aXNvciBnb2VzIGludG8gdGhlIGN1cnJlbnQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBuID0gbWF0aGZsb29yKHJlbTAgLyB5YzApO1xyXG5cclxuICAgICAgICAgICAgLy8gIEFsZ29yaXRobTpcclxuICAgICAgICAgICAgLy8gIHByb2R1Y3QgPSBkaXZpc29yIG11bHRpcGxpZWQgYnkgdHJpYWwgZGlnaXQgKG4pLlxyXG4gICAgICAgICAgICAvLyAgQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIC8vICBJZiBwcm9kdWN0IGlzIGdyZWF0ZXIgdGhhbiByZW1haW5kZXI6XHJcbiAgICAgICAgICAgIC8vICAgIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LCBkZWNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcbiAgICAgICAgICAgIC8vICBTdWJ0cmFjdCBwcm9kdWN0IGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAvLyAgSWYgcHJvZHVjdCB3YXMgbGVzcyB0aGFuIHJlbWFpbmRlciBhdCB0aGUgbGFzdCBjb21wYXJlOlxyXG4gICAgICAgICAgICAvLyAgICBDb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3IuXHJcbiAgICAgICAgICAgIC8vICAgIElmIHJlbWFpbmRlciBpcyBncmVhdGVyIHRoYW4gZGl2aXNvcjpcclxuICAgICAgICAgICAgLy8gICAgICBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLCBpbmNyZW1lbnQgdHJpYWwgZGlnaXQuXHJcblxyXG4gICAgICAgICAgICBpZiAobiA+IDEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBtYXkgYmUgPiBiYXNlIG9ubHkgd2hlbiBiYXNlIGlzIDMuXHJcbiAgICAgICAgICAgICAgaWYgKG4gPj0gYmFzZSkgbiA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseSh5YywgbiwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBwcm9kdWN0IGFuZCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCA+IHJlbWFpbmRlciB0aGVuIHRyaWFsIGRpZ2l0IG4gdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAxIHRvbyBoaWdoIGFib3V0IDUlIG9mIHRoZSB0aW1lLCBhbmQgaXMgbm90IGtub3duIHRvIGhhdmVcclxuICAgICAgICAgICAgICAvLyBldmVyIGJlZW4gbW9yZSB0aGFuIDEgdG9vIGhpZ2guXHJcbiAgICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCkgPT0gMSkge1xyXG4gICAgICAgICAgICAgICAgbi0tO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocHJvZCwgeUwgPCBwcm9kTCA/IHl6IDogeWMsIHByb2RMLCBiYXNlKTtcclxuICAgICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICBjbXAgPSAxO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gbiBpcyAwIG9yIDEsIGNtcCBpcyAtMS5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDAsIHRoZXJlIGlzIG5vIG5lZWQgdG8gY29tcGFyZSB5YyBhbmQgcmVtIGFnYWluIGJlbG93LFxyXG4gICAgICAgICAgICAgIC8vIHNvIGNoYW5nZSBjbXAgdG8gMSB0byBhdm9pZCBpdC5cclxuICAgICAgICAgICAgICAvLyBJZiBuIGlzIDEsIGxlYXZlIGNtcCBhcyAtMSwgc28geWMgYW5kIHJlbSBhcmUgY29tcGFyZWQgYWdhaW4uXHJcbiAgICAgICAgICAgICAgaWYgKG4gPT0gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIGRpdmlzb3IgPCByZW1haW5kZXIsIHNvIG4gbXVzdCBiZSBhdCBsZWFzdCAxLlxyXG4gICAgICAgICAgICAgICAgY21wID0gbiA9IDE7XHJcbiAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvclxyXG4gICAgICAgICAgICAgIHByb2QgPSB5Yy5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChwcm9kTCA8IHJlbUwpIHByb2QgPSBbMF0uY29uY2F0KHByb2QpO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgPT0gLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIElmIGRpdmlzb3IgPCBuZXcgcmVtYWluZGVyLCBzdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIC8vIFRyaWFsIGRpZ2l0IG4gdG9vIGxvdy5cclxuICAgICAgICAgICAgICAvLyBuIGlzIDEgdG9vIGxvdyBhYm91dCA1JSBvZiB0aGUgdGltZSwgYW5kIHZlcnkgcmFyZWx5IDIgdG9vIGxvdy5cclxuICAgICAgICAgICAgICB3aGlsZSAoY29tcGFyZSh5YywgcmVtLCB5TCwgcmVtTCkgPCAxKSB7XHJcbiAgICAgICAgICAgICAgICBuKys7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICAgIHN1YnRyYWN0KHJlbSwgeUwgPCByZW1MID8geXogOiB5YywgcmVtTCwgYmFzZSk7XHJcbiAgICAgICAgICAgICAgICByZW1MID0gcmVtLmxlbmd0aDtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgIG4rKztcclxuICAgICAgICAgICAgcmVtID0gWzBdO1xyXG4gICAgICAgICAgfSAvLyBlbHNlIGNtcCA9PT0gMSBhbmQgbiB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIG4sIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICBxY1tpKytdID0gbjtcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChyZW1bMF0pIHtcclxuICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4Y1t4aV0gfHwgMDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlbSA9IFt4Y1t4aV1dO1xyXG4gICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IHdoaWxlICgoeGkrKyA8IHhMIHx8IHJlbVswXSAhPSBudWxsKSAmJiBzLS0pO1xyXG5cclxuICAgICAgICBtb3JlID0gcmVtWzBdICE9IG51bGw7XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFjWzBdKSBxYy5zcGxpY2UoMCwgMSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChiYXNlID09IEJBU0UpIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFjWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIHMgPSBxY1swXTsgcyA+PSAxMDsgcyAvPSAxMCwgaSsrKTtcclxuXHJcbiAgICAgICAgcm91bmQocSwgZHAgKyAocS5lID0gaSArIGUgKiBMT0dfQkFTRSAtIDEpICsgMSwgcm0sIG1vcmUpO1xyXG5cclxuICAgICAgLy8gQ2FsbGVyIGlzIGNvbnZlcnRCYXNlLlxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHEuZSA9IGU7XHJcbiAgICAgICAgcS5yID0gK21vcmU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBxO1xyXG4gICAgfTtcclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIgbiBpbiBmaXhlZC1wb2ludCBvciBleHBvbmVudGlhbFxyXG4gICAqIG5vdGF0aW9uIHJvdW5kZWQgdG8gdGhlIHNwZWNpZmllZCBkZWNpbWFsIHBsYWNlcyBvciBzaWduaWZpY2FudCBkaWdpdHMuXHJcbiAgICpcclxuICAgKiBuOiBhIEJpZ051bWJlci5cclxuICAgKiBpOiB0aGUgaW5kZXggb2YgdGhlIGxhc3QgZGlnaXQgcmVxdWlyZWQgKGkuZS4gdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXApLlxyXG4gICAqIHJtOiB0aGUgcm91bmRpbmcgbW9kZS5cclxuICAgKiBpZDogMSAodG9FeHBvbmVudGlhbCkgb3IgMiAodG9QcmVjaXNpb24pLlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGZvcm1hdChuLCBpLCBybSwgaWQpIHtcclxuICAgIHZhciBjMCwgZSwgbmUsIGxlbiwgc3RyO1xyXG5cclxuICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICBlbHNlIGludENoZWNrKHJtLCAwLCA4KTtcclxuXHJcbiAgICBpZiAoIW4uYykgcmV0dXJuIG4udG9TdHJpbmcoKTtcclxuXHJcbiAgICBjMCA9IG4uY1swXTtcclxuICAgIG5lID0gbi5lO1xyXG5cclxuICAgIGlmIChpID09IG51bGwpIHtcclxuICAgICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG4gICAgICBzdHIgPSBpZCA9PSAxIHx8IGlkID09IDIgJiYgKG5lIDw9IFRPX0VYUF9ORUcgfHwgbmUgPj0gVE9fRVhQX1BPUylcclxuICAgICAgID8gdG9FeHBvbmVudGlhbChzdHIsIG5lKVxyXG4gICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBuZSwgJzAnKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSByb3VuZChuZXcgQmlnTnVtYmVyKG4pLCBpLCBybSk7XHJcblxyXG4gICAgICAvLyBuLmUgbWF5IGhhdmUgY2hhbmdlZCBpZiB0aGUgdmFsdWUgd2FzIHJvdW5kZWQgdXAuXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgICBzdHIgPSBjb2VmZlRvU3RyaW5nKG4uYyk7XHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgICAvLyB0b1ByZWNpc2lvbiByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICAgIC8vIHNwZWNpZmllZCBpcyBsZXNzIHRoYW4gdGhlIG51bWJlciBvZiBkaWdpdHMgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgaW50ZWdlclxyXG4gICAgICAvLyBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBmaXhlZC1wb2ludCBub3RhdGlvbi5cclxuXHJcbiAgICAgIC8vIEV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICBpZiAoaWQgPT0gMSB8fCBpZCA9PSAyICYmIChpIDw9IGUgfHwgZSA8PSBUT19FWFBfTkVHKSkge1xyXG5cclxuICAgICAgICAvLyBBcHBlbmQgemVyb3M/XHJcbiAgICAgICAgZm9yICg7IGxlbiA8IGk7IHN0ciArPSAnMCcsIGxlbisrKTtcclxuICAgICAgICBzdHIgPSB0b0V4cG9uZW50aWFsKHN0ciwgZSk7XHJcblxyXG4gICAgICAvLyBGaXhlZC1wb2ludCBub3RhdGlvbi5cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpIC09IG5lICsgKGlkID09PSAyICYmIGUgPiBuZSk7XHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KHN0ciwgZSwgJzAnKTtcclxuXHJcbiAgICAgICAgLy8gQXBwZW5kIHplcm9zP1xyXG4gICAgICAgIGlmIChlICsgMSA+IGxlbikge1xyXG4gICAgICAgICAgaWYgKC0taSA+IDApIGZvciAoc3RyICs9ICcuJzsgaS0tOyBzdHIgKz0gJzAnKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaSArPSBlIC0gbGVuO1xyXG4gICAgICAgICAgaWYgKGkgPiAwKSB7XHJcbiAgICAgICAgICAgIGlmIChlICsgMSA9PSBsZW4pIHN0ciArPSAnLic7XHJcbiAgICAgICAgICAgIGZvciAoOyBpLS07IHN0ciArPSAnMCcpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuLnMgPCAwICYmIGMwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSBCaWdOdW1iZXIubWF4IGFuZCBCaWdOdW1iZXIubWluLlxyXG4gIC8vIElmIGFueSBudW1iZXIgaXMgTmFOLCByZXR1cm4gTmFOLlxyXG4gIGZ1bmN0aW9uIG1heE9yTWluKGFyZ3MsIG4pIHtcclxuICAgIHZhciBrLCB5LFxyXG4gICAgICBpID0gMSxcclxuICAgICAgeCA9IG5ldyBCaWdOdW1iZXIoYXJnc1swXSk7XHJcblxyXG4gICAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIHkgPSBuZXcgQmlnTnVtYmVyKGFyZ3NbaV0pO1xyXG4gICAgICBpZiAoIXkucyB8fCAoayA9IGNvbXBhcmUoeCwgeSkpID09PSBuIHx8IGsgPT09IDAgJiYgeC5zID09PSBuKSB7XHJcbiAgICAgICAgeCA9IHk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFN0cmlwIHRyYWlsaW5nIHplcm9zLCBjYWxjdWxhdGUgYmFzZSAxMCBleHBvbmVudCBhbmQgY2hlY2sgYWdhaW5zdCBNSU5fRVhQIGFuZCBNQVhfRVhQLlxyXG4gICAqIENhbGxlZCBieSBtaW51cywgcGx1cyBhbmQgdGltZXMuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXNlKG4sIGMsIGUpIHtcclxuICAgIHZhciBpID0gMSxcclxuICAgICAgaiA9IGMubGVuZ3RoO1xyXG5cclxuICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIWNbLS1qXTsgYy5wb3AoKSk7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50LiBGaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgY1swXS5cclxuICAgIGZvciAoaiA9IGNbMF07IGogPj0gMTA7IGogLz0gMTAsIGkrKyk7XHJcblxyXG4gICAgLy8gT3ZlcmZsb3c/XHJcbiAgICBpZiAoKGUgPSBpICsgZSAqIExPR19CQVNFIC0gMSkgPiBNQVhfRVhQKSB7XHJcblxyXG4gICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgbi5jID0gbi5lID0gbnVsbDtcclxuXHJcbiAgICAvLyBVbmRlcmZsb3c/XHJcbiAgICB9IGVsc2UgaWYgKGUgPCBNSU5fRVhQKSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICBuLmMgPSBbbi5lID0gMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuLmUgPSBlO1xyXG4gICAgICBuLmMgPSBjO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIEhhbmRsZSB2YWx1ZXMgdGhhdCBmYWlsIHRoZSB2YWxpZGl0eSB0ZXN0IGluIEJpZ051bWJlci5cclxuICBwYXJzZU51bWVyaWMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pLFxyXG4gICAgICBkb3RBZnRlciA9IC9eKFteLl0rKVxcLiQvLFxyXG4gICAgICBkb3RCZWZvcmUgPSAvXlxcLihbXi5dKykkLyxcclxuICAgICAgaXNJbmZpbml0eU9yTmFOID0gL14tPyhJbmZpbml0eXxOYU4pJC8sXHJcbiAgICAgIHdoaXRlc3BhY2VPclBsdXMgPSAvXlxccypcXCsoPz1bXFx3Ll0pfF5cXHMrfFxccyskL2c7XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBzdHIsIGlzTnVtLCBiKSB7XHJcbiAgICAgIHZhciBiYXNlLFxyXG4gICAgICAgIHMgPSBpc051bSA/IHN0ciA6IHN0ci5yZXBsYWNlKHdoaXRlc3BhY2VPclBsdXMsICcnKTtcclxuXHJcbiAgICAgIC8vIE5vIGV4Y2VwdGlvbiBvbiDCsUluZmluaXR5IG9yIE5hTi5cclxuICAgICAgaWYgKGlzSW5maW5pdHlPck5hTi50ZXN0KHMpKSB7XHJcbiAgICAgICAgeC5zID0gaXNOYU4ocykgPyBudWxsIDogcyA8IDAgPyAtMSA6IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKCFpc051bSkge1xyXG5cclxuICAgICAgICAgIC8vIGJhc2VQcmVmaXggPSAvXigtPykwKFt4Ym9dKSg/PVxcd1tcXHcuXSokKS9pXHJcbiAgICAgICAgICBzID0gcy5yZXBsYWNlKGJhc2VQcmVmaXgsIGZ1bmN0aW9uIChtLCBwMSwgcDIpIHtcclxuICAgICAgICAgICAgYmFzZSA9IChwMiA9IHAyLnRvTG93ZXJDYXNlKCkpID09ICd4JyA/IDE2IDogcDIgPT0gJ2InID8gMiA6IDg7XHJcbiAgICAgICAgICAgIHJldHVybiAhYiB8fCBiID09IGJhc2UgPyBwMSA6IG07XHJcbiAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICBpZiAoYikge1xyXG4gICAgICAgICAgICBiYXNlID0gYjtcclxuXHJcbiAgICAgICAgICAgIC8vIEUuZy4gJzEuJyB0byAnMScsICcuMScgdG8gJzAuMSdcclxuICAgICAgICAgICAgcyA9IHMucmVwbGFjZShkb3RBZnRlciwgJyQxJykucmVwbGFjZShkb3RCZWZvcmUsICcwLiQxJyk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHN0ciAhPSBzKSByZXR1cm4gbmV3IEJpZ051bWJlcihzLCBiYXNlKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vICdbQmlnTnVtYmVyIEVycm9yXSBOb3QgYSBudW1iZXI6IHtufSdcclxuICAgICAgICAvLyAnW0JpZ051bWJlciBFcnJvcl0gTm90IGEgYmFzZSB7Yn0gbnVtYmVyOiB7bn0nXHJcbiAgICAgICAgaWYgKEJpZ051bWJlci5ERUJVRykge1xyXG4gICAgICAgICAgdGhyb3cgRXJyb3JcclxuICAgICAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ05vdCBhJyArIChiID8gJyBiYXNlICcgKyBiIDogJycpICsgJyBudW1iZXI6ICcgKyBzdHIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gTmFOXHJcbiAgICAgICAgeC5zID0gbnVsbDtcclxuICAgICAgfVxyXG5cclxuICAgICAgeC5jID0geC5lID0gbnVsbDtcclxuICAgIH1cclxuICB9KSgpO1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSb3VuZCB4IHRvIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLiBDaGVjayBmb3Igb3Zlci91bmRlci1mbG93LlxyXG4gICAqIElmIHIgaXMgdHJ1dGh5LCBpdCBpcyBrbm93biB0aGF0IHRoZXJlIGFyZSBtb3JlIGRpZ2l0cyBhZnRlciB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcm91bmQoeCwgc2QsIHJtLCByKSB7XHJcbiAgICB2YXIgZCwgaSwgaiwgaywgbiwgbmksIHJkLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgcG93czEwID0gUE9XU19URU47XHJcblxyXG4gICAgLy8gaWYgeCBpcyBub3QgSW5maW5pdHkgb3IgTmFOLi4uXHJcbiAgICBpZiAoeGMpIHtcclxuXHJcbiAgICAgIC8vIHJkIGlzIHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIC8vIG4gaXMgYSBiYXNlIDFlMTQgbnVtYmVyLCB0aGUgdmFsdWUgb2YgdGhlIGVsZW1lbnQgb2YgYXJyYXkgeC5jIGNvbnRhaW5pbmcgcmQuXHJcbiAgICAgIC8vIG5pIGlzIHRoZSBpbmRleCBvZiBuIHdpdGhpbiB4LmMuXHJcbiAgICAgIC8vIGQgaXMgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgLy8gaSBpcyB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4gaW5jbHVkaW5nIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgIC8vIGogaXMgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gbiAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcbiAgICAgIG91dDoge1xyXG5cclxuICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IGVsZW1lbnQgb2YgeGMuXHJcbiAgICAgICAgZm9yIChkID0gMSwgayA9IHhjWzBdOyBrID49IDEwOyBrIC89IDEwLCBkKyspO1xyXG4gICAgICAgIGkgPSBzZCAtIGQ7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdCBpcyBpbiB0aGUgZmlyc3QgZWxlbWVudCBvZiB4Yy4uLlxyXG4gICAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgICAgIGogPSBzZDtcclxuICAgICAgICAgIG4gPSB4Y1tuaSA9IDBdO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgcmQgPSBtYXRoZmxvb3IobiAvIHBvd3MxMFtkIC0gaiAtIDFdICUgMTApO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBuaSA9IG1hdGhjZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcblxyXG4gICAgICAgICAgaWYgKG5pID49IHhjLmxlbmd0aCkge1xyXG5cclxuICAgICAgICAgICAgaWYgKHIpIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gTmVlZGVkIGJ5IHNxcnQuXHJcbiAgICAgICAgICAgICAgZm9yICg7IHhjLmxlbmd0aCA8PSBuaTsgeGMucHVzaCgwKSk7XHJcbiAgICAgICAgICAgICAgbiA9IHJkID0gMDtcclxuICAgICAgICAgICAgICBkID0gMTtcclxuICAgICAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG4gICAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGJyZWFrIG91dDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgbiA9IGsgPSB4Y1tuaV07XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2Ygbi5cclxuICAgICAgICAgICAgZm9yIChkID0gMTsgayA+PSAxMDsgayAvPSAxMCwgZCsrKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIG4uXHJcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgICAgICAgICAvLyBHZXQgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiBuLCBhZGp1c3RlZCBmb3IgbGVhZGluZyB6ZXJvcy5cclxuICAgICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4gaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkLlxyXG4gICAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZDtcclxuXHJcbiAgICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiBuLlxyXG4gICAgICAgICAgICByZCA9IGogPCAwID8gMCA6IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqIC0gMV0gJSAxMCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByID0gciB8fCBzZCA8IDAgfHxcclxuXHJcbiAgICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICAgIC8vIFRoZSBleHByZXNzaW9uICBuICUgcG93czEwW2QgLSBqIC0gMV0gIHJldHVybnMgYWxsIGRpZ2l0cyBvZiBuIHRvIHRoZSByaWdodFxyXG4gICAgICAgIC8vIG9mIHRoZSBkaWdpdCBhdCBqLCBlLmcuIGlmIG4gaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uIGdpdmVzIDcxNC5cclxuICAgICAgICAgeGNbbmkgKyAxXSAhPSBudWxsIHx8IChqIDwgMCA/IG4gOiBuICUgcG93czEwW2QgLSBqIC0gMV0pO1xyXG5cclxuICAgICAgICByID0gcm0gPCA0XHJcbiAgICAgICAgID8gKHJkIHx8IHIpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgICA6IHJkID4gNSB8fCByZCA9PSA1ICYmIChybSA9PSA0IHx8IHIgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyBuIC8gcG93czEwW2QgLSBqXSA6IDAgOiB4Y1tuaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICAgIGlmIChzZCA8IDEgfHwgIXhjWzBdKSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICBzZCAtPSB4LmUgKyAxO1xyXG5cclxuICAgICAgICAgICAgLy8gMSwgMC4xLCAwLjAxLCAwLjAwMSwgMC4wMDAxIGV0Yy5cclxuICAgICAgICAgICAgeGNbMF0gPSBwb3dzMTBbKExPR19CQVNFIC0gc2QgJSBMT0dfQkFTRSkgJSBMT0dfQkFTRV07XHJcbiAgICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgIHhjWzBdID0geC5lID0gMDtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4geDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgICAgIGlmIChpID09IDApIHtcclxuICAgICAgICAgIHhjLmxlbmd0aCA9IG5pO1xyXG4gICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgICBuaS0tO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB4Yy5sZW5ndGggPSBuaSArIDE7XHJcbiAgICAgICAgICBrID0gcG93czEwW0xPR19CQVNFIC0gaV07XHJcblxyXG4gICAgICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIG4uXHJcbiAgICAgICAgICB4Y1tuaV0gPSBqID4gMCA/IG1hdGhmbG9vcihuIC8gcG93czEwW2QgLSBqXSAlIHBvd3MxMFtqXSkgKiBrIDogMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJvdW5kIHVwP1xyXG4gICAgICAgIGlmIChyKSB7XHJcblxyXG4gICAgICAgICAgZm9yICg7IDspIHtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGlzIGluIHRoZSBmaXJzdCBlbGVtZW50IG9mIHhjLi4uXHJcbiAgICAgICAgICAgIGlmIChuaSA9PSAwKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhjWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICAgIGZvciAoaSA9IDEsIGogPSB4Y1swXTsgaiA+PSAxMDsgaiAvPSAxMCwgaSsrKTtcclxuICAgICAgICAgICAgICBqID0geGNbMF0gKz0gaztcclxuICAgICAgICAgICAgICBmb3IgKGsgPSAxOyBqID49IDEwOyBqIC89IDEwLCBrKyspO1xyXG5cclxuICAgICAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICAgIHguZSsrO1xyXG4gICAgICAgICAgICAgICAgaWYgKHhjWzBdID09IEJBU0UpIHhjWzBdID0gMTtcclxuICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHhjW25pXSArPSBrO1xyXG4gICAgICAgICAgICAgIGlmICh4Y1tuaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgICAgeGNbbmktLV0gPSAwO1xyXG4gICAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAgICAgZm9yIChpID0geGMubGVuZ3RoOyB4Y1stLWldID09PSAwOyB4Yy5wb3AoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIE92ZXJmbG93PyBJbmZpbml0eS5cclxuICAgICAgaWYgKHguZSA+IE1BWF9FWFApIHtcclxuICAgICAgICB4LmMgPSB4LmUgPSBudWxsO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93PyBaZXJvLlxyXG4gICAgICB9IGVsc2UgaWYgKHguZSA8IE1JTl9FWFApIHtcclxuICAgICAgICB4LmMgPSBbeC5lID0gMF07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiB2YWx1ZU9mKG4pIHtcclxuICAgIHZhciBzdHIsXHJcbiAgICAgIGUgPSBuLmU7XHJcblxyXG4gICAgaWYgKGUgPT09IG51bGwpIHJldHVybiBuLnRvU3RyaW5nKCk7XHJcblxyXG4gICAgc3RyID0gY29lZmZUb1N0cmluZyhuLmMpO1xyXG5cclxuICAgIHN0ciA9IGUgPD0gVE9fRVhQX05FRyB8fCBlID49IFRPX0VYUF9QT1NcclxuICAgICAgPyB0b0V4cG9uZW50aWFsKHN0ciwgZSlcclxuICAgICAgOiB0b0ZpeGVkUG9pbnQoc3RyLCBlLCAnMCcpO1xyXG5cclxuICAgIHJldHVybiBuLnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIFBST1RPVFlQRS9JTlNUQU5DRSBNRVRIT0RTXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyLlxyXG4gICAqL1xyXG4gIFAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSBuZXcgQmlnTnVtYmVyKHRoaXMpO1xyXG4gICAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5cclxuICAgKiAgIDEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgLTEgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqICAgMCBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgdmFsdWUsXHJcbiAgICogICBvciBudWxsIGlmIHRoZSB2YWx1ZSBvZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAqL1xyXG4gIFAuY29tcGFyZWRUbyA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gY29tcGFyZSh0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBJZiBkcCBpcyB1bmRlZmluZWQgb3IgbnVsbCBvciB0cnVlIG9yIGZhbHNlLCByZXR1cm4gdGhlIG51bWJlciBvZiBkZWNpbWFsIHBsYWNlcyBvZiB0aGVcclxuICAgKiB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICpcclxuICAgKiBPdGhlcndpc2UsIGlmIGRwIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGRwIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yXHJcbiAgICogUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlczogaW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgYywgbiwgdixcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGlmIChybSA9PSBudWxsKSBybSA9IFJPVU5ESU5HX01PREU7XHJcbiAgICAgIGVsc2UgaW50Q2hlY2socm0sIDAsIDgpO1xyXG5cclxuICAgICAgcmV0dXJuIHJvdW5kKG5ldyBCaWdOdW1iZXIoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKGMgPSB4LmMpKSByZXR1cm4gbnVsbDtcclxuICAgIG4gPSAoKHYgPSBjLmxlbmd0aCAtIDEpIC0gYml0Rmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3QgbnVtYmVyLlxyXG4gICAgaWYgKHYgPSBjW3ZdKSBmb3IgKDsgdiAlIDEwID09IDA7IHYgLz0gMTAsIG4tLSk7XHJcbiAgICBpZiAobiA8IDApIG4gPSAwO1xyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC8gMCA9IElcclxuICAgKiAgbiAvIE4gPSBOXHJcbiAgICogIG4gLyBJID0gMFxyXG4gICAqICAwIC8gbiA9IDBcclxuICAgKiAgMCAvIDAgPSBOXHJcbiAgICogIDAgLyBOID0gTlxyXG4gICAqICAwIC8gSSA9IDBcclxuICAgKiAgTiAvIG4gPSBOXHJcbiAgICogIE4gLyAwID0gTlxyXG4gICAqICBOIC8gTiA9IE5cclxuICAgKiAgTiAvIEkgPSBOXHJcbiAgICogIEkgLyBuID0gSVxyXG4gICAqICBJIC8gMCA9IElcclxuICAgKiAgSSAvIE4gPSBOXHJcbiAgICogIEkgLyBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgZGl2aWRlZCBieSB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYiksIHJvdW5kZWQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZCBST1VORElOR19NT0RFLlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCBERUNJTUFMX1BMQUNFUywgUk9VTkRJTkdfTU9ERSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgaW50ZWdlciBwYXJ0IG9mIGRpdmlkaW5nIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIGJ5IHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5kaXZpZGVkVG9JbnRlZ2VyQnkgPSBQLmlkaXYgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgcmV0dXJuIGRpdih0aGlzLCBuZXcgQmlnTnVtYmVyKHksIGIpLCAwLCAxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGV4cG9uZW50aWF0ZWQgYnkgbi5cclxuICAgKlxyXG4gICAqIElmIG0gaXMgcHJlc2VudCwgcmV0dXJuIHRoZSByZXN1bHQgbW9kdWxvIG0uXHJcbiAgICogSWYgbiBpcyBuZWdhdGl2ZSByb3VuZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICogSWYgUE9XX1BSRUNJU0lPTiBpcyBub24temVybyBhbmQgbSBpcyBub3QgcHJlc2VudCwgcm91bmQgdG8gUE9XX1BSRUNJU0lPTiB1c2luZyBST1VORElOR19NT0RFLlxyXG4gICAqXHJcbiAgICogVGhlIG1vZHVsYXIgcG93ZXIgb3BlcmF0aW9uIHdvcmtzIGVmZmljaWVudGx5IHdoZW4geCwgbiwgYW5kIG0gYXJlIGludGVnZXJzLCBvdGhlcndpc2UgaXRcclxuICAgKiBpcyBlcXVpdmFsZW50IHRvIGNhbGN1bGF0aW5nIHguZXhwb25lbnRpYXRlZEJ5KG4pLm1vZHVsbyhtKSB3aXRoIGEgUE9XX1BSRUNJU0lPTiBvZiAwLlxyXG4gICAqXHJcbiAgICogbiB7bnVtYmVyfHN0cmluZ3xCaWdOdW1iZXJ9IFRoZSBleHBvbmVudC4gQW4gaW50ZWdlci5cclxuICAgKiBbbV0ge251bWJlcnxzdHJpbmd8QmlnTnVtYmVyfSBUaGUgbW9kdWx1cy5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBFeHBvbmVudCBub3QgYW4gaW50ZWdlcjoge259J1xyXG4gICAqL1xyXG4gIFAuZXhwb25lbnRpYXRlZEJ5ID0gUC5wb3cgPSBmdW5jdGlvbiAobiwgbSkge1xyXG4gICAgdmFyIGhhbGYsIGlzTW9kRXhwLCBpLCBrLCBtb3JlLCBuSXNCaWcsIG5Jc05lZywgbklzT2RkLCB5LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBuID0gbmV3IEJpZ051bWJlcihuKTtcclxuXHJcbiAgICAvLyBBbGxvdyBOYU4gYW5kIMKxSW5maW5pdHksIGJ1dCBub3Qgb3RoZXIgbm9uLWludGVnZXJzLlxyXG4gICAgaWYgKG4uYyAmJiAhbi5pc0ludGVnZXIoKSkge1xyXG4gICAgICB0aHJvdyBFcnJvclxyXG4gICAgICAgIChiaWdudW1iZXJFcnJvciArICdFeHBvbmVudCBub3QgYW4gaW50ZWdlcjogJyArIHZhbHVlT2YobikpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtICE9IG51bGwpIG0gPSBuZXcgQmlnTnVtYmVyKG0pO1xyXG5cclxuICAgIC8vIEV4cG9uZW50IG9mIE1BWF9TQUZFX0lOVEVHRVIgaXMgMTUuXHJcbiAgICBuSXNCaWcgPSBuLmUgPiAxNDtcclxuXHJcbiAgICAvLyBJZiB4IGlzIE5hTiwgwrFJbmZpbml0eSwgwrEwIG9yIMKxMSwgb3IgbiBpcyDCsUluZmluaXR5LCBOYU4gb3IgwrEwLlxyXG4gICAgaWYgKCF4LmMgfHwgIXguY1swXSB8fCB4LmNbMF0gPT0gMSAmJiAheC5lICYmIHguYy5sZW5ndGggPT0gMSB8fCAhbi5jIHx8ICFuLmNbMF0pIHtcclxuXHJcbiAgICAgIC8vIFRoZSBzaWduIG9mIHRoZSByZXN1bHQgb2YgcG93IHdoZW4geCBpcyBuZWdhdGl2ZSBkZXBlbmRzIG9uIHRoZSBldmVubmVzcyBvZiBuLlxyXG4gICAgICAvLyBJZiArbiBvdmVyZmxvd3MgdG8gwrFJbmZpbml0eSwgdGhlIGV2ZW5uZXNzIG9mIG4gd291bGQgYmUgbm90IGJlIGtub3duLlxyXG4gICAgICB5ID0gbmV3IEJpZ051bWJlcihNYXRoLnBvdygrdmFsdWVPZih4KSwgbklzQmlnID8gbi5zICogKDIgLSBpc09kZChuKSkgOiArdmFsdWVPZihuKSkpO1xyXG4gICAgICByZXR1cm4gbSA/IHkubW9kKG0pIDogeTtcclxuICAgIH1cclxuXHJcbiAgICBuSXNOZWcgPSBuLnMgPCAwO1xyXG5cclxuICAgIGlmIChtKSB7XHJcblxyXG4gICAgICAvLyB4ICUgbSByZXR1cm5zIE5hTiBpZiBhYnMobSkgaXMgemVybywgb3IgbSBpcyBOYU4uXHJcbiAgICAgIGlmIChtLmMgPyAhbS5jWzBdIDogIW0ucykgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAgIGlzTW9kRXhwID0gIW5Jc05lZyAmJiB4LmlzSW50ZWdlcigpICYmIG0uaXNJbnRlZ2VyKCk7XHJcblxyXG4gICAgICBpZiAoaXNNb2RFeHApIHggPSB4Lm1vZChtKTtcclxuXHJcbiAgICAvLyBPdmVyZmxvdyB0byDCsUluZmluaXR5OiA+PTIqKjFlMTAgb3IgPj0xLjAwMDAwMjQqKjFlMTUuXHJcbiAgICAvLyBVbmRlcmZsb3cgdG8gwrEwOiA8PTAuNzkqKjFlMTAgb3IgPD0wLjk5OTk5NzUqKjFlMTUuXHJcbiAgICB9IGVsc2UgaWYgKG4uZSA+IDkgJiYgKHguZSA+IDAgfHwgeC5lIDwgLTEgfHwgKHguZSA9PSAwXHJcbiAgICAgIC8vIFsxLCAyNDAwMDAwMDBdXHJcbiAgICAgID8geC5jWzBdID4gMSB8fCBuSXNCaWcgJiYgeC5jWzFdID49IDI0ZTdcclxuICAgICAgLy8gWzgwMDAwMDAwMDAwMDAwXSAgWzk5OTk5NzUwMDAwMDAwXVxyXG4gICAgICA6IHguY1swXSA8IDhlMTMgfHwgbklzQmlnICYmIHguY1swXSA8PSA5OTk5OTc1ZTcpKSkge1xyXG5cclxuICAgICAgLy8gSWYgeCBpcyBuZWdhdGl2ZSBhbmQgbiBpcyBvZGQsIGsgPSAtMCwgZWxzZSBrID0gMC5cclxuICAgICAgayA9IHgucyA8IDAgJiYgaXNPZGQobikgPyAtMCA6IDA7XHJcblxyXG4gICAgICAvLyBJZiB4ID49IDEsIGsgPSDCsUluZmluaXR5LlxyXG4gICAgICBpZiAoeC5lID4gLTEpIGsgPSAxIC8gaztcclxuXHJcbiAgICAgIC8vIElmIG4gaXMgbmVnYXRpdmUgcmV0dXJuIMKxMCwgZWxzZSByZXR1cm4gwrFJbmZpbml0eS5cclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIobklzTmVnID8gMSAvIGsgOiBrKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKFBPV19QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgIC8vIFRydW5jYXRpbmcgZWFjaCBjb2VmZmljaWVudCBhcnJheSB0byBhIGxlbmd0aCBvZiBrIGFmdGVyIGVhY2ggbXVsdGlwbGljYXRpb25cclxuICAgICAgLy8gZXF1YXRlcyB0byB0cnVuY2F0aW5nIHNpZ25pZmljYW50IGRpZ2l0cyB0byBQT1dfUFJFQ0lTSU9OICsgWzI4LCA0MV0sXHJcbiAgICAgIC8vIGkuZS4gdGhlcmUgd2lsbCBiZSBhIG1pbmltdW0gb2YgMjggZ3VhcmQgZGlnaXRzIHJldGFpbmVkLlxyXG4gICAgICBrID0gbWF0aGNlaWwoUE9XX1BSRUNJU0lPTiAvIExPR19CQVNFICsgMik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG5Jc0JpZykge1xyXG4gICAgICBoYWxmID0gbmV3IEJpZ051bWJlcigwLjUpO1xyXG4gICAgICBpZiAobklzTmVnKSBuLnMgPSAxO1xyXG4gICAgICBuSXNPZGQgPSBpc09kZChuKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgPSBNYXRoLmFicygrdmFsdWVPZihuKSk7XHJcbiAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgfVxyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcblxyXG4gICAgLy8gUGVyZm9ybXMgNTQgbG9vcCBpdGVyYXRpb25zIGZvciBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEuXHJcbiAgICBmb3IgKDsgOykge1xyXG5cclxuICAgICAgaWYgKG5Jc09kZCkge1xyXG4gICAgICAgIHkgPSB5LnRpbWVzKHgpO1xyXG4gICAgICAgIGlmICgheS5jKSBicmVhaztcclxuXHJcbiAgICAgICAgaWYgKGspIHtcclxuICAgICAgICAgIGlmICh5LmMubGVuZ3RoID4gaykgeS5jLmxlbmd0aCA9IGs7XHJcbiAgICAgICAgfSBlbHNlIGlmIChpc01vZEV4cCkge1xyXG4gICAgICAgICAgeSA9IHkubW9kKG0pOyAgICAvL3kgPSB5Lm1pbnVzKGRpdih5LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGkpIHtcclxuICAgICAgICBpID0gbWF0aGZsb29yKGkgLyAyKTtcclxuICAgICAgICBpZiAoaSA9PT0gMCkgYnJlYWs7XHJcbiAgICAgICAgbklzT2RkID0gaSAlIDI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IG4udGltZXMoaGFsZik7XHJcbiAgICAgICAgcm91bmQobiwgbi5lICsgMSwgMSk7XHJcblxyXG4gICAgICAgIGlmIChuLmUgPiAxNCkge1xyXG4gICAgICAgICAgbklzT2RkID0gaXNPZGQobik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGkgPSArdmFsdWVPZihuKTtcclxuICAgICAgICAgIGlmIChpID09PSAwKSBicmVhaztcclxuICAgICAgICAgIG5Jc09kZCA9IGkgJSAyO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgeCA9IHgudGltZXMoeCk7XHJcblxyXG4gICAgICBpZiAoaykge1xyXG4gICAgICAgIGlmICh4LmMgJiYgeC5jLmxlbmd0aCA+IGspIHguYy5sZW5ndGggPSBrO1xyXG4gICAgICB9IGVsc2UgaWYgKGlzTW9kRXhwKSB7XHJcbiAgICAgICAgeCA9IHgubW9kKG0pOyAgICAvL3ggPSB4Lm1pbnVzKGRpdih4LCBtLCAwLCBNT0RVTE9fTU9ERSkudGltZXMobSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGlzTW9kRXhwKSByZXR1cm4geTtcclxuICAgIGlmIChuSXNOZWcpIHkgPSBPTkUuZGl2KHkpO1xyXG5cclxuICAgIHJldHVybiBtID8geS5tb2QobSkgOiBrID8gcm91bmQoeSwgUE9XX1BSRUNJU0lPTiwgUk9VTkRJTkdfTU9ERSwgbW9yZSkgOiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHJvdW5kZWQgdG8gYW4gaW50ZWdlclxyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgcm0sIG9yIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7cm19J1xyXG4gICAqL1xyXG4gIFAuaW50ZWdlclZhbHVlID0gZnVuY3Rpb24gKHJtKSB7XHJcbiAgICB2YXIgbiA9IG5ldyBCaWdOdW1iZXIodGhpcyk7XHJcbiAgICBpZiAocm0gPT0gbnVsbCkgcm0gPSBST1VORElOR19NT0RFO1xyXG4gICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcbiAgICByZXR1cm4gcm91bmQobiwgbi5lICsgMSwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgQmlnTnVtYmVyKHksIGIpLFxyXG4gICAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0VxdWFsVG8gPSBQLmVxID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzR3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpID4gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzR3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gMSB8fCBiID09PSAwO1xyXG5cclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzSW50ZWdlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuYyAmJiBiaXRGbG9vcih0aGlzLmUgLyBMT0dfQkFTRSkgPiB0aGlzLmMubGVuZ3RoIC0gMjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBCaWdOdW1iZXIoeSwgYiksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTGVzc1RoYW4gPSBQLmx0ID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHJldHVybiBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZlxyXG4gICAqIEJpZ051bWJlcih5LCBiKSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKi9cclxuICBQLmlzTGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICByZXR1cm4gKGIgPSBjb21wYXJlKHRoaXMsIG5ldyBCaWdOdW1iZXIoeSwgYikpKSA9PT0gLTEgfHwgYiA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgTmFOLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNOYU4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gIXRoaXMucztcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICovXHJcbiAgUC5pc05lZ2F0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHRoaXMucyA8IDA7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNQb3NpdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBpcyAwIG9yIC0wLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqL1xyXG4gIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5jICYmIHRoaXMuY1swXSA9PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC0gMCA9IG5cclxuICAgKiAgbiAtIE4gPSBOXHJcbiAgICogIG4gLSBJID0gLUlcclxuICAgKiAgMCAtIG4gPSAtblxyXG4gICAqICAwIC0gMCA9IDBcclxuICAgKiAgMCAtIE4gPSBOXHJcbiAgICogIDAgLSBJID0gLUlcclxuICAgKiAgTiAtIG4gPSBOXHJcbiAgICogIE4gLSAwID0gTlxyXG4gICAqICBOIC0gTiA9IE5cclxuICAgKiAgTiAtIEkgPSBOXHJcbiAgICogIEkgLSBuID0gSVxyXG4gICAqICBJIC0gMCA9IElcclxuICAgKiAgSSAtIE4gPSBOXHJcbiAgICogIEkgLSBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbWludXMgdGhlIHZhbHVlIG9mXHJcbiAgICogQmlnTnVtYmVyKHksIGIpLlxyXG4gICAqL1xyXG4gIFAubWludXMgPSBmdW5jdGlvbiAoeSwgYikge1xyXG4gICAgdmFyIGksIGosIHQsIHhMVHksXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBhID0geC5zO1xyXG5cclxuICAgIHkgPSBuZXcgQmlnTnVtYmVyKHksIGIpO1xyXG4gICAgYiA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOP1xyXG4gICAgaWYgKCFhIHx8ICFiKSByZXR1cm4gbmV3IEJpZ051bWJlcihOYU4pO1xyXG5cclxuICAgIC8vIFNpZ25zIGRpZmZlcj9cclxuICAgIGlmIChhICE9IGIpIHtcclxuICAgICAgeS5zID0gLWI7XHJcbiAgICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gRWl0aGVyIEluZmluaXR5P1xyXG4gICAgICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIHhjID8gKHkucyA9IC1iLCB5KSA6IG5ldyBCaWdOdW1iZXIoeWMgPyB4IDogTmFOKTtcclxuXHJcbiAgICAgIC8vIEVpdGhlciB6ZXJvP1xyXG4gICAgICBpZiAoIXhjWzBdIHx8ICF5Y1swXSkge1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLCB4IGlmIHggaXMgbm9uLXplcm8sIG9yIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgICAgICByZXR1cm4geWNbMF0gPyAoeS5zID0gLWIsIHkpIDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOlxyXG5cclxuICAgICAgICAgLy8gSUVFRSA3NTQgKDIwMDgpIDYuMzogbiAtIG4gPSAtMCB3aGVuIHJvdW5kaW5nIHRvIC1JbmZpbml0eVxyXG4gICAgICAgICBST1VORElOR19NT0RFID09IDMgPyAtMCA6IDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuXHJcbiAgICAgIGlmICh4TFR5ID0gYSA8IDApIHtcclxuICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgdCA9IHhjO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHllID0geGU7XHJcbiAgICAgICAgdCA9IHljO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0LnJldmVyc2UoKTtcclxuXHJcbiAgICAgIC8vIFByZXBlbmQgemVyb3MgdG8gZXF1YWxpc2UgZXhwb25lbnRzLlxyXG4gICAgICBmb3IgKGIgPSBhOyBiLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIEV4cG9uZW50cyBlcXVhbC4gQ2hlY2sgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICAgIGogPSAoeExUeSA9IChhID0geGMubGVuZ3RoKSA8IChiID0geWMubGVuZ3RoKSkgPyBhIDogYjtcclxuXHJcbiAgICAgIGZvciAoYSA9IGIgPSAwOyBiIDwgajsgYisrKSB7XHJcblxyXG4gICAgICAgIGlmICh4Y1tiXSAhPSB5Y1tiXSkge1xyXG4gICAgICAgICAgeExUeSA9IHhjW2JdIDwgeWNbYl07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyB4IDwgeT8gUG9pbnQgeGMgdG8gdGhlIGFycmF5IG9mIHRoZSBiaWdnZXIgbnVtYmVyLlxyXG4gICAgaWYgKHhMVHkpIHtcclxuICAgICAgdCA9IHhjO1xyXG4gICAgICB4YyA9IHljO1xyXG4gICAgICB5YyA9IHQ7XHJcbiAgICAgIHkucyA9IC15LnM7XHJcbiAgICB9XHJcblxyXG4gICAgYiA9IChqID0geWMubGVuZ3RoKSAtIChpID0geGMubGVuZ3RoKTtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MgdG8geGMgaWYgc2hvcnRlci5cclxuICAgIC8vIE5vIG5lZWQgdG8gYWRkIHplcm9zIHRvIHljIGlmIHNob3J0ZXIgYXMgc3VidHJhY3Qgb25seSBuZWVkcyB0byBzdGFydCBhdCB5Yy5sZW5ndGguXHJcbiAgICBpZiAoYiA+IDApIGZvciAoOyBiLS07IHhjW2krK10gPSAwKTtcclxuICAgIGIgPSBCQVNFIC0gMTtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCB5YyBmcm9tIHhjLlxyXG4gICAgZm9yICg7IGogPiBhOykge1xyXG5cclxuICAgICAgaWYgKHhjWy0tal0gPCB5Y1tqXSkge1xyXG4gICAgICAgIGZvciAoaSA9IGo7IGkgJiYgIXhjWy0taV07IHhjW2ldID0gYik7XHJcbiAgICAgICAgLS14Y1tpXTtcclxuICAgICAgICB4Y1tqXSArPSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4Y1tqXSAtPSB5Y1tqXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgbGVhZGluZyB6ZXJvcyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgZm9yICg7IHhjWzBdID09IDA7IHhjLnNwbGljZSgwLCAxKSwgLS15ZSk7XHJcblxyXG4gICAgLy8gWmVybz9cclxuICAgIGlmICgheGNbMF0pIHtcclxuXHJcbiAgICAgIC8vIEZvbGxvd2luZyBJRUVFIDc1NCAoMjAwOCkgNi4zLFxyXG4gICAgICAvLyBuIC0gbiA9ICswICBidXQgIG4gLSBuID0gLTAgIHdoZW4gcm91bmRpbmcgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIHkucyA9IFJPVU5ESU5HX01PREUgPT0gMyA/IC0xIDogMTtcclxuICAgICAgeS5jID0gW3kuZSA9IDBdO1xyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciBJbmZpbml0eSBhcyAreCAtICt5ICE9IEluZmluaXR5ICYmIC14IC0gLXkgIT0gSW5maW5pdHlcclxuICAgIC8vIGZvciBmaW5pdGUgeCBhbmQgeS5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgeGMsIHllKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgIG4gJSAwID0gIE5cclxuICAgKiAgIG4gJSBOID0gIE5cclxuICAgKiAgIG4gJSBJID0gIG5cclxuICAgKiAgIDAgJSBuID0gIDBcclxuICAgKiAgLTAgJSBuID0gLTBcclxuICAgKiAgIDAgJSAwID0gIE5cclxuICAgKiAgIDAgJSBOID0gIE5cclxuICAgKiAgIDAgJSBJID0gIDBcclxuICAgKiAgIE4gJSBuID0gIE5cclxuICAgKiAgIE4gJSAwID0gIE5cclxuICAgKiAgIE4gJSBOID0gIE5cclxuICAgKiAgIE4gJSBJID0gIE5cclxuICAgKiAgIEkgJSBuID0gIE5cclxuICAgKiAgIEkgJSAwID0gIE5cclxuICAgKiAgIEkgJSBOID0gIE5cclxuICAgKiAgIEkgJSBJID0gIE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG1vZHVsbyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUgb2YgTU9EVUxPX01PREUuXHJcbiAgICovXHJcbiAgUC5tb2R1bG8gPSBQLm1vZCA9IGZ1bmN0aW9uICh5LCBiKSB7XHJcbiAgICB2YXIgcSwgcyxcclxuICAgICAgeCA9IHRoaXM7XHJcblxyXG4gICAgeSA9IG5ldyBCaWdOdW1iZXIoeSwgYik7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIEluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgemVyby5cclxuICAgIGlmICgheC5jIHx8ICF5LnMgfHwgeS5jICYmICF5LmNbMF0pIHtcclxuICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIEluZmluaXR5IG9yIHggaXMgemVyby5cclxuICAgIH0gZWxzZSBpZiAoIXkuYyB8fCB4LmMgJiYgIXguY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih4KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoTU9EVUxPX01PREUgPT0gOSkge1xyXG5cclxuICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgIC8vIHIgPSB4IC0gcXkgICAgd2hlcmUgIDAgPD0gciA8IGFicyh5KVxyXG4gICAgICBzID0geS5zO1xyXG4gICAgICB5LnMgPSAxO1xyXG4gICAgICBxID0gZGl2KHgsIHksIDAsIDMpO1xyXG4gICAgICB5LnMgPSBzO1xyXG4gICAgICBxLnMgKj0gcztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHEgPSBkaXYoeCwgeSwgMCwgTU9EVUxPX01PREUpO1xyXG4gICAgfVxyXG5cclxuICAgIHkgPSB4Lm1pbnVzKHEudGltZXMoeSkpO1xyXG5cclxuICAgIC8vIFRvIG1hdGNoIEphdmFTY3JpcHQgJSwgZW5zdXJlIHNpZ24gb2YgemVybyBpcyBzaWduIG9mIGRpdmlkZW5kLlxyXG4gICAgaWYgKCF5LmNbMF0gJiYgTU9EVUxPX01PREUgPT0gMSkgeS5zID0geC5zO1xyXG5cclxuICAgIHJldHVybiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICogMCA9IDBcclxuICAgKiAgbiAqIE4gPSBOXHJcbiAgICogIG4gKiBJID0gSVxyXG4gICAqICAwICogbiA9IDBcclxuICAgKiAgMCAqIDAgPSAwXHJcbiAgICogIDAgKiBOID0gTlxyXG4gICAqICAwICogSSA9IE5cclxuICAgKiAgTiAqIG4gPSBOXHJcbiAgICogIE4gKiAwID0gTlxyXG4gICAqICBOICogTiA9IE5cclxuICAgKiAgTiAqIEkgPSBOXHJcbiAgICogIEkgKiBuID0gSVxyXG4gICAqICBJICogMCA9IE5cclxuICAgKiAgSSAqIE4gPSBOXHJcbiAgICogIEkgKiBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgbXVsdGlwbGllZCBieSB0aGUgdmFsdWVcclxuICAgKiBvZiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5tdWx0aXBsaWVkQnkgPSBQLnRpbWVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciBjLCBlLCBpLCBqLCBrLCBtLCB4Y0wsIHhsbywgeGhpLCB5Y0wsIHlsbywgeWhpLCB6YyxcclxuICAgICAgYmFzZSwgc3FydEJhc2UsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4YyA9IHguYyxcclxuICAgICAgeWMgPSAoeSA9IG5ldyBCaWdOdW1iZXIoeSwgYikpLmM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTiwgwrFJbmZpbml0eSBvciDCsTA/XHJcbiAgICBpZiAoIXhjIHx8ICF5YyB8fCAheGNbMF0gfHwgIXljWzBdKSB7XHJcblxyXG4gICAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4sIG9yIG9uZSBpcyAwIGFuZCB0aGUgb3RoZXIgaXMgSW5maW5pdHkuXHJcbiAgICAgIGlmICgheC5zIHx8ICF5LnMgfHwgeGMgJiYgIXhjWzBdICYmICF5YyB8fCB5YyAmJiAheWNbMF0gJiYgIXhjKSB7XHJcbiAgICAgICAgeS5jID0geS5lID0geS5zID0gbnVsbDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB5LnMgKj0geC5zO1xyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICBpZiAoIXhjIHx8ICF5Yykge1xyXG4gICAgICAgICAgeS5jID0geS5lID0gbnVsbDtcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiBlaXRoZXIgaXMgwrEwLlxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB5LmMgPSBbMF07XHJcbiAgICAgICAgICB5LmUgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgZSA9IGJpdEZsb29yKHguZSAvIExPR19CQVNFKSArIGJpdEZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIHkucyAqPSB4LnM7XHJcbiAgICB4Y0wgPSB4Yy5sZW5ndGg7XHJcbiAgICB5Y0wgPSB5Yy5sZW5ndGg7XHJcblxyXG4gICAgLy8gRW5zdXJlIHhjIHBvaW50cyB0byBsb25nZXIgYXJyYXkgYW5kIHhjTCB0byBpdHMgbGVuZ3RoLlxyXG4gICAgaWYgKHhjTCA8IHljTCkge1xyXG4gICAgICB6YyA9IHhjO1xyXG4gICAgICB4YyA9IHljO1xyXG4gICAgICB5YyA9IHpjO1xyXG4gICAgICBpID0geGNMO1xyXG4gICAgICB4Y0wgPSB5Y0w7XHJcbiAgICAgIHljTCA9IGk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGlzZSB0aGUgcmVzdWx0IGFycmF5IHdpdGggemVyb3MuXHJcbiAgICBmb3IgKGkgPSB4Y0wgKyB5Y0wsIHpjID0gW107IGktLTsgemMucHVzaCgwKSk7XHJcblxyXG4gICAgYmFzZSA9IEJBU0U7XHJcbiAgICBzcXJ0QmFzZSA9IFNRUlRfQkFTRTtcclxuXHJcbiAgICBmb3IgKGkgPSB5Y0w7IC0taSA+PSAwOykge1xyXG4gICAgICBjID0gMDtcclxuICAgICAgeWxvID0geWNbaV0gJSBzcXJ0QmFzZTtcclxuICAgICAgeWhpID0geWNbaV0gLyBzcXJ0QmFzZSB8IDA7XHJcblxyXG4gICAgICBmb3IgKGsgPSB4Y0wsIGogPSBpICsgazsgaiA+IGk7KSB7XHJcbiAgICAgICAgeGxvID0geGNbLS1rXSAlIHNxcnRCYXNlO1xyXG4gICAgICAgIHhoaSA9IHhjW2tdIC8gc3FydEJhc2UgfCAwO1xyXG4gICAgICAgIG0gPSB5aGkgKiB4bG8gKyB4aGkgKiB5bG87XHJcbiAgICAgICAgeGxvID0geWxvICogeGxvICsgKChtICUgc3FydEJhc2UpICogc3FydEJhc2UpICsgemNbal0gKyBjO1xyXG4gICAgICAgIGMgPSAoeGxvIC8gYmFzZSB8IDApICsgKG0gLyBzcXJ0QmFzZSB8IDApICsgeWhpICogeGhpO1xyXG4gICAgICAgIHpjW2otLV0gPSB4bG8gJSBiYXNlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB6Y1tqXSA9IGM7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGMpIHtcclxuICAgICAgKytlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgemMuc3BsaWNlKDAsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub3JtYWxpc2UoeSwgemMsIGUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIG5lZ2F0ZWQsXHJcbiAgICogaS5lLiBtdWx0aXBsaWVkIGJ5IC0xLlxyXG4gICAqL1xyXG4gIFAubmVnYXRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IEJpZ051bWJlcih0aGlzKTtcclxuICAgIHgucyA9IC14LnMgfHwgbnVsbDtcclxuICAgIHJldHVybiB4O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IEJpZ051bWJlciB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcGx1cyB0aGUgdmFsdWUgb2ZcclxuICAgKiBCaWdOdW1iZXIoeSwgYikuXHJcbiAgICovXHJcbiAgUC5wbHVzID0gZnVuY3Rpb24gKHksIGIpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgYSA9IHgucztcclxuXHJcbiAgICB5ID0gbmV3IEJpZ051bWJlcih5LCBiKTtcclxuICAgIGIgPSB5LnM7XHJcblxyXG4gICAgLy8gRWl0aGVyIE5hTj9cclxuICAgIGlmICghYSB8fCAhYikgcmV0dXJuIG5ldyBCaWdOdW1iZXIoTmFOKTtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICAgaWYgKGEgIT0gYikge1xyXG4gICAgICB5LnMgPSAtYjtcclxuICAgICAgcmV0dXJuIHgubWludXMoeSk7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHhlID0geC5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHllID0geS5lIC8gTE9HX0JBU0UsXHJcbiAgICAgIHhjID0geC5jLFxyXG4gICAgICB5YyA9IHkuYztcclxuXHJcbiAgICBpZiAoIXhlIHx8ICF5ZSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIMKxSW5maW5pdHkuXHJcbiAgICAgIGlmICgheGMgfHwgIXljKSByZXR1cm4gbmV3IEJpZ051bWJlcihhIC8gMCk7XHJcblxyXG4gICAgICAvLyBFaXRoZXIgemVybz9cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVybywgeCBpZiB4IGlzIG5vbi16ZXJvLCBvciB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIGlmICgheGNbMF0gfHwgIXljWzBdKSByZXR1cm4geWNbMF0gPyB5IDogbmV3IEJpZ051bWJlcih4Y1swXSA/IHggOiBhICogMCk7XHJcbiAgICB9XHJcblxyXG4gICAgeGUgPSBiaXRGbG9vcih4ZSk7XHJcbiAgICB5ZSA9IGJpdEZsb29yKHllKTtcclxuICAgIHhjID0geGMuc2xpY2UoKTtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy4gRmFzdGVyIHRvIHVzZSByZXZlcnNlIHRoZW4gZG8gdW5zaGlmdHMuXHJcbiAgICBpZiAoYSA9IHhlIC0geWUpIHtcclxuICAgICAgaWYgKGEgPiAwKSB7XHJcbiAgICAgICAgeWUgPSB4ZTtcclxuICAgICAgICB0ID0geWM7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgIHQgPSB4YztcclxuICAgICAgfVxyXG5cclxuICAgICAgdC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoOyBhLS07IHQucHVzaCgwKSk7XHJcbiAgICAgIHQucmV2ZXJzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGEgPSB4Yy5sZW5ndGg7XHJcbiAgICBiID0geWMubGVuZ3RoO1xyXG5cclxuICAgIC8vIFBvaW50IHhjIHRvIHRoZSBsb25nZXIgYXJyYXksIGFuZCBiIHRvIHRoZSBzaG9ydGVyIGxlbmd0aC5cclxuICAgIGlmIChhIC0gYiA8IDApIHtcclxuICAgICAgdCA9IHljO1xyXG4gICAgICB5YyA9IHhjO1xyXG4gICAgICB4YyA9IHQ7XHJcbiAgICAgIGIgPSBhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE9ubHkgc3RhcnQgYWRkaW5nIGF0IHljLmxlbmd0aCAtIDEgYXMgdGhlIGZ1cnRoZXIgZGlnaXRzIG9mIHhjIGNhbiBiZSBpZ25vcmVkLlxyXG4gICAgZm9yIChhID0gMDsgYjspIHtcclxuICAgICAgYSA9ICh4Y1stLWJdID0geGNbYl0gKyB5Y1tiXSArIGEpIC8gQkFTRSB8IDA7XHJcbiAgICAgIHhjW2JdID0gQkFTRSA9PT0geGNbYl0gPyAwIDogeGNbYl0gJSBCQVNFO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChhKSB7XHJcbiAgICAgIHhjID0gW2FdLmNvbmNhdCh4Yyk7XHJcbiAgICAgICsreWU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm8gbmVlZCB0byBjaGVjayBmb3IgemVybywgYXMgK3ggKyAreSAhPSAwICYmIC14ICsgLXkgIT0gMFxyXG4gICAgLy8geWUgPSBNQVhfRVhQICsgMSBwb3NzaWJsZVxyXG4gICAgcmV0dXJuIG5vcm1hbGlzZSh5LCB4YywgeWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIElmIHNkIGlzIHVuZGVmaW5lZCBvciBudWxsIG9yIHRydWUgb3IgZmFsc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGRpZ2l0cyBvZlxyXG4gICAqIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciwgb3IgbnVsbCBpZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaXMgwrFJbmZpbml0eSBvciBOYU4uXHJcbiAgICogSWYgc2QgaXMgdHJ1ZSBpbmNsdWRlIGludGVnZXItcGFydCB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgY291bnQuXHJcbiAgICpcclxuICAgKiBPdGhlcndpc2UsIGlmIHNkIGlzIGEgbnVtYmVyLCByZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzXHJcbiAgICogQmlnTnVtYmVyIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIHNkIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIHJtLCBvclxyXG4gICAqIFJPVU5ESU5HX01PREUgaWYgcm0gaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIHNkIHtudW1iZXJ8Ym9vbGVhbn0gbnVtYmVyOiBzaWduaWZpY2FudCBkaWdpdHM6IGludGVnZXIsIDEgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IHdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlIG9yIGZhbHNlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAqL1xyXG4gIFAucHJlY2lzaW9uID0gUC5zZCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHZhciBjLCBuLCB2LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoc2QgIT0gbnVsbCAmJiBzZCAhPT0gISFzZCkge1xyXG4gICAgICBpbnRDaGVjayhzZCwgMSwgTUFYKTtcclxuICAgICAgaWYgKHJtID09IG51bGwpIHJtID0gUk9VTkRJTkdfTU9ERTtcclxuICAgICAgZWxzZSBpbnRDaGVjayhybSwgMCwgOCk7XHJcblxyXG4gICAgICByZXR1cm4gcm91bmQobmV3IEJpZ051bWJlcih4KSwgc2QsIHJtKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIShjID0geC5jKSkgcmV0dXJuIG51bGw7XHJcbiAgICB2ID0gYy5sZW5ndGggLSAxO1xyXG4gICAgbiA9IHYgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgaWYgKHYgPSBjW3ZdKSB7XHJcblxyXG4gICAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IGVsZW1lbnQuXHJcbiAgICAgIGZvciAoOyB2ICUgMTAgPT0gMDsgdiAvPSAxMCwgbi0tKTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3QgZWxlbWVudC5cclxuICAgICAgZm9yICh2ID0gY1swXTsgdiA+PSAxMDsgdiAvPSAxMCwgbisrKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2QgJiYgeC5lICsgMSA+IG4pIG4gPSB4LmUgKyAxO1xyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBCaWdOdW1iZXIgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIHNoaWZ0ZWQgYnkgayBwbGFjZXNcclxuICAgKiAocG93ZXJzIG9mIDEwKS4gU2hpZnQgdG8gdGhlIHJpZ2h0IGlmIG4gPiAwLCBhbmQgdG8gdGhlIGxlZnQgaWYgbiA8IDAuXHJcbiAgICpcclxuICAgKiBrIHtudW1iZXJ9IEludGVnZXIsIC1NQVhfU0FGRV9JTlRFR0VSIHRvIE1BWF9TQUZFX0lOVEVHRVIgaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtrfSdcclxuICAgKi9cclxuICBQLnNoaWZ0ZWRCeSA9IGZ1bmN0aW9uIChrKSB7XHJcbiAgICBpbnRDaGVjayhrLCAtTUFYX1NBRkVfSU5URUdFUiwgTUFYX1NBRkVfSU5URUdFUik7XHJcbiAgICByZXR1cm4gdGhpcy50aW1lcygnMWUnICsgayk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIHNxcnQoLW4pID0gIE5cclxuICAgKiAgc3FydChOKSA9ICBOXHJcbiAgICogIHNxcnQoLUkpID0gIE5cclxuICAgKiAgc3FydChJKSA9ICBJXHJcbiAgICogIHNxcnQoMCkgPSAgMFxyXG4gICAqICBzcXJ0KC0wKSA9IC0wXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgQmlnTnVtYmVyIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIsXHJcbiAgICogcm91bmRlZCBhY2NvcmRpbmcgdG8gREVDSU1BTF9QTEFDRVMgYW5kIFJPVU5ESU5HX01PREUuXHJcbiAgICovXHJcbiAgUC5zcXVhcmVSb290ID0gUC5zcXJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIG0sIG4sIHIsIHJlcCwgdCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIGMgPSB4LmMsXHJcbiAgICAgIHMgPSB4LnMsXHJcbiAgICAgIGUgPSB4LmUsXHJcbiAgICAgIGRwID0gREVDSU1BTF9QTEFDRVMgKyA0LFxyXG4gICAgICBoYWxmID0gbmV3IEJpZ051bWJlcignMC41Jyk7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICBpZiAocyAhPT0gMSB8fCAhYyB8fCAhY1swXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEJpZ051bWJlcighcyB8fCBzIDwgMCAmJiAoIWMgfHwgY1swXSkgPyBOYU4gOiBjID8geCA6IDEgLyAwKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgcyA9IE1hdGguc3FydCgrdmFsdWVPZih4KSk7XHJcblxyXG4gICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGNvZWZmVG9TdHJpbmcoYyk7XHJcbiAgICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICAgIHMgPSBNYXRoLnNxcnQoK24pO1xyXG4gICAgICBlID0gYml0Rmxvb3IoKGUgKyAxKSAvIDIpIC0gKGUgPCAwIHx8IGUgJSAyKTtcclxuXHJcbiAgICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgICAgbiA9ICc1ZScgKyBlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgICBuID0gbi5zbGljZSgwLCBuLmluZGV4T2YoJ2UnKSArIDEpICsgZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgciA9IG5ldyBCaWdOdW1iZXIobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gbmV3IEJpZ051bWJlcihzICsgJycpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIGZvciB6ZXJvLlxyXG4gICAgLy8gciBjb3VsZCBiZSB6ZXJvIGlmIE1JTl9FWFAgaXMgY2hhbmdlZCBhZnRlciB0aGUgdGhpcyB2YWx1ZSB3YXMgY3JlYXRlZC5cclxuICAgIC8vIFRoaXMgd291bGQgY2F1c2UgYSBkaXZpc2lvbiBieSB6ZXJvICh4L3QpIGFuZCBoZW5jZSBJbmZpbml0eSBiZWxvdywgd2hpY2ggd291bGQgY2F1c2VcclxuICAgIC8vIGNvZWZmVG9TdHJpbmcgdG8gdGhyb3cuXHJcbiAgICBpZiAoci5jWzBdKSB7XHJcbiAgICAgIGUgPSByLmU7XHJcbiAgICAgIHMgPSBlICsgZHA7XHJcbiAgICAgIGlmIChzIDwgMykgcyA9IDA7XHJcblxyXG4gICAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICAgIGZvciAoOyA7KSB7XHJcbiAgICAgICAgdCA9IHI7XHJcbiAgICAgICAgciA9IGhhbGYudGltZXModC5wbHVzKGRpdih4LCB0LCBkcCwgMSkpKTtcclxuXHJcbiAgICAgICAgaWYgKGNvZWZmVG9TdHJpbmcodC5jKS5zbGljZSgwLCBzKSA9PT0gKG4gPSBjb2VmZlRvU3RyaW5nKHIuYykpLnNsaWNlKDAsIHMpKSB7XHJcblxyXG4gICAgICAgICAgLy8gVGhlIGV4cG9uZW50IG9mIHIgbWF5IGhlcmUgYmUgb25lIGxlc3MgdGhhbiB0aGUgZmluYWwgcmVzdWx0IGV4cG9uZW50LFxyXG4gICAgICAgICAgLy8gZS5nIDAuMDAwOTk5OSAoZS00KSAtLT4gMC4wMDEgKGUtMyksIHNvIGFkanVzdCBzIHNvIHRoZSByb3VuZGluZyBkaWdpdHNcclxuICAgICAgICAgIC8vIGFyZSBpbmRleGVkIGNvcnJlY3RseS5cclxuICAgICAgICAgIGlmIChyLmUgPCBlKSAtLXM7XHJcbiAgICAgICAgICBuID0gbi5zbGljZShzIC0gMywgcyArIDEpO1xyXG5cclxuICAgICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0c1xyXG4gICAgICAgICAgLy8gYXJlIDk5OTkgb3IgNDk5OSAoaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5KSBjb250aW51ZSB0aGVcclxuICAgICAgICAgIC8vIGl0ZXJhdGlvbi5cclxuICAgICAgICAgIGlmIChuID09ICc5OTk5JyB8fCAhcmVwICYmIG4gPT0gJzQ5OTknKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGVcclxuICAgICAgICAgICAgLy8gZXhhY3QgcmVzdWx0IGFzIHRoZSBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgICAgIGlmICghcmVwKSB7XHJcbiAgICAgICAgICAgICAgcm91bmQodCwgdC5lICsgREVDSU1BTF9QTEFDRVMgKyAyLCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBkcCArPSA0O1xyXG4gICAgICAgICAgICBzICs9IDQ7XHJcbiAgICAgICAgICAgIHJlcCA9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgICAgLy8gSWYgcm91bmRpbmcgZGlnaXRzIGFyZSBudWxsLCAwezAsNH0gb3IgNTB7MCwzfSwgY2hlY2sgZm9yIGV4YWN0XHJcbiAgICAgICAgICAgIC8vIHJlc3VsdC4gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdC5cclxuICAgICAgICAgICAgICByb3VuZChyLCByLmUgKyBERUNJTUFMX1BMQUNFUyArIDIsIDEpO1xyXG4gICAgICAgICAgICAgIG0gPSAhci50aW1lcyhyKS5lcSh4KTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHJvdW5kKHIsIHIuZSArIERFQ0lNQUxfUExBQ0VTICsgMSwgUk9VTkRJTkdfTU9ERSwgbSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gZXhwb25lbnRpYWwgbm90YXRpb24gYW5kXHJcbiAgICogcm91bmRlZCB1c2luZyBST1VORElOR19NT0RFIHRvIGRwIGZpeGVkIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAqXHJcbiAgICogW2RwXSB7bnVtYmVyfSBEZWNpbWFsIHBsYWNlcy4gSW50ZWdlciwgMCB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqL1xyXG4gIFAudG9FeHBvbmVudGlhbCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIGlmIChkcCAhPSBudWxsKSB7XHJcbiAgICAgIGludENoZWNrKGRwLCAwLCBNQVgpO1xyXG4gICAgICBkcCsrO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0sIDEpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kaW5nXHJcbiAgICogdG8gZHAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBybSwgb3IgUk9VTkRJTkdfTU9ERSBpZiBybSBpcyBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogTm90ZTogYXMgd2l0aCBKYXZhU2NyaXB0J3MgbnVtYmVyIHR5cGUsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsXHJcbiAgICogYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWCBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ1tCaWdOdW1iZXIgRXJyb3JdIEFyZ3VtZW50IHtub3QgYSBwcmltaXRpdmUgbnVtYmVyfG5vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX06IHtkcHxybX0nXHJcbiAgICovXHJcbiAgUC50b0ZpeGVkID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgaWYgKGRwICE9IG51bGwpIHtcclxuICAgICAgaW50Q2hlY2soZHAsIDAsIE1BWCk7XHJcbiAgICAgIGRwID0gZHAgKyB0aGlzLmUgKyAxO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZvcm1hdCh0aGlzLCBkcCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgQmlnTnVtYmVyIGluIGZpeGVkLXBvaW50IG5vdGF0aW9uIHJvdW5kZWRcclxuICAgKiB1c2luZyBybSBvciBST1VORElOR19NT0RFIHRvIGRwIGRlY2ltYWwgcGxhY2VzLCBhbmQgZm9ybWF0dGVkIGFjY29yZGluZyB0byB0aGUgcHJvcGVydGllc1xyXG4gICAqIG9mIHRoZSBmb3JtYXQgb3IgRk9STUFUIG9iamVjdCAoc2VlIEJpZ051bWJlci5zZXQpLlxyXG4gICAqXHJcbiAgICogVGhlIGZvcm1hdHRpbmcgb2JqZWN0IG1heSBjb250YWluIHNvbWUgb3IgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIHNob3duIGJlbG93LlxyXG4gICAqXHJcbiAgICogRk9STUFUID0ge1xyXG4gICAqICAgcHJlZml4OiAnJyxcclxuICAgKiAgIGdyb3VwU2l6ZTogMyxcclxuICAgKiAgIHNlY29uZGFyeUdyb3VwU2l6ZTogMCxcclxuICAgKiAgIGdyb3VwU2VwYXJhdG9yOiAnLCcsXHJcbiAgICogICBkZWNpbWFsU2VwYXJhdG9yOiAnLicsXHJcbiAgICogICBmcmFjdGlvbkdyb3VwU2l6ZTogMCxcclxuICAgKiAgIGZyYWN0aW9uR3JvdXBTZXBhcmF0b3I6ICdcXHhBMCcsICAgICAgLy8gbm9uLWJyZWFraW5nIHNwYWNlXHJcbiAgICogICBzdWZmaXg6ICcnXHJcbiAgICogfTtcclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICogW2Zvcm1hdF0ge29iamVjdH0gRm9ybWF0dGluZyBvcHRpb25zLiBTZWUgRk9STUFUIHBiamVjdCBhYm92ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7ZHB8cm19J1xyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCBub3QgYW4gb2JqZWN0OiB7Zm9ybWF0fSdcclxuICAgKi9cclxuICBQLnRvRm9ybWF0ID0gZnVuY3Rpb24gKGRwLCBybSwgZm9ybWF0KSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcclxuICAgICAgaWYgKGRwICE9IG51bGwgJiYgcm0gJiYgdHlwZW9mIHJtID09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgZm9ybWF0ID0gcm07XHJcbiAgICAgICAgcm0gPSBudWxsO1xyXG4gICAgICB9IGVsc2UgaWYgKGRwICYmIHR5cGVvZiBkcCA9PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIGZvcm1hdCA9IGRwO1xyXG4gICAgICAgIGRwID0gcm0gPSBudWxsO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGZvcm1hdCA9IEZPUk1BVDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZm9ybWF0ICE9ICdvYmplY3QnKSB7XHJcbiAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgKGJpZ251bWJlckVycm9yICsgJ0FyZ3VtZW50IG5vdCBhbiBvYmplY3Q6ICcgKyBmb3JtYXQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IHgudG9GaXhlZChkcCwgcm0pO1xyXG5cclxuICAgIGlmICh4LmMpIHtcclxuICAgICAgdmFyIGksXHJcbiAgICAgICAgYXJyID0gc3RyLnNwbGl0KCcuJyksXHJcbiAgICAgICAgZzEgPSArZm9ybWF0Lmdyb3VwU2l6ZSxcclxuICAgICAgICBnMiA9ICtmb3JtYXQuc2Vjb25kYXJ5R3JvdXBTaXplLFxyXG4gICAgICAgIGdyb3VwU2VwYXJhdG9yID0gZm9ybWF0Lmdyb3VwU2VwYXJhdG9yIHx8ICcnLFxyXG4gICAgICAgIGludFBhcnQgPSBhcnJbMF0sXHJcbiAgICAgICAgZnJhY3Rpb25QYXJ0ID0gYXJyWzFdLFxyXG4gICAgICAgIGlzTmVnID0geC5zIDwgMCxcclxuICAgICAgICBpbnREaWdpdHMgPSBpc05lZyA/IGludFBhcnQuc2xpY2UoMSkgOiBpbnRQYXJ0LFxyXG4gICAgICAgIGxlbiA9IGludERpZ2l0cy5sZW5ndGg7XHJcblxyXG4gICAgICBpZiAoZzIpIHtcclxuICAgICAgICBpID0gZzE7XHJcbiAgICAgICAgZzEgPSBnMjtcclxuICAgICAgICBnMiA9IGk7XHJcbiAgICAgICAgbGVuIC09IGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChnMSA+IDAgJiYgbGVuID4gMCkge1xyXG4gICAgICAgIGkgPSBsZW4gJSBnMSB8fCBnMTtcclxuICAgICAgICBpbnRQYXJ0ID0gaW50RGlnaXRzLnN1YnN0cigwLCBpKTtcclxuICAgICAgICBmb3IgKDsgaSA8IGxlbjsgaSArPSBnMSkgaW50UGFydCArPSBncm91cFNlcGFyYXRvciArIGludERpZ2l0cy5zdWJzdHIoaSwgZzEpO1xyXG4gICAgICAgIGlmIChnMiA+IDApIGludFBhcnQgKz0gZ3JvdXBTZXBhcmF0b3IgKyBpbnREaWdpdHMuc2xpY2UoaSk7XHJcbiAgICAgICAgaWYgKGlzTmVnKSBpbnRQYXJ0ID0gJy0nICsgaW50UGFydDtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gZnJhY3Rpb25QYXJ0XHJcbiAgICAgICA/IGludFBhcnQgKyAoZm9ybWF0LmRlY2ltYWxTZXBhcmF0b3IgfHwgJycpICsgKChnMiA9ICtmb3JtYXQuZnJhY3Rpb25Hcm91cFNpemUpXHJcbiAgICAgICAgPyBmcmFjdGlvblBhcnQucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcZHsnICsgZzIgKyAnfVxcXFxCJywgJ2cnKSxcclxuICAgICAgICAgJyQmJyArIChmb3JtYXQuZnJhY3Rpb25Hcm91cFNlcGFyYXRvciB8fCAnJykpXHJcbiAgICAgICAgOiBmcmFjdGlvblBhcnQpXHJcbiAgICAgICA6IGludFBhcnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChmb3JtYXQucHJlZml4IHx8ICcnKSArIHN0ciArIChmb3JtYXQuc3VmZml4IHx8ICcnKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdHdvIEJpZ051bWJlcnMgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBhcyBhIHNpbXBsZVxyXG4gICAqIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlciBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAgICogVGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgYSBwb3NpdGl2ZSBub24temVybyB2YWx1ZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHNwZWNpZmllZFxyXG4gICAqIG1heGltdW0gZGVub21pbmF0b3IuIElmIGEgbWF4aW11bSBkZW5vbWluYXRvciBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgZGVub21pbmF0b3Igd2lsbCBiZVxyXG4gICAqIHRoZSBsb3dlc3QgdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAgICpcclxuICAgKiBbbWRdIHtudW1iZXJ8c3RyaW5nfEJpZ051bWJlcn0gSW50ZWdlciA+PSAxLCBvciBJbmZpbml0eS4gVGhlIG1heGltdW0gZGVub21pbmF0b3IuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQXJndW1lbnQge25vdCBhbiBpbnRlZ2VyfG91dCBvZiByYW5nZX0gOiB7bWR9J1xyXG4gICAqL1xyXG4gIFAudG9GcmFjdGlvbiA9IGZ1bmN0aW9uIChtZCkge1xyXG4gICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGV4cCwgbiwgbjAsIG4xLCBxLCByLCBzLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgeGMgPSB4LmM7XHJcblxyXG4gICAgaWYgKG1kICE9IG51bGwpIHtcclxuICAgICAgbiA9IG5ldyBCaWdOdW1iZXIobWQpO1xyXG5cclxuICAgICAgLy8gVGhyb3cgaWYgbWQgaXMgbGVzcyB0aGFuIG9uZSBvciBpcyBub3QgYW4gaW50ZWdlciwgdW5sZXNzIGl0IGlzIEluZmluaXR5LlxyXG4gICAgICBpZiAoIW4uaXNJbnRlZ2VyKCkgJiYgKG4uYyB8fCBuLnMgIT09IDEpIHx8IG4ubHQoT05FKSkge1xyXG4gICAgICAgIHRocm93IEVycm9yXHJcbiAgICAgICAgICAoYmlnbnVtYmVyRXJyb3IgKyAnQXJndW1lbnQgJyArXHJcbiAgICAgICAgICAgIChuLmlzSW50ZWdlcigpID8gJ291dCBvZiByYW5nZTogJyA6ICdub3QgYW4gaW50ZWdlcjogJykgKyB2YWx1ZU9mKG4pKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmICgheGMpIHJldHVybiBuZXcgQmlnTnVtYmVyKHgpO1xyXG5cclxuICAgIGQgPSBuZXcgQmlnTnVtYmVyKE9ORSk7XHJcbiAgICBuMSA9IGQwID0gbmV3IEJpZ051bWJlcihPTkUpO1xyXG4gICAgZDEgPSBuMCA9IG5ldyBCaWdOdW1iZXIoT05FKTtcclxuICAgIHMgPSBjb2VmZlRvU3RyaW5nKHhjKTtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgaW5pdGlhbCBkZW5vbWluYXRvci5cclxuICAgIC8vIGQgaXMgYSBwb3dlciBvZiAxMCBhbmQgdGhlIG1pbmltdW0gbWF4IGRlbm9taW5hdG9yIHRoYXQgc3BlY2lmaWVzIHRoZSB2YWx1ZSBleGFjdGx5LlxyXG4gICAgZSA9IGQuZSA9IHMubGVuZ3RoIC0geC5lIC0gMTtcclxuICAgIGQuY1swXSA9IFBPV1NfVEVOWyhleHAgPSBlICUgTE9HX0JBU0UpIDwgMCA/IExPR19CQVNFICsgZXhwIDogZXhwXTtcclxuICAgIG1kID0gIW1kIHx8IG4uY29tcGFyZWRUbyhkKSA+IDAgPyAoZSA+IDAgPyBkIDogbjEpIDogbjtcclxuXHJcbiAgICBleHAgPSBNQVhfRVhQO1xyXG4gICAgTUFYX0VYUCA9IDEgLyAwO1xyXG4gICAgbiA9IG5ldyBCaWdOdW1iZXIocyk7XHJcblxyXG4gICAgLy8gbjAgPSBkMSA9IDBcclxuICAgIG4wLmNbMF0gPSAwO1xyXG5cclxuICAgIGZvciAoOyA7KSAge1xyXG4gICAgICBxID0gZGl2KG4sIGQsIDAsIDEpO1xyXG4gICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICBpZiAoZDIuY29tcGFyZWRUbyhtZCkgPT0gMSkgYnJlYWs7XHJcbiAgICAgIGQwID0gZDE7XHJcbiAgICAgIGQxID0gZDI7XHJcbiAgICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyID0gbjEpKTtcclxuICAgICAgbjAgPSBkMjtcclxuICAgICAgZCA9IG4ubWludXMocS50aW1lcyhkMiA9IGQpKTtcclxuICAgICAgbiA9IGQyO1xyXG4gICAgfVxyXG5cclxuICAgIGQyID0gZGl2KG1kLm1pbnVzKGQwKSwgZDEsIDAsIDEpO1xyXG4gICAgbjAgPSBuMC5wbHVzKGQyLnRpbWVzKG4xKSk7XHJcbiAgICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICAgIG4wLnMgPSBuMS5zID0geC5zO1xyXG4gICAgZSA9IGUgKiAyO1xyXG5cclxuICAgIC8vIERldGVybWluZSB3aGljaCBmcmFjdGlvbiBpcyBjbG9zZXIgdG8geCwgbjAvZDAgb3IgbjEvZDFcclxuICAgIHIgPSBkaXYobjEsIGQxLCBlLCBST1VORElOR19NT0RFKS5taW51cyh4KS5hYnMoKS5jb21wYXJlZFRvKFxyXG4gICAgICAgIGRpdihuMCwgZDAsIGUsIFJPVU5ESU5HX01PREUpLm1pbnVzKHgpLmFicygpKSA8IDEgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICAgIE1BWF9FWFAgPSBleHA7XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGlzIEJpZ051bWJlciBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAqL1xyXG4gIFAudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gK3ZhbHVlT2YodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgcm91bmRlZCB0byBzZCBzaWduaWZpY2FudCBkaWdpdHNcclxuICAgKiB1c2luZyByb3VuZGluZyBtb2RlIHJtIG9yIFJPVU5ESU5HX01PREUuIElmIHNkIGlzIGxlc3MgdGhhbiB0aGUgbnVtYmVyIG9mIGRpZ2l0c1xyXG4gICAqIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gZml4ZWQtcG9pbnQgbm90YXRpb24sIHRoZW4gdXNlXHJcbiAgICogZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVggaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICdbQmlnTnVtYmVyIEVycm9yXSBBcmd1bWVudCB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7c2R8cm19J1xyXG4gICAqL1xyXG4gIFAudG9QcmVjaXNpb24gPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICBpZiAoc2QgIT0gbnVsbCkgaW50Q2hlY2soc2QsIDEsIE1BWCk7XHJcbiAgICByZXR1cm4gZm9ybWF0KHRoaXMsIHNkLCBybSwgMik7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBCaWdOdW1iZXIgaW4gYmFzZSBiLCBvciBiYXNlIDEwIGlmIGIgaXNcclxuICAgKiBvbWl0dGVkLiBJZiBhIGJhc2UgaXMgc3BlY2lmaWVkLCBpbmNsdWRpbmcgYmFzZSAxMCwgcm91bmQgYWNjb3JkaW5nIHRvIERFQ0lNQUxfUExBQ0VTIGFuZFxyXG4gICAqIFJPVU5ESU5HX01PREUuIElmIGEgYmFzZSBpcyBub3Qgc3BlY2lmaWVkLCBhbmQgdGhpcyBCaWdOdW1iZXIgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnRcclxuICAgKiB0aGF0IGlzIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiBUT19FWFBfUE9TLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhblxyXG4gICAqIFRPX0VYUF9ORUcsIHJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgKlxyXG4gICAqIFtiXSB7bnVtYmVyfSBJbnRlZ2VyLCAyIHRvIEFMUEhBQkVULmxlbmd0aCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKiAnW0JpZ051bWJlciBFcnJvcl0gQmFzZSB7bm90IGEgcHJpbWl0aXZlIG51bWJlcnxub3QgYW4gaW50ZWdlcnxvdXQgb2YgcmFuZ2V9OiB7Yn0nXHJcbiAgICovXHJcbiAgUC50b1N0cmluZyA9IGZ1bmN0aW9uIChiKSB7XHJcbiAgICB2YXIgc3RyLFxyXG4gICAgICBuID0gdGhpcyxcclxuICAgICAgcyA9IG4ucyxcclxuICAgICAgZSA9IG4uZTtcclxuXHJcbiAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICBpZiAoZSA9PT0gbnVsbCkge1xyXG4gICAgICBpZiAocykge1xyXG4gICAgICAgIHN0ciA9ICdJbmZpbml0eSc7XHJcbiAgICAgICAgaWYgKHMgPCAwKSBzdHIgPSAnLScgKyBzdHI7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgc3RyID0gJ05hTic7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGlmIChiID09IG51bGwpIHtcclxuICAgICAgICBzdHIgPSBlIDw9IFRPX0VYUF9ORUcgfHwgZSA+PSBUT19FWFBfUE9TXHJcbiAgICAgICAgID8gdG9FeHBvbmVudGlhbChjb2VmZlRvU3RyaW5nKG4uYyksIGUpXHJcbiAgICAgICAgIDogdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgZSwgJzAnKTtcclxuICAgICAgfSBlbHNlIGlmIChiID09PSAxMCAmJiBhbHBoYWJldEhhc05vcm1hbERlY2ltYWxEaWdpdHMpIHtcclxuICAgICAgICBuID0gcm91bmQobmV3IEJpZ051bWJlcihuKSwgREVDSU1BTF9QTEFDRVMgKyBlICsgMSwgUk9VTkRJTkdfTU9ERSk7XHJcbiAgICAgICAgc3RyID0gdG9GaXhlZFBvaW50KGNvZWZmVG9TdHJpbmcobi5jKSwgbi5lLCAnMCcpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGludENoZWNrKGIsIDIsIEFMUEhBQkVULmxlbmd0aCwgJ0Jhc2UnKTtcclxuICAgICAgICBzdHIgPSBjb252ZXJ0QmFzZSh0b0ZpeGVkUG9pbnQoY29lZmZUb1N0cmluZyhuLmMpLCBlLCAnMCcpLCAxMCwgYiwgcywgdHJ1ZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzIDwgMCAmJiBuLmNbMF0pIHN0ciA9ICctJyArIHN0cjtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhcyB0b1N0cmluZywgYnV0IGRvIG5vdCBhY2NlcHQgYSBiYXNlIGFyZ3VtZW50LCBhbmQgaW5jbHVkZSB0aGUgbWludXMgc2lnbiBmb3JcclxuICAgKiBuZWdhdGl2ZSB6ZXJvLlxyXG4gICAqL1xyXG4gIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIHZhbHVlT2YodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIFAuX2lzQmlnTnVtYmVyID0gdHJ1ZTtcclxuXHJcbiAgUFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0JpZ051bWJlcic7XHJcblxyXG4gIC8vIE5vZGUuanMgdjEwLjEyLjArXHJcbiAgUFtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9IFAudmFsdWVPZjtcclxuXHJcbiAgaWYgKGNvbmZpZ09iamVjdCAhPSBudWxsKSBCaWdOdW1iZXIuc2V0KGNvbmZpZ09iamVjdCk7XHJcblxyXG4gIHJldHVybiBCaWdOdW1iZXI7XHJcbn1cclxuXHJcblxyXG4vLyBQUklWQVRFIEhFTFBFUiBGVU5DVElPTlNcclxuXHJcbi8vIFRoZXNlIGZ1bmN0aW9ucyBkb24ndCBuZWVkIGFjY2VzcyB0byB2YXJpYWJsZXMsXHJcbi8vIGUuZy4gREVDSU1BTF9QTEFDRVMsIGluIHRoZSBzY29wZSBvZiB0aGUgYGNsb25lYCBmdW5jdGlvbiBhYm92ZS5cclxuXHJcblxyXG5mdW5jdGlvbiBiaXRGbG9vcihuKSB7XHJcbiAgdmFyIGkgPSBuIHwgMDtcclxuICByZXR1cm4gbiA+IDAgfHwgbiA9PT0gaSA/IGkgOiBpIC0gMTtcclxufVxyXG5cclxuXHJcbi8vIFJldHVybiBhIGNvZWZmaWNpZW50IGFycmF5IGFzIGEgc3RyaW5nIG9mIGJhc2UgMTAgZGlnaXRzLlxyXG5mdW5jdGlvbiBjb2VmZlRvU3RyaW5nKGEpIHtcclxuICB2YXIgcywgeixcclxuICAgIGkgPSAxLFxyXG4gICAgaiA9IGEubGVuZ3RoLFxyXG4gICAgciA9IGFbMF0gKyAnJztcclxuXHJcbiAgZm9yICg7IGkgPCBqOykge1xyXG4gICAgcyA9IGFbaSsrXSArICcnO1xyXG4gICAgeiA9IExPR19CQVNFIC0gcy5sZW5ndGg7XHJcbiAgICBmb3IgKDsgei0tOyBzID0gJzAnICsgcyk7XHJcbiAgICByICs9IHM7XHJcbiAgfVxyXG5cclxuICAvLyBEZXRlcm1pbmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChqID0gci5sZW5ndGg7IHIuY2hhckNvZGVBdCgtLWopID09PSA0ODspO1xyXG5cclxuICByZXR1cm4gci5zbGljZSgwLCBqICsgMSB8fCAxKTtcclxufVxyXG5cclxuXHJcbi8vIENvbXBhcmUgdGhlIHZhbHVlIG9mIEJpZ051bWJlcnMgeCBhbmQgeS5cclxuZnVuY3Rpb24gY29tcGFyZSh4LCB5KSB7XHJcbiAgdmFyIGEsIGIsXHJcbiAgICB4YyA9IHguYyxcclxuICAgIHljID0geS5jLFxyXG4gICAgaSA9IHgucyxcclxuICAgIGogPSB5LnMsXHJcbiAgICBrID0geC5lLFxyXG4gICAgbCA9IHkuZTtcclxuXHJcbiAgLy8gRWl0aGVyIE5hTj9cclxuICBpZiAoIWkgfHwgIWopIHJldHVybiBudWxsO1xyXG5cclxuICBhID0geGMgJiYgIXhjWzBdO1xyXG4gIGIgPSB5YyAmJiAheWNbMF07XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmIChhIHx8IGIpIHJldHVybiBhID8gYiA/IDAgOiAtaiA6IGk7XHJcblxyXG4gIC8vIFNpZ25zIGRpZmZlcj9cclxuICBpZiAoaSAhPSBqKSByZXR1cm4gaTtcclxuXHJcbiAgYSA9IGkgPCAwO1xyXG4gIGIgPSBrID09IGw7XHJcblxyXG4gIC8vIEVpdGhlciBJbmZpbml0eT9cclxuICBpZiAoIXhjIHx8ICF5YykgcmV0dXJuIGIgPyAwIDogIXhjIF4gYSA/IDEgOiAtMTtcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKCFiKSByZXR1cm4gayA+IGwgXiBhID8gMSA6IC0xO1xyXG5cclxuICBqID0gKGsgPSB4Yy5sZW5ndGgpIDwgKGwgPSB5Yy5sZW5ndGgpID8gayA6IGw7XHJcblxyXG4gIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgZm9yIChpID0gMDsgaSA8IGo7IGkrKykgaWYgKHhjW2ldICE9IHljW2ldKSByZXR1cm4geGNbaV0gPiB5Y1tpXSBeIGEgPyAxIDogLTE7XHJcblxyXG4gIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICByZXR1cm4gayA9PSBsID8gMCA6IGsgPiBsIF4gYSA/IDEgOiAtMTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrIHRoYXQgbiBpcyBhIHByaW1pdGl2ZSBudW1iZXIsIGFuIGludGVnZXIsIGFuZCBpbiByYW5nZSwgb3RoZXJ3aXNlIHRocm93LlxyXG4gKi9cclxuZnVuY3Rpb24gaW50Q2hlY2sobiwgbWluLCBtYXgsIG5hbWUpIHtcclxuICBpZiAobiA8IG1pbiB8fCBuID4gbWF4IHx8IG4gIT09IG1hdGhmbG9vcihuKSkge1xyXG4gICAgdGhyb3cgRXJyb3JcclxuICAgICAoYmlnbnVtYmVyRXJyb3IgKyAobmFtZSB8fCAnQXJndW1lbnQnKSArICh0eXBlb2YgbiA9PSAnbnVtYmVyJ1xyXG4gICAgICAgPyBuIDwgbWluIHx8IG4gPiBtYXggPyAnIG91dCBvZiByYW5nZTogJyA6ICcgbm90IGFuIGludGVnZXI6ICdcclxuICAgICAgIDogJyBub3QgYSBwcmltaXRpdmUgbnVtYmVyOiAnKSArIFN0cmluZyhuKSk7XHJcbiAgfVxyXG59XHJcblxyXG5cclxuLy8gQXNzdW1lcyBmaW5pdGUgbi5cclxuZnVuY3Rpb24gaXNPZGQobikge1xyXG4gIHZhciBrID0gbi5jLmxlbmd0aCAtIDE7XHJcbiAgcmV0dXJuIGJpdEZsb29yKG4uZSAvIExPR19CQVNFKSA9PSBrICYmIG4uY1trXSAlIDIgIT0gMDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIHRvRXhwb25lbnRpYWwoc3RyLCBlKSB7XHJcbiAgcmV0dXJuIChzdHIubGVuZ3RoID4gMSA/IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSkgOiBzdHIpICtcclxuICAgKGUgPCAwID8gJ2UnIDogJ2UrJykgKyBlO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gdG9GaXhlZFBvaW50KHN0ciwgZSwgeikge1xyXG4gIHZhciBsZW4sIHpzO1xyXG5cclxuICAvLyBOZWdhdGl2ZSBleHBvbmVudD9cclxuICBpZiAoZSA8IDApIHtcclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zLlxyXG4gICAgZm9yICh6cyA9IHogKyAnLic7ICsrZTsgenMgKz0geik7XHJcbiAgICBzdHIgPSB6cyArIHN0cjtcclxuXHJcbiAgLy8gUG9zaXRpdmUgZXhwb25lbnRcclxuICB9IGVsc2Uge1xyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MuXHJcbiAgICBpZiAoKytlID4gbGVuKSB7XHJcbiAgICAgIGZvciAoenMgPSB6LCBlIC09IGxlbjsgLS1lOyB6cyArPSB6KTtcclxuICAgICAgc3RyICs9IHpzO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgbGVuKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBFWFBPUlRcclxuXHJcblxyXG5leHBvcnQgdmFyIEJpZ051bWJlciA9IGNsb25lKCk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCaWdOdW1iZXI7XHJcbiJdLCJuYW1lcyI6WyJpc051bWVyaWMiLCJtYXRoY2VpbCIsIk1hdGgiLCJjZWlsIiwibWF0aGZsb29yIiwiZmxvb3IiLCJiaWdudW1iZXJFcnJvciIsInRvb01hbnlEaWdpdHMiLCJCQVNFIiwiTE9HX0JBU0UiLCJNQVhfU0FGRV9JTlRFR0VSIiwiUE9XU19URU4iLCJTUVJUX0JBU0UiLCJNQVgiLCJjbG9uZSIsImNvbmZpZ09iamVjdCIsImRpdiIsImNvbnZlcnRCYXNlIiwicGFyc2VOdW1lcmljIiwiUCIsIkJpZ051bWJlciIsInByb3RvdHlwZSIsImNvbnN0cnVjdG9yIiwidG9TdHJpbmciLCJ2YWx1ZU9mIiwiT05FIiwiREVDSU1BTF9QTEFDRVMiLCJST1VORElOR19NT0RFIiwiVE9fRVhQX05FRyIsIlRPX0VYUF9QT1MiLCJNSU5fRVhQIiwiTUFYX0VYUCIsIkNSWVBUTyIsIk1PRFVMT19NT0RFIiwiUE9XX1BSRUNJU0lPTiIsIkZPUk1BVCIsInByZWZpeCIsImdyb3VwU2l6ZSIsInNlY29uZGFyeUdyb3VwU2l6ZSIsImdyb3VwU2VwYXJhdG9yIiwiZGVjaW1hbFNlcGFyYXRvciIsImZyYWN0aW9uR3JvdXBTaXplIiwiZnJhY3Rpb25Hcm91cFNlcGFyYXRvciIsInN1ZmZpeCIsIkFMUEhBQkVUIiwiYWxwaGFiZXRIYXNOb3JtYWxEZWNpbWFsRGlnaXRzIiwidiIsImIiLCJhbHBoYWJldCIsImMiLCJjYXNlQ2hhbmdlZCIsImUiLCJpIiwiaXNOdW0iLCJsZW4iLCJzdHIiLCJ4IiwiX2lzQmlnTnVtYmVyIiwicyIsInNsaWNlIiwiU3RyaW5nIiwidGVzdCIsImNoYXJDb2RlQXQiLCJpbmRleE9mIiwicmVwbGFjZSIsInNlYXJjaCIsInN1YnN0cmluZyIsImxlbmd0aCIsImludENoZWNrIiwicm91bmQiLCJERUJVRyIsIkVycm9yIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJ0b0xvd2VyQ2FzZSIsInB1c2giLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsImNvbmZpZyIsInNldCIsIm9iaiIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInBvcCIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJ5dGVzIiwiRVhQT05FTlRJQUxfQVQiLCJSQU5HRSIsImlzQmlnTnVtYmVyIiwibiIsIm91dCIsImNhbGwiLCJtYXhpbXVtIiwibWF4IiwibWF4T3JNaW4iLCJhcmd1bWVudHMiLCJtaW5pbXVtIiwibWluIiwicmFuZG9tIiwicG93Ml81MyIsInJhbmRvbTUzYml0SW50IiwiZHAiLCJhIiwiayIsInJhbmQiLCJVaW50MzJBcnJheSIsImNvcHkiLCJzcGxpY2UiLCJzdW0iLCJhcmdzIiwicGx1cyIsImRlY2ltYWwiLCJ0b0Jhc2VPdXQiLCJiYXNlSW4iLCJiYXNlT3V0IiwiaiIsImFyciIsImFyckwiLCJyZXZlcnNlIiwic2lnbiIsImNhbGxlcklzVG9TdHJpbmciLCJkIiwiciIsInhjIiwieSIsInJtIiwicG93IiwidG9GaXhlZFBvaW50IiwiY29lZmZUb1N0cmluZyIsImNvbmNhdCIsIm11bHRpcGx5IiwiYmFzZSIsIm0iLCJ0ZW1wIiwieGxvIiwieGhpIiwiY2FycnkiLCJrbG8iLCJraGkiLCJjb21wYXJlIiwiYUwiLCJiTCIsImNtcCIsInN1YnRyYWN0IiwibW9yZSIsInByb2QiLCJwcm9kTCIsInEiLCJxYyIsInJlbSIsInJlbUwiLCJyZW0wIiwieGkiLCJ4TCIsInljMCIsInlMIiwieXoiLCJ5YyIsIk5hTiIsImJpdEZsb29yIiwiZm9ybWF0IiwiaWQiLCJjMCIsIm5lIiwidG9FeHBvbmVudGlhbCIsIm5vcm1hbGlzZSIsImJhc2VQcmVmaXgiLCJkb3RBZnRlciIsImRvdEJlZm9yZSIsImlzSW5maW5pdHlPck5hTiIsIndoaXRlc3BhY2VPclBsdXMiLCJpc05hTiIsInAxIiwicDIiLCJzZCIsIm5pIiwicmQiLCJwb3dzMTAiLCJhYnNvbHV0ZVZhbHVlIiwiYWJzIiwiY29tcGFyZWRUbyIsImRlY2ltYWxQbGFjZXMiLCJkaXZpZGVkQnkiLCJkaXZpZGVkVG9JbnRlZ2VyQnkiLCJpZGl2IiwiZXhwb25lbnRpYXRlZEJ5IiwiaGFsZiIsImlzTW9kRXhwIiwibklzQmlnIiwibklzTmVnIiwibklzT2RkIiwiaXNJbnRlZ2VyIiwiaXNPZGQiLCJtb2QiLCJ0aW1lcyIsImludGVnZXJWYWx1ZSIsImlzRXF1YWxUbyIsImVxIiwiaXNGaW5pdGUiLCJpc0dyZWF0ZXJUaGFuIiwiZ3QiLCJpc0dyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaXNMZXNzVGhhbiIsImx0IiwiaXNMZXNzVGhhbk9yRXF1YWxUbyIsImx0ZSIsImlzTmVnYXRpdmUiLCJpc1Bvc2l0aXZlIiwiaXNaZXJvIiwibWludXMiLCJ0IiwieExUeSIsInhlIiwieWUiLCJtb2R1bG8iLCJtdWx0aXBsaWVkQnkiLCJ4Y0wiLCJ5Y0wiLCJ5bG8iLCJ5aGkiLCJ6YyIsInNxcnRCYXNlIiwibmVnYXRlZCIsInByZWNpc2lvbiIsInNoaWZ0ZWRCeSIsInNxdWFyZVJvb3QiLCJzcXJ0IiwicmVwIiwidG9GaXhlZCIsInRvRm9ybWF0Iiwic3BsaXQiLCJnMSIsImcyIiwiaW50UGFydCIsImZyYWN0aW9uUGFydCIsImlzTmVnIiwiaW50RGlnaXRzIiwic3Vic3RyIiwiUmVnRXhwIiwidG9GcmFjdGlvbiIsIm1kIiwiZDAiLCJkMSIsImQyIiwiZXhwIiwibjAiLCJuMSIsInRvTnVtYmVyIiwidG9QcmVjaXNpb24iLCJ0b0pTT04iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsImZvciIsInoiLCJsIiwibmFtZSIsInpzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/bignumber.js@9.3.1/node_modules/bignumber.js/bignumber.mjs\n");

/***/ })

};
;