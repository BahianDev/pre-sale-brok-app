"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3";
exports.ids = ["vendor-chunks/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS4zLjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwbkI7QUFFMW5CLDRCQUE0QjtBQUU1QixlQUFlO0FBQ2YsSUFBSVksYUFBYSxDQUFDQztJQUNoQixNQUFNQyxxQkFBcUJELFdBQVdFLE1BQU0sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxNQUFNO0lBQ2hFLElBQUlILG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0osV0FBV0ksTUFBTSxHQUFHSixVQUFVLENBQUMsRUFBRSxHQUFHLElBQUlLO0lBQ2pEO0lBQ0EsSUFBSUosbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSCxrQkFBa0IsQ0FBQyxFQUFFO0lBQzlCO0lBQ0EsTUFBTUssY0FBY0wsbUJBQW1CTSxNQUFNLENBQUMsQ0FBQ0MsT0FBT0wsTUFBUUssUUFBUUwsSUFBSUMsTUFBTSxFQUFFO0lBQ2xGLE1BQU1LLFNBQVMsSUFBSUosV0FBV0M7SUFDOUIsSUFBSUksU0FBUztJQUNiVCxtQkFBbUJVLE9BQU8sQ0FBQyxDQUFDUjtRQUMxQk0sT0FBT0csR0FBRyxDQUFDVCxLQUFLTztRQUNoQkEsVUFBVVAsSUFBSUMsTUFBTTtJQUN0QjtJQUNBLE9BQU9LO0FBQ1Q7QUFDQSxJQUFJSSxXQUFXLENBQUNDLE9BQU9WO0lBQ3JCLElBQUlVLE1BQU1WLE1BQU0sSUFBSUEsUUFBUSxPQUFPVTtJQUNuQyxNQUFNQyxjQUFjLElBQUlWLFdBQVdELFFBQVFZLElBQUksQ0FBQztJQUNoREQsWUFBWUgsR0FBRyxDQUFDRTtJQUNoQixPQUFPQztBQUNUO0FBQ0EsSUFBSUUsV0FBVyxDQUFDSCxPQUFPVixTQUFX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QUFRLElBQUlDLE9BQU87UUFDMUhPLE9BQU8sQ0FBQ1IsT0FBT1gsT0FBT0osU0FBV2dCLFFBQVFPLEtBQUssQ0FBQ2dHLE1BQU14RyxRQUFRWCxPQUFPSjtJQUN0RTtBQUNGO0FBQ0EsU0FBU3dILGlCQUFpQi9GLE9BQU8sRUFBRWdHLEdBQUc7SUFDcEMsT0FBT2pHLGNBQWM7UUFDbkIsR0FBR0MsT0FBTztRQUNWRSxNQUFNLENBQUN2QixPQUFPSjtZQUNaLE1BQU0sQ0FBQ2UsT0FBT21HLFVBQVUsR0FBR3pGLFFBQVFFLElBQUksQ0FBQ3ZCLE9BQU9KO1lBQy9DLE9BQU87Z0JBQUN5SCxJQUFJMUcsT0FBT1gsT0FBT0o7Z0JBQVNrSDthQUFVO1FBQy9DO0lBQ0Y7QUFDRjtBQUNBLFNBQVNRLGVBQWU3RixLQUFLLEVBQUUwRixLQUFLLEVBQUVFLEdBQUc7SUFDdkMsT0FBTzdGLFlBQVk7UUFDakIsR0FBRzBGLGlCQUFpQnpGLE9BQU8wRixNQUFNO1FBQ2pDNUYsTUFBTThGLE1BQU1ELGlCQUFpQjNGLE9BQU80RixLQUFLOUYsSUFBSSxHQUFHRSxNQUFNRixJQUFJO0lBQzVEO0FBQ0Y7QUFFdXZCLENBQ3Z2Qix1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc2FsZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS4zLjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLm1qcz80MzY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuXG4vLyBzcmMvYnl0ZXMudHNcbnZhciBtZXJnZUJ5dGVzID0gKGJ5dGVBcnJheXMpID0+IHtcbiAgY29uc3Qgbm9uRW1wdHlCeXRlQXJyYXlzID0gYnl0ZUFycmF5cy5maWx0ZXIoKGFycikgPT4gYXJyLmxlbmd0aCk7XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ5dGVBcnJheXMubGVuZ3RoID8gYnl0ZUFycmF5c1swXSA6IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbm9uRW1wdHlCeXRlQXJyYXlzWzBdO1xuICB9XG4gIGNvbnN0IHRvdGFsTGVuZ3RoID0gbm9uRW1wdHlCeXRlQXJyYXlzLnJlZHVjZSgodG90YWwsIGFycikgPT4gdG90YWwgKyBhcnIubGVuZ3RoLCAwKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbm9uRW1wdHlCeXRlQXJyYXlzLmZvckVhY2goKGFycikgPT4ge1xuICAgIHJlc3VsdC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgcGFkQnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4ge1xuICBpZiAoYnl0ZXMubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGJ5dGVzO1xuICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkuZmlsbCgwKTtcbiAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzKTtcbiAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufTtcbnZhciBmaXhCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiBwYWRCeXRlcyhieXRlcy5sZW5ndGggPD0gbGVuZ3RoID8gYnl0ZXMgOiBieXRlcy5zbGljZSgwLCBsZW5ndGgpLCBsZW5ndGgpO1xuZnVuY3Rpb24gY29udGFpbnNCeXRlcyhkYXRhLCBieXRlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHNsaWNlID0gb2Zmc2V0ID09PSAwICYmIGRhdGEubGVuZ3RoID09PSBieXRlcy5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVzLmxlbmd0aCk7XG4gIGlmIChzbGljZS5sZW5ndGggIT09IGJ5dGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYnl0ZXMuZXZlcnkoKGIsIGkpID0+IGIgPT09IHNsaWNlW2ldKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyKGVuY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpKTtcbiAgICAgIGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihkZWNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhjb2RlYykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uY29kZWMsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGNvZGVjLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGNvZGVjKSk7XG4gICAgICBjb2RlYy53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemUoY29kZWMpIHtcbiAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAhPT0gaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gpO1xuICB9XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLmZpeGVkU2l6ZSAhPT0gZGVjb2Rlci5maXhlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZW5jb2RlcixcbiAgICBkZWNvZGU6IGRlY29kZXIuZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgcmVhZDogZGVjb2Rlci5yZWFkLFxuICAgIHdyaXRlOiBlbmNvZGVyLndyaXRlXG4gIH07XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTZW50aW5lbChlbmNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAoZmluZFNlbnRpbmVsSW5kZXgoZW5jb2RlckJ5dGVzLCBzZW50aW5lbCkgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIHtcbiAgICAgICAgZW5jb2RlZEJ5dGVzOiBlbmNvZGVyQnl0ZXMsXG4gICAgICAgIGhleEVuY29kZWRCeXRlczogaGV4Qnl0ZXMoZW5jb2RlckJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChzZW50aW5lbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gc2VudGluZWwubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgd3JpdGUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4uZW5jb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGVuY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpICsgc2VudGluZWwubGVuZ3RoLFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsKGRlY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZUJ5dGVzID0gb2Zmc2V0ID09PSAwID8gYnl0ZXMgOiBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IHNlbnRpbmVsSW5kZXggPSBmaW5kU2VudGluZWxJbmRleChjYW5kaWRhdGVCeXRlcywgc2VudGluZWwpO1xuICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIHJlYWRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpLCBhZGREZWNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSk7XG59XG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlcywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChzZW50aW5lbC5sZW5ndGggPT09IDEpIHJldHVybiBieXRlID09PSBzZW50aW5lbFswXTtcbiAgICByZXR1cm4gY29udGFpbnNCeXRlcyhhcnIsIHNlbnRpbmVsLCBpbmRleCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgZXhwZWN0ZWQsIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoYnl0ZXNMZW5ndGggPCBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgZXhwZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKGNvZGVjRGVzY3JpcHRpb24sIG9mZnNldCwgYnl0ZXNMZW5ndGgpIHtcbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnl0ZXNMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4KGVuY29kZXIsIHByZWZpeCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBvZmZzZXQgPSBwcmVmaXgud3JpdGUoZW5jb2RlckJ5dGVzLmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyKGJpZ2ludFNpemUpO1xuICAgIG9mZnNldCA9IGRlY29kZXJPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiYWRkRGVjb2RlclNpemVQcmVmaXhcIiwgc2l6ZSwgYnl0ZXMpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGRlY29kZXIuZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IGRlY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBkZWNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBkZWNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXgoY29kZWMsIHByZWZpeCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpLCBhZGREZWNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSk7XG59XG5cbi8vIHNyYy9maXgtY29kZWMtc2l6ZS50c1xuZnVuY3Rpb24gZml4RW5jb2RlclNpemUoZW5jb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlQnl0ZUFycmF5ID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgZml4ZWRCeXRlQXJyYXkgPSB2YXJpYWJsZUJ5dGVBcnJheS5sZW5ndGggPiBmaXhlZEJ5dGVzID8gdmFyaWFibGVCeXRlQXJyYXkuc2xpY2UoMCwgZml4ZWRCeXRlcykgOiB2YXJpYWJsZUJ5dGVBcnJheTtcbiAgICAgIGJ5dGVzLnNldChmaXhlZEJ5dGVBcnJheSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBmaXhlZEJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhEZWNvZGVyU2l6ZShkZWNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJmaXhDb2RlY1NpemVcIiwgZml4ZWRCeXRlcywgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBmaXhlZEJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBmaXhlZEJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgICAgICBieXRlcyA9IGZpeEJ5dGVzKGJ5dGVzLCBkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBbdmFsdWVdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGZpeGVkQnl0ZXNdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhDb2RlY1NpemUoY29kZWMsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhmaXhFbmNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcyksIGZpeERlY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSk7XG59XG5cbi8vIHNyYy9vZmZzZXQtY29kZWMudHNcbmZ1bmN0aW9uIG9mZnNldEVuY29kZXIoZW5jb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcG9zdE9mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3UG9zdE9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0RGVjb2RlcihkZWNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgW3ZhbHVlLCBwb3N0T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3UG9zdE9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldENvZGVjKGNvZGVjLCBjb25maWcpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhvZmZzZXRFbmNvZGVyKGNvZGVjLCBjb25maWcpLCBvZmZzZXREZWNvZGVyKGNvZGVjLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIG1vZHVsbyhkaXZpZGVuZCwgZGl2aXNvcikge1xuICBpZiAoZGl2aXNvciA9PT0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xufVxuZnVuY3Rpb24gcmVzaXplRW5jb2RlcihlbmNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGVuY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChuZXdTaXplIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgICAgYnl0ZXNMZW5ndGg6IG5ld1NpemUsXG4gICAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzaXplRGVjb2RlcihkZWNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZURlY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuZnVuY3Rpb24gcmVzaXplQ29kZWMoY29kZWMsIHJlc2l6ZSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJlc2l6ZUVuY29kZXIoY29kZWMsIHJlc2l6ZSksIHJlc2l6ZURlY29kZXIoY29kZWMsIHJlc2l6ZSkpO1xufVxuXG4vLyBzcmMvcGFkLWNvZGVjLnRzXG5mdW5jdGlvbiBwYWRMZWZ0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZExlZnRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRMZWZ0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5mdW5jdGlvbiBwYWRSaWdodENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRSaWdodEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZFJpZ2h0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5cbi8vIHNyYy9yZXZlcnNlLWNvZGVjLnRzXG5mdW5jdGlvbiBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2Uoc291cmNlLCB0YXJnZXRfV0lMTF9NVVRBVEUsIHNvdXJjZU9mZnNldCwgc291cmNlTGVuZ3RoLCB0YXJnZXRPZmZzZXQgPSAwKSB7XG4gIHdoaWxlIChzb3VyY2VPZmZzZXQgPCAtLXNvdXJjZUxlbmd0aCkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZUxlbmd0aF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZUxlbmd0aCArIHRhcmdldE9mZnNldF0gPSBsZWZ0VmFsdWU7XG4gICAgc291cmNlT2Zmc2V0Kys7XG4gIH1cbiAgaWYgKHNvdXJjZU9mZnNldCA9PT0gc291cmNlTGVuZ3RoKSB7XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZUVuY29kZXIoZW5jb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShlbmNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBieXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VEZWNvZGVyKGRlY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZGVjb2Rlcik7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCByZXZlcnNlZEJ5dGVzID0gYnl0ZXMuc2xpY2UoKTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIHJldmVyc2VkQnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZGVjb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVjb2Rlci5yZWFkKHJldmVyc2VkQnl0ZXMsIG9mZnNldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJldmVyc2VFbmNvZGVyKGNvZGVjKSwgcmV2ZXJzZURlY29kZXIoY29kZWMpKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybS1jb2RlYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcihlbmNvZGVyLCB1bm1hcCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uaXNWYXJpYWJsZVNpemUoZW5jb2RlcikgPyB7IC4uLmVuY29kZXIsIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHVubWFwKHZhbHVlKSkgfSA6IGVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4gZW5jb2Rlci53cml0ZSh1bm1hcCh2YWx1ZSksIGJ5dGVzLCBvZmZzZXQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcihkZWNvZGVyLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBbbWFwKHZhbHVlLCBieXRlcywgb2Zmc2V0KSwgbmV3T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ29kZWMoY29kZWMsIHVubWFwLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAuLi50cmFuc2Zvcm1FbmNvZGVyKGNvZGVjLCB1bm1hcCksXG4gICAgcmVhZDogbWFwID8gdHJhbnNmb3JtRGVjb2Rlcihjb2RlYywgbWFwKS5yZWFkIDogY29kZWMucmVhZFxuICB9KTtcbn1cblxuZXhwb3J0IHsgYWRkQ29kZWNTZW50aW5lbCwgYWRkQ29kZWNTaXplUHJlZml4LCBhZGREZWNvZGVyU2VudGluZWwsIGFkZERlY29kZXJTaXplUHJlZml4LCBhZGRFbmNvZGVyU2VudGluZWwsIGFkZEVuY29kZXJTaXplUHJlZml4LCBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSwgYXNzZXJ0SXNGaXhlZFNpemUsIGFzc2VydElzVmFyaWFibGVTaXplLCBjb21iaW5lQ29kZWMsIGNvbnRhaW5zQnl0ZXMsIGNyZWF0ZUNvZGVjLCBjcmVhdGVEZWNvZGVyLCBjcmVhdGVFbmNvZGVyLCBmaXhCeXRlcywgZml4Q29kZWNTaXplLCBmaXhEZWNvZGVyU2l6ZSwgZml4RW5jb2RlclNpemUsIGdldEVuY29kZWRTaXplLCBpc0ZpeGVkU2l6ZSwgaXNWYXJpYWJsZVNpemUsIG1lcmdlQnl0ZXMsIG9mZnNldENvZGVjLCBvZmZzZXREZWNvZGVyLCBvZmZzZXRFbmNvZGVyLCBwYWRCeXRlcywgcGFkTGVmdENvZGVjLCBwYWRMZWZ0RGVjb2RlciwgcGFkTGVmdEVuY29kZXIsIHBhZFJpZ2h0Q29kZWMsIHBhZFJpZ2h0RGVjb2RlciwgcGFkUmlnaHRFbmNvZGVyLCByZXNpemVDb2RlYywgcmVzaXplRGVjb2RlciwgcmVzaXplRW5jb2RlciwgcmV2ZXJzZUNvZGVjLCByZXZlcnNlRGVjb2RlciwgcmV2ZXJzZUVuY29kZXIsIHRyYW5zZm9ybUNvZGVjLCB0cmFuc2Zvcm1EZWNvZGVyLCB0cmFuc2Zvcm1FbmNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIm1lcmdlQnl0ZXMiLCJieXRlQXJyYXlzIiwibm9uRW1wdHlCeXRlQXJyYXlzIiwiZmlsdGVyIiwiYXJyIiwibGVuZ3RoIiwiVWludDhBcnJheSIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwidG90YWwiLCJyZXN1bHQiLCJvZmZzZXQiLCJmb3JFYWNoIiwic2V0IiwicGFkQnl0ZXMiLCJieXRlcyIsInBhZGRlZEJ5dGVzIiwiZmlsbCIsImZpeEJ5dGVzIiwic2xpY2UiLCJjb250YWluc0J5dGVzIiwiZGF0YSIsImV2ZXJ5IiwiYiIsImkiLCJnZXRFbmNvZGVkU2l6ZSIsInZhbHVlIiwiZW5jb2RlciIsImZpeGVkU2l6ZSIsImdldFNpemVGcm9tVmFsdWUiLCJjcmVhdGVFbmNvZGVyIiwiT2JqZWN0IiwiZnJlZXplIiwiZW5jb2RlIiwid3JpdGUiLCJjcmVhdGVEZWNvZGVyIiwiZGVjb2RlciIsImRlY29kZSIsInJlYWQiLCJjcmVhdGVDb2RlYyIsImNvZGVjIiwiaXNGaXhlZFNpemUiLCJhc3NlcnRJc0ZpeGVkU2l6ZSIsImlzVmFyaWFibGVTaXplIiwiYXNzZXJ0SXNWYXJpYWJsZVNpemUiLCJjb21iaW5lQ29kZWMiLCJkZWNvZGVyRml4ZWRTaXplIiwiZW5jb2RlckZpeGVkU2l6ZSIsIm1heFNpemUiLCJkZWNvZGVyTWF4U2l6ZSIsImVuY29kZXJNYXhTaXplIiwiYWRkRW5jb2RlclNlbnRpbmVsIiwic2VudGluZWwiLCJlbmNvZGVyQnl0ZXMiLCJmaW5kU2VudGluZWxJbmRleCIsImVuY29kZWRCeXRlcyIsImhleEVuY29kZWRCeXRlcyIsImhleEJ5dGVzIiwiaGV4U2VudGluZWwiLCJhZGREZWNvZGVyU2VudGluZWwiLCJjYW5kaWRhdGVCeXRlcyIsInNlbnRpbmVsSW5kZXgiLCJkZWNvZGVkQnl0ZXMiLCJoZXhEZWNvZGVkQnl0ZXMiLCJwcmVTZW50aW5lbEJ5dGVzIiwiYWRkQ29kZWNTZW50aW5lbCIsImZpbmRJbmRleCIsImJ5dGUiLCJpbmRleCIsInN0ciIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMiLCJjb2RlY0Rlc2NyaXB0aW9uIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImV4cGVjdGVkIiwiYnl0ZXNMZW5ndGgiLCJhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UiLCJhZGRFbmNvZGVyU2l6ZVByZWZpeCIsInByZWZpeCIsInByZWZpeE1heFNpemUiLCJlbmNvZGVyU2l6ZSIsImFkZERlY29kZXJTaXplUHJlZml4IiwiYmlnaW50U2l6ZSIsImRlY29kZXJPZmZzZXQiLCJzaXplIiwiTnVtYmVyIiwiYWRkQ29kZWNTaXplUHJlZml4IiwiZml4RW5jb2RlclNpemUiLCJmaXhlZEJ5dGVzIiwidmFyaWFibGVCeXRlQXJyYXkiLCJmaXhlZEJ5dGVBcnJheSIsImZpeERlY29kZXJTaXplIiwiZml4Q29kZWNTaXplIiwib2Zmc2V0RW5jb2RlciIsImNvbmZpZyIsInByZU9mZnNldCIsIndyYXBCeXRlcyIsIm1vZHVsbyIsIm5ld1ByZU9mZnNldCIsInBvc3RPZmZzZXQiLCJuZXdQb3N0T2Zmc2V0Iiwib2Zmc2V0RGVjb2RlciIsIm9mZnNldENvZGVjIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwicmVzaXplRW5jb2RlciIsInJlc2l6ZSIsIm5ld1NpemUiLCJyZXNpemVEZWNvZGVyIiwicmVzaXplQ29kZWMiLCJwYWRMZWZ0RW5jb2RlciIsInBhZFJpZ2h0RW5jb2RlciIsInBhZExlZnREZWNvZGVyIiwicGFkUmlnaHREZWNvZGVyIiwicGFkTGVmdENvZGVjIiwicGFkUmlnaHRDb2RlYyIsImNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZSIsInNvdXJjZSIsInRhcmdldF9XSUxMX01VVEFURSIsInNvdXJjZU9mZnNldCIsInNvdXJjZUxlbmd0aCIsInRhcmdldE9mZnNldCIsImxlZnRWYWx1ZSIsInJldmVyc2VFbmNvZGVyIiwibmV3T2Zmc2V0IiwicmV2ZXJzZURlY29kZXIiLCJyZXZlcnNlZEJ5dGVzIiwicmV2ZXJzZUNvZGVjIiwidHJhbnNmb3JtRW5jb2RlciIsInVubWFwIiwidHJhbnNmb3JtRGVjb2RlciIsIm1hcCIsInRyYW5zZm9ybUNvZGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \*********************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(rsc)/./node_modules/.pnpm/@solana+errors@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS4zLjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwbkI7QUFFMW5CLDRCQUE0QjtBQUU1QixlQUFlO0FBQ2YsSUFBSVksYUFBYSxDQUFDQztJQUNoQixNQUFNQyxxQkFBcUJELFdBQVdFLE1BQU0sQ0FBQyxDQUFDQyxNQUFRQSxJQUFJQyxNQUFNO0lBQ2hFLElBQUlILG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0osV0FBV0ksTUFBTSxHQUFHSixVQUFVLENBQUMsRUFBRSxHQUFHLElBQUlLO0lBQ2pEO0lBQ0EsSUFBSUosbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSCxrQkFBa0IsQ0FBQyxFQUFFO0lBQzlCO0lBQ0EsTUFBTUssY0FBY0wsbUJBQW1CTSxNQUFNLENBQUMsQ0FBQ0MsT0FBT0wsTUFBUUssUUFBUUwsSUFBSUMsTUFBTSxFQUFFO0lBQ2xGLE1BQU1LLFNBQVMsSUFBSUosV0FBV0M7SUFDOUIsSUFBSUksU0FBUztJQUNiVCxtQkFBbUJVLE9BQU8sQ0FBQyxDQUFDUjtRQUMxQk0sT0FBT0csR0FBRyxDQUFDVCxLQUFLTztRQUNoQkEsVUFBVVAsSUFBSUMsTUFBTTtJQUN0QjtJQUNBLE9BQU9LO0FBQ1Q7QUFDQSxJQUFJSSxXQUFXLENBQUNDLE9BQU9WO0lBQ3JCLElBQUlVLE1BQU1WLE1BQU0sSUFBSUEsUUFBUSxPQUFPVTtJQUNuQyxNQUFNQyxjQUFjLElBQUlWLFdBQVdELFFBQVFZLElBQUksQ0FBQztJQUNoREQsWUFBWUgsR0FBRyxDQUFDRTtJQUNoQixPQUFPQztBQUNUO0FBQ0EsSUFBSUUsV0FBVyxDQUFDSCxPQUFPVixTQUFX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QUFRLElBQUlDLE9BQU87UUFDMUhPLE9BQU8sQ0FBQ1IsT0FBT1gsT0FBT0osU0FBV2dCLFFBQVFPLEtBQUssQ0FBQ2dHLE1BQU14RyxRQUFRWCxPQUFPSjtJQUN0RTtBQUNGO0FBQ0EsU0FBU3dILGlCQUFpQi9GLE9BQU8sRUFBRWdHLEdBQUc7SUFDcEMsT0FBT2pHLGNBQWM7UUFDbkIsR0FBR0MsT0FBTztRQUNWRSxNQUFNLENBQUN2QixPQUFPSjtZQUNaLE1BQU0sQ0FBQ2UsT0FBT21HLFVBQVUsR0FBR3pGLFFBQVFFLElBQUksQ0FBQ3ZCLE9BQU9KO1lBQy9DLE9BQU87Z0JBQUN5SCxJQUFJMUcsT0FBT1gsT0FBT0o7Z0JBQVNrSDthQUFVO1FBQy9DO0lBQ0Y7QUFDRjtBQUNBLFNBQVNRLGVBQWU3RixLQUFLLEVBQUUwRixLQUFLLEVBQUVFLEdBQUc7SUFDdkMsT0FBTzdGLFlBQVk7UUFDakIsR0FBRzBGLGlCQUFpQnpGLE9BQU8wRixNQUFNO1FBQ2pDNUYsTUFBTThGLE1BQU1ELGlCQUFpQjNGLE9BQU80RixLQUFLOUYsSUFBSSxHQUFHRSxNQUFNRixJQUFJO0lBQzVEO0FBQ0Y7QUFFdXZCLENBQ3Z2Qix1Q0FBdUM7Q0FDdkMsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJlc2FsZS13ZWIvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjAuMC1yYy4xX3R5cGVzY3JpcHRANS4zLjMvbm9kZV9tb2R1bGVzL0Bzb2xhbmEvY29kZWNzLWNvcmUvZGlzdC9pbmRleC5ub2RlLm1qcz80MzY5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYUVycm9yLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCBTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyB9IGZyb20gJ0Bzb2xhbmEvZXJyb3JzJztcblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuXG4vLyBzcmMvYnl0ZXMudHNcbnZhciBtZXJnZUJ5dGVzID0gKGJ5dGVBcnJheXMpID0+IHtcbiAgY29uc3Qgbm9uRW1wdHlCeXRlQXJyYXlzID0gYnl0ZUFycmF5cy5maWx0ZXIoKGFycikgPT4gYXJyLmxlbmd0aCk7XG4gIGlmIChub25FbXB0eUJ5dGVBcnJheXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ5dGVBcnJheXMubGVuZ3RoID8gYnl0ZUFycmF5c1swXSA6IG5ldyBVaW50OEFycmF5KCk7XG4gIH1cbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gbm9uRW1wdHlCeXRlQXJyYXlzWzBdO1xuICB9XG4gIGNvbnN0IHRvdGFsTGVuZ3RoID0gbm9uRW1wdHlCeXRlQXJyYXlzLnJlZHVjZSgodG90YWwsIGFycikgPT4gdG90YWwgKyBhcnIubGVuZ3RoLCAwKTtcbiAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgbm9uRW1wdHlCeXRlQXJyYXlzLmZvckVhY2goKGFycikgPT4ge1xuICAgIHJlc3VsdC5zZXQoYXJyLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBhcnIubGVuZ3RoO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgcGFkQnl0ZXMgPSAoYnl0ZXMsIGxlbmd0aCkgPT4ge1xuICBpZiAoYnl0ZXMubGVuZ3RoID49IGxlbmd0aCkgcmV0dXJuIGJ5dGVzO1xuICBjb25zdCBwYWRkZWRCeXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCkuZmlsbCgwKTtcbiAgcGFkZGVkQnl0ZXMuc2V0KGJ5dGVzKTtcbiAgcmV0dXJuIHBhZGRlZEJ5dGVzO1xufTtcbnZhciBmaXhCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiBwYWRCeXRlcyhieXRlcy5sZW5ndGggPD0gbGVuZ3RoID8gYnl0ZXMgOiBieXRlcy5zbGljZSgwLCBsZW5ndGgpLCBsZW5ndGgpO1xuZnVuY3Rpb24gY29udGFpbnNCeXRlcyhkYXRhLCBieXRlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHNsaWNlID0gb2Zmc2V0ID09PSAwICYmIGRhdGEubGVuZ3RoID09PSBieXRlcy5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVzLmxlbmd0aCk7XG4gIGlmIChzbGljZS5sZW5ndGggIT09IGJ5dGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYnl0ZXMuZXZlcnkoKGIsIGkpID0+IGIgPT09IHNsaWNlW2ldKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyKGVuY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpKTtcbiAgICAgIGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihkZWNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhjb2RlYykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uY29kZWMsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGNvZGVjLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGNvZGVjKSk7XG4gICAgICBjb2RlYy53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemUoY29kZWMpIHtcbiAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAhPT0gaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gpO1xuICB9XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLmZpeGVkU2l6ZSAhPT0gZGVjb2Rlci5maXhlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZW5jb2RlcixcbiAgICBkZWNvZGU6IGRlY29kZXIuZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgcmVhZDogZGVjb2Rlci5yZWFkLFxuICAgIHdyaXRlOiBlbmNvZGVyLndyaXRlXG4gIH07XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTZW50aW5lbChlbmNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAoZmluZFNlbnRpbmVsSW5kZXgoZW5jb2RlckJ5dGVzLCBzZW50aW5lbCkgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIHtcbiAgICAgICAgZW5jb2RlZEJ5dGVzOiBlbmNvZGVyQnl0ZXMsXG4gICAgICAgIGhleEVuY29kZWRCeXRlczogaGV4Qnl0ZXMoZW5jb2RlckJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChzZW50aW5lbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gc2VudGluZWwubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgd3JpdGUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4uZW5jb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGVuY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpICsgc2VudGluZWwubGVuZ3RoLFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsKGRlY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZUJ5dGVzID0gb2Zmc2V0ID09PSAwID8gYnl0ZXMgOiBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IHNlbnRpbmVsSW5kZXggPSBmaW5kU2VudGluZWxJbmRleChjYW5kaWRhdGVCeXRlcywgc2VudGluZWwpO1xuICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIHJlYWRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpLCBhZGREZWNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSk7XG59XG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlcywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChzZW50aW5lbC5sZW5ndGggPT09IDEpIHJldHVybiBieXRlID09PSBzZW50aW5lbFswXTtcbiAgICByZXR1cm4gY29udGFpbnNCeXRlcyhhcnIsIHNlbnRpbmVsLCBpbmRleCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgZXhwZWN0ZWQsIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoYnl0ZXNMZW5ndGggPCBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgZXhwZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKGNvZGVjRGVzY3JpcHRpb24sIG9mZnNldCwgYnl0ZXNMZW5ndGgpIHtcbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnl0ZXNMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4KGVuY29kZXIsIHByZWZpeCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBvZmZzZXQgPSBwcmVmaXgud3JpdGUoZW5jb2RlckJ5dGVzLmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyKGJpZ2ludFNpemUpO1xuICAgIG9mZnNldCA9IGRlY29kZXJPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiYWRkRGVjb2RlclNpemVQcmVmaXhcIiwgc2l6ZSwgYnl0ZXMpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGRlY29kZXIuZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IGRlY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBkZWNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBkZWNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXgoY29kZWMsIHByZWZpeCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpLCBhZGREZWNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSk7XG59XG5cbi8vIHNyYy9maXgtY29kZWMtc2l6ZS50c1xuZnVuY3Rpb24gZml4RW5jb2RlclNpemUoZW5jb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHZhcmlhYmxlQnl0ZUFycmF5ID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgICAgY29uc3QgZml4ZWRCeXRlQXJyYXkgPSB2YXJpYWJsZUJ5dGVBcnJheS5sZW5ndGggPiBmaXhlZEJ5dGVzID8gdmFyaWFibGVCeXRlQXJyYXkuc2xpY2UoMCwgZml4ZWRCeXRlcykgOiB2YXJpYWJsZUJ5dGVBcnJheTtcbiAgICAgIGJ5dGVzLnNldChmaXhlZEJ5dGVBcnJheSwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBvZmZzZXQgKyBmaXhlZEJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhEZWNvZGVyU2l6ZShkZWNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJmaXhDb2RlY1NpemVcIiwgZml4ZWRCeXRlcywgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBmaXhlZEJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBmaXhlZEJ5dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgICAgICBieXRlcyA9IGZpeEJ5dGVzKGJ5dGVzLCBkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBbdmFsdWVdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG9mZnNldCArIGZpeGVkQnl0ZXNdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBmaXhDb2RlY1NpemUoY29kZWMsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhmaXhFbmNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcyksIGZpeERlY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSk7XG59XG5cbi8vIHNyYy9vZmZzZXQtY29kZWMudHNcbmZ1bmN0aW9uIG9mZnNldEVuY29kZXIoZW5jb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcG9zdE9mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gbmV3UG9zdE9mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0RGVjb2RlcihkZWNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBwcmVPZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHdyYXBCeXRlcyA9IChvZmZzZXQpID0+IG1vZHVsbyhvZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBuZXdQcmVPZmZzZXQgPSBjb25maWcucHJlT2Zmc2V0ID8gY29uZmlnLnByZU9mZnNldCh7IGJ5dGVzLCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHByZU9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UHJlT2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgW3ZhbHVlLCBwb3N0T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3UG9zdE9mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldENvZGVjKGNvZGVjLCBjb25maWcpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhvZmZzZXRFbmNvZGVyKGNvZGVjLCBjb25maWcpLCBvZmZzZXREZWNvZGVyKGNvZGVjLCBjb25maWcpKTtcbn1cbmZ1bmN0aW9uIG1vZHVsbyhkaXZpZGVuZCwgZGl2aXNvcikge1xuICBpZiAoZGl2aXNvciA9PT0gMCkgcmV0dXJuIDA7XG4gIHJldHVybiAoZGl2aWRlbmQgJSBkaXZpc29yICsgZGl2aXNvcikgJSBkaXZpc29yO1xufVxuZnVuY3Rpb24gcmVzaXplRW5jb2RlcihlbmNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGVuY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgbmV3U2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpKTtcbiAgICAgIGlmIChuZXdTaXplIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgICAgYnl0ZXNMZW5ndGg6IG5ld1NpemUsXG4gICAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U2l6ZTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzaXplRGVjb2RlcihkZWNvZGVyLCByZXNpemUpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgY29uc3QgZml4ZWRTaXplID0gcmVzaXplKGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICBpZiAoZml4ZWRTaXplIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICBieXRlc0xlbmd0aDogZml4ZWRTaXplLFxuICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZURlY29kZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplIH0pO1xuICB9XG4gIHJldHVybiBkZWNvZGVyO1xufVxuZnVuY3Rpb24gcmVzaXplQ29kZWMoY29kZWMsIHJlc2l6ZSkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJlc2l6ZUVuY29kZXIoY29kZWMsIHJlc2l6ZSksIHJlc2l6ZURlY29kZXIoY29kZWMsIHJlc2l6ZSkpO1xufVxuXG4vLyBzcmMvcGFkLWNvZGVjLnRzXG5mdW5jdGlvbiBwYWRMZWZ0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwcmVPZmZzZXQ6ICh7IHByZU9mZnNldCB9KSA9PiBwcmVPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkUmlnaHREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHBvc3RPZmZzZXQ6ICh7IHBvc3RPZmZzZXQgfSkgPT4gcG9zdE9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRMZWZ0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZExlZnRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRMZWZ0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5mdW5jdGlvbiBwYWRSaWdodENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRSaWdodEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZFJpZ2h0RGVjb2Rlcihjb2RlYywgb2Zmc2V0KSk7XG59XG5cbi8vIHNyYy9yZXZlcnNlLWNvZGVjLnRzXG5mdW5jdGlvbiBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2Uoc291cmNlLCB0YXJnZXRfV0lMTF9NVVRBVEUsIHNvdXJjZU9mZnNldCwgc291cmNlTGVuZ3RoLCB0YXJnZXRPZmZzZXQgPSAwKSB7XG4gIHdoaWxlIChzb3VyY2VPZmZzZXQgPCAtLXNvdXJjZUxlbmd0aCkge1xuICAgIGNvbnN0IGxlZnRWYWx1ZSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZUxlbmd0aF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZUxlbmd0aCArIHRhcmdldE9mZnNldF0gPSBsZWZ0VmFsdWU7XG4gICAgc291cmNlT2Zmc2V0Kys7XG4gIH1cbiAgaWYgKHNvdXJjZU9mZnNldCA9PT0gc291cmNlTGVuZ3RoKSB7XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgfVxufVxuZnVuY3Rpb24gcmV2ZXJzZUVuY29kZXIoZW5jb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShlbmNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgbmV3T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG9mZnNldCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBieXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBlbmNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXdPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VEZWNvZGVyKGRlY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZGVjb2Rlcik7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCByZXZlcnNlZEJ5dGVzID0gYnl0ZXMuc2xpY2UoKTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIHJldmVyc2VkQnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZGVjb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gZGVjb2Rlci5yZWFkKHJldmVyc2VkQnl0ZXMsIG9mZnNldCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJldmVyc2VDb2RlYyhjb2RlYykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHJldmVyc2VFbmNvZGVyKGNvZGVjKSwgcmV2ZXJzZURlY29kZXIoY29kZWMpKTtcbn1cblxuLy8gc3JjL3RyYW5zZm9ybS1jb2RlYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtRW5jb2RlcihlbmNvZGVyLCB1bm1hcCkge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uaXNWYXJpYWJsZVNpemUoZW5jb2RlcikgPyB7IC4uLmVuY29kZXIsIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4gZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHVubWFwKHZhbHVlKSkgfSA6IGVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4gZW5jb2Rlci53cml0ZSh1bm1hcCh2YWx1ZSksIGJ5dGVzLCBvZmZzZXQpXG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtRGVjb2RlcihkZWNvZGVyLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgbmV3T2Zmc2V0XSA9IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBbbWFwKHZhbHVlLCBieXRlcywgb2Zmc2V0KSwgbmV3T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtQ29kZWMoY29kZWMsIHVubWFwLCBtYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUNvZGVjKHtcbiAgICAuLi50cmFuc2Zvcm1FbmNvZGVyKGNvZGVjLCB1bm1hcCksXG4gICAgcmVhZDogbWFwID8gdHJhbnNmb3JtRGVjb2Rlcihjb2RlYywgbWFwKS5yZWFkIDogY29kZWMucmVhZFxuICB9KTtcbn1cblxuZXhwb3J0IHsgYWRkQ29kZWNTZW50aW5lbCwgYWRkQ29kZWNTaXplUHJlZml4LCBhZGREZWNvZGVyU2VudGluZWwsIGFkZERlY29kZXJTaXplUHJlZml4LCBhZGRFbmNvZGVyU2VudGluZWwsIGFkZEVuY29kZXJTaXplUHJlZml4LCBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSwgYXNzZXJ0SXNGaXhlZFNpemUsIGFzc2VydElzVmFyaWFibGVTaXplLCBjb21iaW5lQ29kZWMsIGNvbnRhaW5zQnl0ZXMsIGNyZWF0ZUNvZGVjLCBjcmVhdGVEZWNvZGVyLCBjcmVhdGVFbmNvZGVyLCBmaXhCeXRlcywgZml4Q29kZWNTaXplLCBmaXhEZWNvZGVyU2l6ZSwgZml4RW5jb2RlclNpemUsIGdldEVuY29kZWRTaXplLCBpc0ZpeGVkU2l6ZSwgaXNWYXJpYWJsZVNpemUsIG1lcmdlQnl0ZXMsIG9mZnNldENvZGVjLCBvZmZzZXREZWNvZGVyLCBvZmZzZXRFbmNvZGVyLCBwYWRCeXRlcywgcGFkTGVmdENvZGVjLCBwYWRMZWZ0RGVjb2RlciwgcGFkTGVmdEVuY29kZXIsIHBhZFJpZ2h0Q29kZWMsIHBhZFJpZ2h0RGVjb2RlciwgcGFkUmlnaHRFbmNvZGVyLCByZXNpemVDb2RlYywgcmVzaXplRGVjb2RlciwgcmVzaXplRW5jb2RlciwgcmV2ZXJzZUNvZGVjLCByZXZlcnNlRGVjb2RlciwgcmV2ZXJzZUVuY29kZXIsIHRyYW5zZm9ybUNvZGVjLCB0cmFuc2Zvcm1EZWNvZGVyLCB0cmFuc2Zvcm1FbmNvZGVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXBcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcCJdLCJuYW1lcyI6WyJTb2xhbmFFcnJvciIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0NBTk5PVF9ERUNPREVfRU1QVFlfQllURV9BUlJBWSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUyIsIm1lcmdlQnl0ZXMiLCJieXRlQXJyYXlzIiwibm9uRW1wdHlCeXRlQXJyYXlzIiwiZmlsdGVyIiwiYXJyIiwibGVuZ3RoIiwiVWludDhBcnJheSIsInRvdGFsTGVuZ3RoIiwicmVkdWNlIiwidG90YWwiLCJyZXN1bHQiLCJvZmZzZXQiLCJmb3JFYWNoIiwic2V0IiwicGFkQnl0ZXMiLCJieXRlcyIsInBhZGRlZEJ5dGVzIiwiZmlsbCIsImZpeEJ5dGVzIiwic2xpY2UiLCJjb250YWluc0J5dGVzIiwiZGF0YSIsImV2ZXJ5IiwiYiIsImkiLCJnZXRFbmNvZGVkU2l6ZSIsInZhbHVlIiwiZW5jb2RlciIsImZpeGVkU2l6ZSIsImdldFNpemVGcm9tVmFsdWUiLCJjcmVhdGVFbmNvZGVyIiwiT2JqZWN0IiwiZnJlZXplIiwiZW5jb2RlIiwid3JpdGUiLCJjcmVhdGVEZWNvZGVyIiwiZGVjb2RlciIsImRlY29kZSIsInJlYWQiLCJjcmVhdGVDb2RlYyIsImNvZGVjIiwiaXNGaXhlZFNpemUiLCJhc3NlcnRJc0ZpeGVkU2l6ZSIsImlzVmFyaWFibGVTaXplIiwiYXNzZXJ0SXNWYXJpYWJsZVNpemUiLCJjb21iaW5lQ29kZWMiLCJkZWNvZGVyRml4ZWRTaXplIiwiZW5jb2RlckZpeGVkU2l6ZSIsIm1heFNpemUiLCJkZWNvZGVyTWF4U2l6ZSIsImVuY29kZXJNYXhTaXplIiwiYWRkRW5jb2RlclNlbnRpbmVsIiwic2VudGluZWwiLCJlbmNvZGVyQnl0ZXMiLCJmaW5kU2VudGluZWxJbmRleCIsImVuY29kZWRCeXRlcyIsImhleEVuY29kZWRCeXRlcyIsImhleEJ5dGVzIiwiaGV4U2VudGluZWwiLCJhZGREZWNvZGVyU2VudGluZWwiLCJjYW5kaWRhdGVCeXRlcyIsInNlbnRpbmVsSW5kZXgiLCJkZWNvZGVkQnl0ZXMiLCJoZXhEZWNvZGVkQnl0ZXMiLCJwcmVTZW50aW5lbEJ5dGVzIiwiYWRkQ29kZWNTZW50aW5lbCIsImZpbmRJbmRleCIsImJ5dGUiLCJpbmRleCIsInN0ciIsInRvU3RyaW5nIiwicGFkU3RhcnQiLCJhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMiLCJjb2RlY0Rlc2NyaXB0aW9uIiwiYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyIsImV4cGVjdGVkIiwiYnl0ZXNMZW5ndGgiLCJhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UiLCJhZGRFbmNvZGVyU2l6ZVByZWZpeCIsInByZWZpeCIsInByZWZpeE1heFNpemUiLCJlbmNvZGVyU2l6ZSIsImFkZERlY29kZXJTaXplUHJlZml4IiwiYmlnaW50U2l6ZSIsImRlY29kZXJPZmZzZXQiLCJzaXplIiwiTnVtYmVyIiwiYWRkQ29kZWNTaXplUHJlZml4IiwiZml4RW5jb2RlclNpemUiLCJmaXhlZEJ5dGVzIiwidmFyaWFibGVCeXRlQXJyYXkiLCJmaXhlZEJ5dGVBcnJheSIsImZpeERlY29kZXJTaXplIiwiZml4Q29kZWNTaXplIiwib2Zmc2V0RW5jb2RlciIsImNvbmZpZyIsInByZU9mZnNldCIsIndyYXBCeXRlcyIsIm1vZHVsbyIsIm5ld1ByZU9mZnNldCIsInBvc3RPZmZzZXQiLCJuZXdQb3N0T2Zmc2V0Iiwib2Zmc2V0RGVjb2RlciIsIm9mZnNldENvZGVjIiwiZGl2aWRlbmQiLCJkaXZpc29yIiwicmVzaXplRW5jb2RlciIsInJlc2l6ZSIsIm5ld1NpemUiLCJyZXNpemVEZWNvZGVyIiwicmVzaXplQ29kZWMiLCJwYWRMZWZ0RW5jb2RlciIsInBhZFJpZ2h0RW5jb2RlciIsInBhZExlZnREZWNvZGVyIiwicGFkUmlnaHREZWNvZGVyIiwicGFkTGVmdENvZGVjIiwicGFkUmlnaHRDb2RlYyIsImNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZSIsInNvdXJjZSIsInRhcmdldF9XSUxMX01VVEFURSIsInNvdXJjZU9mZnNldCIsInNvdXJjZUxlbmd0aCIsInRhcmdldE9mZnNldCIsImxlZnRWYWx1ZSIsInJldmVyc2VFbmNvZGVyIiwibmV3T2Zmc2V0IiwicmV2ZXJzZURlY29kZXIiLCJyZXZlcnNlZEJ5dGVzIiwicmV2ZXJzZUNvZGVjIiwidHJhbnNmb3JtRW5jb2RlciIsInVubWFwIiwidHJhbnNmb3JtRGVjb2RlciIsIm1hcCIsInRyYW5zZm9ybUNvZGVjIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@solana+codecs-core@2.0.0-rc.1_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ })

};
;