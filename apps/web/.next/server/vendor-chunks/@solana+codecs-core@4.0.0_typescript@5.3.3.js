"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-core@4.0.0_typescript@5.3.3";
exports.ids = ["vendor-chunks/@solana+codecs-core@4.0.0_typescript@5.3.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createDecoderThatConsumesEntireByteArray: () => (/* binding */ createDecoderThatConsumesEntireByteArray),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@4.0.0_typescript@5.3.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nfunction padBytes(bytes, length) {\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n}\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\nfunction createDecoderThatConsumesEntireByteArray(decoder) {\n    return createDecoder({\n        ...decoder,\n        read (bytes, offset) {\n            const [value, newOffset] = decoder.read(bytes, offset);\n            if (bytes.length > newOffset) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_DECODER_TO_CONSUME_ENTIRE_BYTE_ARRAY, {\n                    expectedLength: newOffset,\n                    numExcessBytes: bytes.length - newOffset\n                });\n            }\n            return [\n                value,\n                newOffset\n            ];\n        }\n    });\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUA0LjAuMF90eXBlc2NyaXB0QDUuMy4zL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStyQjtBQUUvckIsNEJBQTRCO0FBRTVCLGVBQWU7QUFDZixJQUFJYSxhQUFhLENBQUNDO0lBQ2hCLE1BQU1DLHFCQUFxQkQsV0FBV0UsTUFBTSxDQUFDLENBQUNDLE1BQVFBLElBQUlDLE1BQU07SUFDaEUsSUFBSUgsbUJBQW1CRyxNQUFNLEtBQUssR0FBRztRQUNuQyxPQUFPSixXQUFXSSxNQUFNLEdBQUdKLFVBQVUsQ0FBQyxFQUFFLEdBQUcsSUFBSUs7SUFDakQ7SUFDQSxJQUFJSixtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9ILGtCQUFrQixDQUFDLEVBQUU7SUFDOUI7SUFDQSxNQUFNSyxjQUFjTCxtQkFBbUJNLE1BQU0sQ0FBQyxDQUFDQyxPQUFPTCxNQUFRSyxRQUFRTCxJQUFJQyxNQUFNLEVBQUU7SUFDbEYsTUFBTUssU0FBUyxJQUFJSixXQUFXQztJQUM5QixJQUFJSSxTQUFTO0lBQ2JULG1CQUFtQlUsT0FBTyxDQUFDLENBQUNSO1FBQzFCTSxPQUFPRyxHQUFHLENBQUNULEtBQUtPO1FBQ2hCQSxVQUFVUCxJQUFJQyxNQUFNO0lBQ3RCO0lBQ0EsT0FBT0s7QUFDVDtBQUNBLFNBQVNJLFNBQVNDLEtBQUssRUFBRVYsTUFBTTtJQUM3QixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FB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ZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmErY29kZWNzLWNvcmVANC4wLjBfdHlwZXNjcmlwdEA1LjMuMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzP2VmMGYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0RFQ09ERVJfVE9fQ09OU1VNRV9FTlRJUkVfQllURV9BUlJBWSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5cbi8vIHNyYy9ieXRlcy50c1xudmFyIG1lcmdlQnl0ZXMgPSAoYnl0ZUFycmF5cykgPT4ge1xuICBjb25zdCBub25FbXB0eUJ5dGVBcnJheXMgPSBieXRlQXJyYXlzLmZpbHRlcigoYXJyKSA9PiBhcnIubGVuZ3RoKTtcbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnl0ZUFycmF5cy5sZW5ndGggPyBieXRlQXJyYXlzWzBdIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub25FbXB0eUJ5dGVBcnJheXNbMF07XG4gIH1cbiAgY29uc3QgdG90YWxMZW5ndGggPSBub25FbXB0eUJ5dGVBcnJheXMucmVkdWNlKCh0b3RhbCwgYXJyKSA9PiB0b3RhbCArIGFyci5sZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBub25FbXB0eUJ5dGVBcnJheXMuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbmZ1bmN0aW9uIHBhZEJ5dGVzKGJ5dGVzLCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBieXRlcztcbiAgY29uc3QgcGFkZGVkQnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpLmZpbGwoMCk7XG4gIHBhZGRlZEJ5dGVzLnNldChieXRlcyk7XG4gIHJldHVybiBwYWRkZWRCeXRlcztcbn1cbnZhciBmaXhCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiBwYWRCeXRlcyhieXRlcy5sZW5ndGggPD0gbGVuZ3RoID8gYnl0ZXMgOiBieXRlcy5zbGljZSgwLCBsZW5ndGgpLCBsZW5ndGgpO1xuZnVuY3Rpb24gY29udGFpbnNCeXRlcyhkYXRhLCBieXRlcywgb2Zmc2V0KSB7XG4gIGNvbnN0IHNsaWNlID0gb2Zmc2V0ID09PSAwICYmIGRhdGEubGVuZ3RoID09PSBieXRlcy5sZW5ndGggPyBkYXRhIDogZGF0YS5zbGljZShvZmZzZXQsIG9mZnNldCArIGJ5dGVzLmxlbmd0aCk7XG4gIGlmIChzbGljZS5sZW5ndGggIT09IGJ5dGVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gYnl0ZXMuZXZlcnkoKGIsIGkpID0+IGIgPT09IHNsaWNlW2ldKTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kZWRTaXplKHZhbHVlLCBlbmNvZGVyKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGVuY29kZXIgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbmNvZGVyKGVuY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpKTtcbiAgICAgIGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCAwKTtcbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVjb2RlcihkZWNvZGVyKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIGRlY29kZTogKGJ5dGVzLCBvZmZzZXQgPSAwKSA9PiBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldClbMF1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDb2RlYyhjb2RlYykge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uY29kZWMsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGNvZGVjLnJlYWQoYnl0ZXMsIG9mZnNldClbMF0sXG4gICAgZW5jb2RlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoZ2V0RW5jb2RlZFNpemUodmFsdWUsIGNvZGVjKSk7XG4gICAgICBjb2RlYy53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBpc0ZpeGVkU2l6ZShjb2RlYykge1xuICByZXR1cm4gXCJmaXhlZFNpemVcIiBpbiBjb2RlYyAmJiB0eXBlb2YgY29kZWMuZml4ZWRTaXplID09PSBcIm51bWJlclwiO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNGaXhlZFNpemUoY29kZWMpIHtcbiAgaWYgKCFpc0ZpeGVkU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzVmFyaWFibGVTaXplKGNvZGVjKSB7XG4gIHJldHVybiAhaXNGaXhlZFNpemUoY29kZWMpO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgaWYgKCFpc1ZhcmlhYmxlU2l6ZShjb2RlYykpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbWJpbmVDb2RlYyhlbmNvZGVyLCBkZWNvZGVyKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAhPT0gaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9TSVpFX0NPTVBBVElCSUxJVFlfTUlTTUFUQ0gpO1xuICB9XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLmZpeGVkU2l6ZSAhPT0gZGVjb2Rlci5maXhlZFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyRml4ZWRTaXplOiBkZWNvZGVyLmZpeGVkU2l6ZSxcbiAgICAgIGVuY29kZXJGaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplXG4gICAgfSk7XG4gIH1cbiAgaWYgKCFpc0ZpeGVkU2l6ZShlbmNvZGVyKSAmJiAhaXNGaXhlZFNpemUoZGVjb2RlcikgJiYgZW5jb2Rlci5tYXhTaXplICE9PSBkZWNvZGVyLm1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCwge1xuICAgICAgZGVjb2Rlck1heFNpemU6IGRlY29kZXIubWF4U2l6ZSxcbiAgICAgIGVuY29kZXJNYXhTaXplOiBlbmNvZGVyLm1heFNpemVcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZW5jb2RlcixcbiAgICBkZWNvZGU6IGRlY29kZXIuZGVjb2RlLFxuICAgIGVuY29kZTogZW5jb2Rlci5lbmNvZGUsXG4gICAgcmVhZDogZGVjb2Rlci5yZWFkLFxuICAgIHdyaXRlOiBlbmNvZGVyLndyaXRlXG4gIH07XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2VudGluZWwudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTZW50aW5lbChlbmNvZGVyLCBzZW50aW5lbCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBpZiAoZmluZFNlbnRpbmVsSW5kZXgoZW5jb2RlckJ5dGVzLCBzZW50aW5lbCkgPj0gMCkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVEX0JZVEVTX01VU1RfTk9UX0lOQ0xVREVfU0VOVElORUwsIHtcbiAgICAgICAgZW5jb2RlZEJ5dGVzOiBlbmNvZGVyQnl0ZXMsXG4gICAgICAgIGhleEVuY29kZWRCeXRlczogaGV4Qnl0ZXMoZW5jb2RlckJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICAgIGJ5dGVzLnNldChzZW50aW5lbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gc2VudGluZWwubGVuZ3RoO1xuICAgIHJldHVybiBvZmZzZXQ7XG4gIH07XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBlbmNvZGVyLmZpeGVkU2l6ZSArIHNlbnRpbmVsLmxlbmd0aCwgd3JpdGUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgLi4uZW5jb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGVuY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodmFsdWUpICsgc2VudGluZWwubGVuZ3RoLFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNlbnRpbmVsKGRlY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGNhbmRpZGF0ZUJ5dGVzID0gb2Zmc2V0ID09PSAwID8gYnl0ZXMgOiBieXRlcy5zbGljZShvZmZzZXQpO1xuICAgIGNvbnN0IHNlbnRpbmVsSW5kZXggPSBmaW5kU2VudGluZWxJbmRleChjYW5kaWRhdGVCeXRlcywgc2VudGluZWwpO1xuICAgIGlmIChzZW50aW5lbEluZGV4ID09PSAtMSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMsIHtcbiAgICAgICAgZGVjb2RlZEJ5dGVzOiBjYW5kaWRhdGVCeXRlcyxcbiAgICAgICAgaGV4RGVjb2RlZEJ5dGVzOiBoZXhCeXRlcyhjYW5kaWRhdGVCeXRlcyksXG4gICAgICAgIGhleFNlbnRpbmVsOiBoZXhCeXRlcyhzZW50aW5lbCksXG4gICAgICAgIHNlbnRpbmVsXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcHJlU2VudGluZWxCeXRlcyA9IGNhbmRpZGF0ZUJ5dGVzLnNsaWNlKDAsIHNlbnRpbmVsSW5kZXgpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUocHJlU2VudGluZWxCeXRlcyksIG9mZnNldCArIHByZVNlbnRpbmVsQnl0ZXMubGVuZ3RoICsgc2VudGluZWwubGVuZ3RoXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCByZWFkIH0pO1xuICB9XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIC4uLmRlY29kZXIubWF4U2l6ZSAhPSBudWxsID8geyBtYXhTaXplOiBkZWNvZGVyLm1heFNpemUgKyBzZW50aW5lbC5sZW5ndGggfSA6IHt9LFxuICAgIHJlYWRcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpLCBhZGREZWNvZGVyU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSk7XG59XG5mdW5jdGlvbiBmaW5kU2VudGluZWxJbmRleChieXRlcywgc2VudGluZWwpIHtcbiAgcmV0dXJuIGJ5dGVzLmZpbmRJbmRleCgoYnl0ZSwgaW5kZXgsIGFycikgPT4ge1xuICAgIGlmIChzZW50aW5lbC5sZW5ndGggPT09IDEpIHJldHVybiBieXRlID09PSBzZW50aW5lbFswXTtcbiAgICByZXR1cm4gY29udGFpbnNCeXRlcyhhcnIsIHNlbnRpbmVsLCBpbmRleCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgcmV0dXJuIGJ5dGVzLnJlZHVjZSgoc3RyLCBieXRlKSA9PiBzdHIgKyBieXRlLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIiksIFwiXCIpO1xufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjKGNvZGVjRGVzY3JpcHRpb24sIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGlmIChieXRlcy5sZW5ndGggLSBvZmZzZXQgPD0gMCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZLCB7XG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgZXhwZWN0ZWQsIGJ5dGVzLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IGJ5dGVzTGVuZ3RoID0gYnl0ZXMubGVuZ3RoIC0gb2Zmc2V0O1xuICBpZiAoYnl0ZXNMZW5ndGggPCBleHBlY3RlZCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgZXhwZWN0ZWRcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKGNvZGVjRGVzY3JpcHRpb24sIG9mZnNldCwgYnl0ZXNMZW5ndGgpIHtcbiAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnl0ZXNMZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX09GRlNFVF9PVVRfT0ZfUkFOR0UsIHtcbiAgICAgIGJ5dGVzTGVuZ3RoLFxuICAgICAgY29kZWNEZXNjcmlwdGlvbixcbiAgICAgIG9mZnNldFxuICAgIH0pO1xuICB9XG59XG5cbi8vIHNyYy9hZGQtY29kZWMtc2l6ZS1wcmVmaXgudHNcbmZ1bmN0aW9uIGFkZEVuY29kZXJTaXplUHJlZml4KGVuY29kZXIsIHByZWZpeCkge1xuICBjb25zdCB3cml0ZSA9ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGVuY29kZXJCeXRlcyA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICBvZmZzZXQgPSBwcmVmaXgud3JpdGUoZW5jb2RlckJ5dGVzLmxlbmd0aCwgYnl0ZXMsIG9mZnNldCk7XG4gICAgYnl0ZXMuc2V0KGVuY29kZXJCeXRlcywgb2Zmc2V0KTtcbiAgICByZXR1cm4gb2Zmc2V0ICsgZW5jb2RlckJ5dGVzLmxlbmd0aDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGVuY29kZXIuZml4ZWRTaXplLCB3cml0ZSB9KTtcbiAgfVxuICBjb25zdCBwcmVmaXhNYXhTaXplID0gaXNGaXhlZFNpemUocHJlZml4KSA/IHByZWZpeC5maXhlZFNpemUgOiBwcmVmaXgubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBlbmNvZGVyTWF4U2l6ZSA9IGlzRml4ZWRTaXplKGVuY29kZXIpID8gZW5jb2Rlci5maXhlZFNpemUgOiBlbmNvZGVyLm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgbWF4U2l6ZSA9IHByZWZpeE1heFNpemUgIT09IG51bGwgJiYgZW5jb2Rlck1heFNpemUgIT09IG51bGwgPyBwcmVmaXhNYXhTaXplICsgZW5jb2Rlck1heFNpemUgOiBudWxsO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGVuY29kZXJTaXplID0gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpO1xuICAgICAgcmV0dXJuIGdldEVuY29kZWRTaXplKGVuY29kZXJTaXplLCBwcmVmaXgpICsgZW5jb2RlclNpemU7XG4gICAgfSxcbiAgICB3cml0ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZERlY29kZXJTaXplUHJlZml4KGRlY29kZXIsIHByZWZpeCkge1xuICBjb25zdCByZWFkID0gKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBbYmlnaW50U2l6ZSwgZGVjb2Rlck9mZnNldF0gPSBwcmVmaXgucmVhZChieXRlcywgb2Zmc2V0KTtcbiAgICBjb25zdCBzaXplID0gTnVtYmVyKGJpZ2ludFNpemUpO1xuICAgIG9mZnNldCA9IGRlY29kZXJPZmZzZXQ7XG4gICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIHNpemUpO1xuICAgIH1cbiAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiYWRkRGVjb2RlclNpemVQcmVmaXhcIiwgc2l6ZSwgYnl0ZXMpO1xuICAgIHJldHVybiBbZGVjb2Rlci5kZWNvZGUoYnl0ZXMpLCBvZmZzZXQgKyBzaXplXTtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKHByZWZpeCkgJiYgaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogcHJlZml4LmZpeGVkU2l6ZSArIGRlY29kZXIuZml4ZWRTaXplLCByZWFkIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGRlY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZGVjb2RlcikgPyBkZWNvZGVyLmZpeGVkU2l6ZSA6IGRlY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBkZWNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBkZWNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgLi4ubWF4U2l6ZSAhPT0gbnVsbCA/IHsgbWF4U2l6ZSB9IDoge30sIHJlYWQgfSk7XG59XG5mdW5jdGlvbiBhZGRDb2RlY1NpemVQcmVmaXgoY29kZWMsIHByZWZpeCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGFkZEVuY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpLCBhZGREZWNvZGVyU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyVGhhdENvbnN1bWVzRW50aXJlQnl0ZUFycmF5KGRlY29kZXIpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZChieXRlcywgb2Zmc2V0KSB7XG4gICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICBpZiAoYnl0ZXMubGVuZ3RoID4gbmV3T2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfREVDT0RFUl9UT19DT05TVU1FX0VOVElSRV9CWVRFX0FSUkFZLCB7XG4gICAgICAgICAgZXhwZWN0ZWRMZW5ndGg6IG5ld09mZnNldCxcbiAgICAgICAgICBudW1FeGNlc3NCeXRlczogYnl0ZXMubGVuZ3RoIC0gbmV3T2Zmc2V0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt2YWx1ZSwgbmV3T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzcmMvZml4LWNvZGVjLXNpemUudHNcbmZ1bmN0aW9uIGZpeEVuY29kZXJTaXplKGVuY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB2YXJpYWJsZUJ5dGVBcnJheSA9IGVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICAgIGNvbnN0IGZpeGVkQnl0ZUFycmF5ID0gdmFyaWFibGVCeXRlQXJyYXkubGVuZ3RoID4gZml4ZWRCeXRlcyA/IHZhcmlhYmxlQnl0ZUFycmF5LnNsaWNlKDAsIGZpeGVkQnl0ZXMpIDogdmFyaWFibGVCeXRlQXJyYXk7XG4gICAgICBieXRlcy5zZXQoZml4ZWRCeXRlQXJyYXksIG9mZnNldCk7XG4gICAgICByZXR1cm4gb2Zmc2V0ICsgZml4ZWRCeXRlcztcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4RGVjb2RlclNpemUoZGVjb2RlciwgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgZml4ZWRTaXplOiBmaXhlZEJ5dGVzLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjKFwiZml4Q29kZWNTaXplXCIsIGZpeGVkQnl0ZXMsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgaWYgKG9mZnNldCA+IDAgfHwgYnl0ZXMubGVuZ3RoID4gZml4ZWRCeXRlcykge1xuICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgZml4ZWRCeXRlcyk7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICAgICAgYnl0ZXMgPSBmaXhCeXRlcyhieXRlcywgZGVjb2Rlci5maXhlZFNpemUpO1xuICAgICAgfVxuICAgICAgY29uc3QgW3ZhbHVlXSA9IGRlY29kZXIucmVhZChieXRlcywgMCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBvZmZzZXQgKyBmaXhlZEJ5dGVzXTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZml4Q29kZWNTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoZml4RW5jb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpLCBmaXhEZWNvZGVyU2l6ZShjb2RlYywgZml4ZWRCeXRlcykpO1xufVxuXG4vLyBzcmMvb2Zmc2V0LWNvZGVjLnRzXG5mdW5jdGlvbiBvZmZzZXRFbmNvZGVyKGVuY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXRFbmNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHBvc3RPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgbmV3UHJlT2Zmc2V0KTtcbiAgICAgIGNvbnN0IG5ld1Bvc3RPZmZzZXQgPSBjb25maWcucG9zdE9mZnNldCA/IGNvbmZpZy5wb3N0T2Zmc2V0KHsgYnl0ZXMsIG5ld1ByZU9mZnNldCwgcG9zdE9mZnNldCwgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwb3N0T2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQb3N0T2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIG5ld1Bvc3RPZmZzZXQ7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIG9mZnNldERlY29kZXIoZGVjb2RlciwgY29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgcHJlT2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCB3cmFwQnl0ZXMgPSAob2Zmc2V0KSA9PiBtb2R1bG8ob2Zmc2V0LCBieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgbmV3UHJlT2Zmc2V0ID0gY29uZmlnLnByZU9mZnNldCA/IGNvbmZpZy5wcmVPZmZzZXQoeyBieXRlcywgcHJlT2Zmc2V0LCB3cmFwQnl0ZXMgfSkgOiBwcmVPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1ByZU9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IFt2YWx1ZSwgcG9zdE9mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldERlY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdmFsdWUsIG5ld1Bvc3RPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXRDb2RlYyhjb2RlYywgY29uZmlnKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMob2Zmc2V0RW5jb2Rlcihjb2RlYywgY29uZmlnKSwgb2Zmc2V0RGVjb2Rlcihjb2RlYywgY29uZmlnKSk7XG59XG5mdW5jdGlvbiBtb2R1bG8oZGl2aWRlbmQsIGRpdmlzb3IpIHtcbiAgaWYgKGRpdmlzb3IgPT09IDApIHJldHVybiAwO1xuICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShlbmNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVFbmNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7IC4uLmVuY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IG5ld1NpemUgPSByZXNpemUoZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKSk7XG4gICAgICBpZiAobmV3U2l6ZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCwge1xuICAgICAgICAgIGJ5dGVzTGVuZ3RoOiBuZXdTaXplLFxuICAgICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1NpemU7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgcmVzaXplKSB7XG4gIGlmIChpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIGNvbnN0IGZpeGVkU2l6ZSA9IHJlc2l6ZShkZWNvZGVyLmZpeGVkU2l6ZSk7XG4gICAgaWYgKGZpeGVkU2l6ZSA8IDApIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgYnl0ZXNMZW5ndGg6IGZpeGVkU2l6ZSxcbiAgICAgICAgY29kZWNEZXNjcmlwdGlvbjogXCJyZXNpemVEZWNvZGVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZSB9KTtcbiAgfVxuICByZXR1cm4gZGVjb2Rlcjtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUNvZGVjKGNvZGVjLCByZXNpemUpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXNpemVFbmNvZGVyKGNvZGVjLCByZXNpemUpLCByZXNpemVEZWNvZGVyKGNvZGVjLCByZXNpemUpKTtcbn1cblxuLy8gc3JjL3BhZC1jb2RlYy50c1xuZnVuY3Rpb24gcGFkTGVmdEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RW5jb2RlcihlbmNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldEVuY29kZXIoXG4gICAgcmVzaXplRW5jb2RlcihlbmNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcHJlT2Zmc2V0OiAoeyBwcmVPZmZzZXQgfSkgPT4gcHJlT2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0RGVjb2RlcihkZWNvZGVyLCBvZmZzZXQpIHtcbiAgcmV0dXJuIG9mZnNldERlY29kZXIoXG4gICAgcmVzaXplRGVjb2RlcihkZWNvZGVyLCAoc2l6ZSkgPT4gc2l6ZSArIG9mZnNldCksXG4gICAgeyBwb3N0T2Zmc2V0OiAoeyBwb3N0T2Zmc2V0IH0pID0+IHBvc3RPZmZzZXQgKyBvZmZzZXQgfVxuICApO1xufVxuZnVuY3Rpb24gcGFkTGVmdENvZGVjKGNvZGVjLCBvZmZzZXQpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhwYWRMZWZ0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkTGVmdERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuZnVuY3Rpb24gcGFkUmlnaHRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkUmlnaHRFbmNvZGVyKGNvZGVjLCBvZmZzZXQpLCBwYWRSaWdodERlY29kZXIoY29kZWMsIG9mZnNldCkpO1xufVxuXG4vLyBzcmMvcmV2ZXJzZS1jb2RlYy50c1xuZnVuY3Rpb24gY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKHNvdXJjZSwgdGFyZ2V0X1dJTExfTVVUQVRFLCBzb3VyY2VPZmZzZXQsIHNvdXJjZUxlbmd0aCwgdGFyZ2V0T2Zmc2V0ID0gMCkge1xuICB3aGlsZSAoc291cmNlT2Zmc2V0IDwgLS1zb3VyY2VMZW5ndGgpIHtcbiAgICBjb25zdCBsZWZ0VmFsdWUgPSBzb3VyY2Vbc291cmNlT2Zmc2V0XTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VMZW5ndGhdO1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VMZW5ndGggKyB0YXJnZXRPZmZzZXRdID0gbGVmdFZhbHVlO1xuICAgIHNvdXJjZU9mZnNldCsrO1xuICB9XG4gIGlmIChzb3VyY2VPZmZzZXQgPT09IHNvdXJjZUxlbmd0aCkge1xuICAgIHRhcmdldF9XSUxMX01VVEFURVtzb3VyY2VPZmZzZXQgKyB0YXJnZXRPZmZzZXRdID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gIH1cbn1cbmZ1bmN0aW9uIHJldmVyc2VFbmNvZGVyKGVuY29kZXIpIHtcbiAgYXNzZXJ0SXNGaXhlZFNpemUoZW5jb2Rlcik7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IG5ld09mZnNldCA9IGVuY29kZXIud3JpdGUodmFsdWUsIGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIG9mZnNldCxcbiAgICAgICAgb2Zmc2V0ICsgZW5jb2Rlci5maXhlZFNpemVcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlRGVjb2RlcihkZWNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGRlY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgcmV2ZXJzZWRCeXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgICBjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UoXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICByZXZlcnNlZEJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGRlY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIGRlY29kZXIucmVhZChyZXZlcnNlZEJ5dGVzLCBvZmZzZXQpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXZlcnNlQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvbWJpbmVDb2RlYyhyZXZlcnNlRW5jb2Rlcihjb2RlYyksIHJldmVyc2VEZWNvZGVyKGNvZGVjKSk7XG59XG5cbi8vIHNyYy90cmFuc2Zvcm0tY29kZWMudHNcbmZ1bmN0aW9uIHRyYW5zZm9ybUVuY29kZXIoZW5jb2RlciwgdW5tYXApIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmlzVmFyaWFibGVTaXplKGVuY29kZXIpID8geyAuLi5lbmNvZGVyLCBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh1bm1hcCh2YWx1ZSkpIH0gOiBlbmNvZGVyLFxuICAgIHdyaXRlOiAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpID0+IGVuY29kZXIud3JpdGUodW5tYXAodmFsdWUpLCBieXRlcywgb2Zmc2V0KVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybURlY29kZXIoZGVjb2RlciwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVEZWNvZGVyKHtcbiAgICAuLi5kZWNvZGVyLFxuICAgIHJlYWQ6IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBbdmFsdWUsIG5ld09mZnNldF0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gW21hcCh2YWx1ZSwgYnl0ZXMsIG9mZnNldCksIG5ld09mZnNldF07XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUNvZGVjKGNvZGVjLCB1bm1hcCwgbWFwKSB7XG4gIHJldHVybiBjcmVhdGVDb2RlYyh7XG4gICAgLi4udHJhbnNmb3JtRW5jb2Rlcihjb2RlYywgdW5tYXApLFxuICAgIHJlYWQ6IG1hcCA/IHRyYW5zZm9ybURlY29kZXIoY29kZWMsIG1hcCkucmVhZCA6IGNvZGVjLnJlYWRcbiAgfSk7XG59XG5cbmV4cG9ydCB7IGFkZENvZGVjU2VudGluZWwsIGFkZENvZGVjU2l6ZVByZWZpeCwgYWRkRGVjb2RlclNlbnRpbmVsLCBhZGREZWNvZGVyU2l6ZVByZWZpeCwgYWRkRW5jb2RlclNlbnRpbmVsLCBhZGRFbmNvZGVyU2l6ZVByZWZpeCwgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5SXNOb3RFbXB0eUZvckNvZGVjLCBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UsIGFzc2VydElzRml4ZWRTaXplLCBhc3NlcnRJc1ZhcmlhYmxlU2l6ZSwgY29tYmluZUNvZGVjLCBjb250YWluc0J5dGVzLCBjcmVhdGVDb2RlYywgY3JlYXRlRGVjb2RlciwgY3JlYXRlRGVjb2RlclRoYXRDb25zdW1lc0VudGlyZUJ5dGVBcnJheSwgY3JlYXRlRW5jb2RlciwgZml4Qnl0ZXMsIGZpeENvZGVjU2l6ZSwgZml4RGVjb2RlclNpemUsIGZpeEVuY29kZXJTaXplLCBnZXRFbmNvZGVkU2l6ZSwgaXNGaXhlZFNpemUsIGlzVmFyaWFibGVTaXplLCBtZXJnZUJ5dGVzLCBvZmZzZXRDb2RlYywgb2Zmc2V0RGVjb2Rlciwgb2Zmc2V0RW5jb2RlciwgcGFkQnl0ZXMsIHBhZExlZnRDb2RlYywgcGFkTGVmdERlY29kZXIsIHBhZExlZnRFbmNvZGVyLCBwYWRSaWdodENvZGVjLCBwYWRSaWdodERlY29kZXIsIHBhZFJpZ2h0RW5jb2RlciwgcmVzaXplQ29kZWMsIHJlc2l6ZURlY29kZXIsIHJlc2l6ZUVuY29kZXIsIHJldmVyc2VDb2RlYywgcmV2ZXJzZURlY29kZXIsIHJldmVyc2VFbmNvZGVyLCB0cmFuc2Zvcm1Db2RlYywgdHJhbnNmb3JtRGVjb2RlciwgdHJhbnNmb3JtRW5jb2RlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5ub2RlLm1qcy5tYXAiXSwibmFtZXMiOlsiU29sYW5hRXJyb3IiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1ZBUklBQkxFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9GSVhFRF9TSVpFX01JU01BVENIIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERVJfREVDT0RFUl9NQVhfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVkiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fSU5WQUxJRF9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19PRkZTRVRfT1VUX09GX1JBTkdFIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0RFQ09ERVJfVE9fQ09OU1VNRV9FTlRJUkVfQllURV9BUlJBWSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwibWVyZ2VCeXRlcyIsImJ5dGVBcnJheXMiLCJub25FbXB0eUJ5dGVBcnJheXMiLCJmaWx0ZXIiLCJhcnIiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJ0b3RhbCIsInJlc3VsdCIsIm9mZnNldCIsImZvckVhY2giLCJzZXQiLCJwYWRCeXRlcyIsImJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJmaWxsIiwiZml4Qnl0ZXMiLCJzbGljZSIsImNvbnRhaW5zQnl0ZXMiLCJkYXRhIiwiZXZlcnkiLCJiIiwiaSIsImdldEVuY29kZWRTaXplIiwidmFsdWUiLCJlbmNvZGVyIiwiZml4ZWRTaXplIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImNyZWF0ZUVuY29kZXIiLCJPYmplY3QiLCJmcmVlemUiLCJlbmNvZGUiLCJ3cml0ZSIsImNyZWF0ZURlY29kZXIiLCJkZWNvZGVyIiwiZGVjb2RlIiwicmVhZCIsImNyZWF0ZUNvZGVjIiwiY29kZWMiLCJpc0ZpeGVkU2l6ZSIsImFzc2VydElzRml4ZWRTaXplIiwiaXNWYXJpYWJsZVNpemUiLCJhc3NlcnRJc1ZhcmlhYmxlU2l6ZSIsImNvbWJpbmVDb2RlYyIsImRlY29kZXJGaXhlZFNpemUiLCJlbmNvZGVyRml4ZWRTaXplIiwibWF4U2l6ZSIsImRlY29kZXJNYXhTaXplIiwiZW5jb2Rlck1heFNpemUiLCJhZGRFbmNvZGVyU2VudGluZWwiLCJzZW50aW5lbCIsImVuY29kZXJCeXRlcyIsImZpbmRTZW50aW5lbEluZGV4IiwiZW5jb2RlZEJ5dGVzIiwiaGV4RW5jb2RlZEJ5dGVzIiwiaGV4Qnl0ZXMiLCJoZXhTZW50aW5lbCIsImFkZERlY29kZXJTZW50aW5lbCIsImNhbmRpZGF0ZUJ5dGVzIiwic2VudGluZWxJbmRleCIsImRlY29kZWRCeXRlcyIsImhleERlY29kZWRCeXRlcyIsInByZVNlbnRpbmVsQnl0ZXMiLCJhZGRDb2RlY1NlbnRpbmVsIiwiZmluZEluZGV4IiwiYnl0ZSIsImluZGV4Iiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiZXhwZWN0ZWQiLCJieXRlc0xlbmd0aCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsImFkZEVuY29kZXJTaXplUHJlZml4IiwicHJlZml4IiwicHJlZml4TWF4U2l6ZSIsImVuY29kZXJTaXplIiwiYWRkRGVjb2RlclNpemVQcmVmaXgiLCJiaWdpbnRTaXplIiwiZGVjb2Rlck9mZnNldCIsInNpemUiLCJOdW1iZXIiLCJhZGRDb2RlY1NpemVQcmVmaXgiLCJjcmVhdGVEZWNvZGVyVGhhdENvbnN1bWVzRW50aXJlQnl0ZUFycmF5IiwibmV3T2Zmc2V0IiwiZXhwZWN0ZWRMZW5ndGgiLCJudW1FeGNlc3NCeXRlcyIsImZpeEVuY29kZXJTaXplIiwiZml4ZWRCeXRlcyIsInZhcmlhYmxlQnl0ZUFycmF5IiwiZml4ZWRCeXRlQXJyYXkiLCJmaXhEZWNvZGVyU2l6ZSIsImZpeENvZGVjU2l6ZSIsIm9mZnNldEVuY29kZXIiLCJjb25maWciLCJwcmVPZmZzZXQiLCJ3cmFwQnl0ZXMiLCJtb2R1bG8iLCJuZXdQcmVPZmZzZXQiLCJwb3N0T2Zmc2V0IiwibmV3UG9zdE9mZnNldCIsIm9mZnNldERlY29kZXIiLCJvZmZzZXRDb2RlYyIsImRpdmlkZW5kIiwiZGl2aXNvciIsInJlc2l6ZUVuY29kZXIiLCJyZXNpemUiLCJuZXdTaXplIiwicmVzaXplRGVjb2RlciIsInJlc2l6ZUNvZGVjIiwicGFkTGVmdEVuY29kZXIiLCJwYWRSaWdodEVuY29kZXIiLCJwYWRMZWZ0RGVjb2RlciIsInBhZFJpZ2h0RGVjb2RlciIsInBhZExlZnRDb2RlYyIsInBhZFJpZ2h0Q29kZWMiLCJjb3B5U291cmNlVG9UYXJnZXRJblJldmVyc2UiLCJzb3VyY2UiLCJ0YXJnZXRfV0lMTF9NVVRBVEUiLCJzb3VyY2VPZmZzZXQiLCJzb3VyY2VMZW5ndGgiLCJ0YXJnZXRPZmZzZXQiLCJsZWZ0VmFsdWUiLCJyZXZlcnNlRW5jb2RlciIsInJldmVyc2VEZWNvZGVyIiwicmV2ZXJzZWRCeXRlcyIsInJldmVyc2VDb2RlYyIsInRyYW5zZm9ybUVuY29kZXIiLCJ1bm1hcCIsInRyYW5zZm9ybURlY29kZXIiLCJtYXAiLCJ0cmFuc2Zvcm1Db2RlYyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-core@4.0.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ })

};
;