"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/borsh@0.7.0";
exports.ids = ["vendor-chunks/borsh@0.7.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (void 0) && (void 0).__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(ssr)/./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"));\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(__webpack_require__(/*! text-encoding-utf-8 */ \"(ssr)/./node_modules/.pnpm/text-encoding-utf-8@1.0.2/node_modules/text-encoding-utf-8/lib/encoding.lib.js\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n    fatal: true\n});\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message){\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor(){\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([\n                this.buf,\n                Buffer.alloc(INITIAL_LENGTH)\n            ]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH)\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array){\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function(...args) {\n        try {\n            return originalMethod.apply(this, args);\n        } catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\n                    \"ERR_BUFFER_OUT_OF_BOUNDS\",\n                    \"ERR_OUT_OF_RANGE\"\n                ].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf){\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        } catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for(let i = 0; i < len; ++i){\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        } else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for(let i = 0; i < fieldType[1]; i++){\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            } else {\n                writer.writeArray(value, (item)=>{\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        } else if (fieldType.kind !== undefined) {\n            switch(fieldType.kind){\n                case \"option\":\n                    {\n                        if (value === null || value === undefined) {\n                            writer.writeU8(0);\n                        } else {\n                            writer.writeU8(1);\n                            serializeField(schema, fieldName, value, fieldType.type, writer);\n                        }\n                        break;\n                    }\n                case \"map\":\n                    {\n                        writer.writeU32(value.size);\n                        value.forEach((val, key)=>{\n                            serializeField(schema, fieldName, key, fieldType.key, writer);\n                            serializeField(schema, fieldName, val, fieldType.value, writer);\n                        });\n                        break;\n                    }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        } else {\n            serializeStruct(schema, value, writer);\n        }\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType])=>{\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    } else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for(let idx = 0; idx < structSchema.values.length; ++idx){\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    } else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            } else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for(let i = 0; i < fieldType[1]; i++){\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            } else {\n                return reader.readArray(()=>deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for(let i = 0; i < length; i++){\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields){\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({\n            [fieldName]: fieldValue\n        });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yc2hAMC43LjAvbm9kZV9tb2R1bGVzL2JvcnNoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JKLE9BQU9PLGNBQWMsQ0FBQ0wsR0FBR0csSUFBSTtRQUFFRyxZQUFZO1FBQU1DLEtBQUs7WUFBYSxPQUFPTixDQUFDLENBQUNDLEVBQUU7UUFBRTtJQUFFO0FBQ3RGLElBQU0sU0FBU0YsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSU0scUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1WLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVTLENBQUM7SUFDekZYLE9BQU9PLGNBQWMsQ0FBQ0wsR0FBRyxXQUFXO1FBQUVNLFlBQVk7UUFBTUksT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNULENBQUMsRUFBRVMsQ0FBQztJQUNkVCxDQUFDLENBQUMsVUFBVSxHQUFHUztBQUNuQjtBQUNBLElBQUlFLGFBQWEsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxVQUFVLElBQUssU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUNqRixJQUFJQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVDLElBQUlILElBQUksSUFBSUgsU0FBU0UsU0FBUyxPQUFPQSxPQUFPakIsT0FB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QU94RTtBQUNYO0FBQ0FJLG1CQUFtQixHQUFHRTtBQUN0QixpRkFBaUY7QUFDakYsU0FBU0QscUJBQXFCNkYsTUFBTSxFQUFFNEIsU0FBUyxFQUFFMUUsTUFBTSxFQUFFNkUsU0FBU3pILFlBQVk7SUFDMUUsTUFBTWdILFNBQVMsSUFBSVMsT0FBTzdFO0lBQzFCLE9BQU95RSxrQkFBa0IzQixRQUFRNEIsV0FBV047QUFDaEQ7QUFDQXBILDRCQUE0QixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2JvcnNoQDAuNy4wL25vZGVfbW9kdWxlcy9ib3JzaC9saWIvaW5kZXguanM/NDkxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlc2VyaWFsaXplVW5jaGVja2VkID0gZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5CaW5hcnlSZWFkZXIgPSBleHBvcnRzLkJpbmFyeVdyaXRlciA9IGV4cG9ydHMuQm9yc2hFcnJvciA9IGV4cG9ydHMuYmFzZURlY29kZSA9IGV4cG9ydHMuYmFzZUVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGJzNThfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnM1OFwiKSk7XG4vLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBwb2x5ZmlsbCBub3QgaW5jbHVkZWQgd2hlbiBub3QgcmVxdWlyZWRcbmNvbnN0IGVuY29kaW5nID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0ZXh0LWVuY29kaW5nLXV0Zi04XCIpKTtcbmNvbnN0IFJlc29sdmVkVGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwiZnVuY3Rpb25cIiA/IGVuY29kaW5nLlRleHREZWNvZGVyIDogVGV4dERlY29kZXI7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBSZXNvbHZlZFRleHREZWNvZGVyKFwidXRmLThcIiwgeyBmYXRhbDogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGJhc2VFbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJzNThfMS5kZWZhdWx0LmVuY29kZShCdWZmZXIuZnJvbSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbmZ1bmN0aW9uIGJhc2VEZWNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnM1OF8xLmRlZmF1bHQuZGVjb2RlKHZhbHVlKSk7XG59XG5leHBvcnRzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuY29uc3QgSU5JVElBTF9MRU5HVEggPSAxMDI0O1xuY2xhc3MgQm9yc2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLmZpZWxkUGF0aC5zcGxpY2UoMCwgMCwgZmllbGROYW1lKTtcbiAgICAgICAgLy8gTk9URTogTW9kaWZ5aW5nIG1lc3NhZ2UgZGlyZWN0bHkgYXMgamVzdCBkb2Vzbid0IHVzZSAudG9TdHJpbmcoKVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm9yaWdpbmFsTWVzc2FnZSArIFwiOiBcIiArIHRoaXMuZmllbGRQYXRoLmpvaW4oXCIuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9yc2hFcnJvciA9IEJvcnNoRXJyb3I7XG4vLy8gQmluYXJ5IGVuY29kZXIuXG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvYyhJTklUSUFMX0xFTkdUSCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgbWF5YmVSZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGggPCAxNiArIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmLCBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVVOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDgodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG4gICAgd3JpdGVVMTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQxNkxFKHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIHdyaXRlVTMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSA0O1xuICAgIH1cbiAgICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDgpKSk7XG4gICAgfVxuICAgIHdyaXRlVTEyOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDE2KSkpO1xuICAgIH1cbiAgICB3cml0ZVUyNTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCAzMikpKTtcbiAgICB9XG4gICAgd3JpdGVVNTEyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgNjQpKSk7XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAvLyBCdWZmZXIuZnJvbSBpcyBuZWVkZWQgYXMgdGhpcy5idWYuc3ViYXJyYXkgY2FuIHJldHVybiBwbGFpbiBVaW50OEFycmF5IGluIGJyb3dzZXJcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKSksXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihiKTtcbiAgICB9XG4gICAgd3JpdGVGaXhlZEFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20oYXJyYXkpKTtcbiAgICB9XG4gICAgd3JpdGVBcnJheShhcnJheSwgZm4pIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICAgICAgZm4oZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeVdyaXRlciA9IEJpbmFyeVdyaXRlcjtcbmZ1bmN0aW9uIGhhbmRsaW5nUmFuZ2VFcnJvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHByb3BlcnR5RGVzY3JpcHRvci52YWx1ZTtcbiAgICBwcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGlmIChbXCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFNcIiwgXCJFUlJfT1VUX09GX1JBTkdFXCJdLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihcIlJlYWNoZWQgdGhlIGVuZCBvZiBidWZmZXIgd2hlbiBkZXNlcmlhbGl6aW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYpIHtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmVhZFU4KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFUxNigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDE2TEUodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVMzIoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTY0KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUxMjgoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigxNik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUyNTYoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigzMik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFU1MTIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcig2NCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZEJ1ZmZlcihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ICsgbGVuID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0ZWQgYnVmZmVyIGxlbmd0aCAke2xlbn0gaXNuJ3Qgd2l0aGluIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVhZFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcihsZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTk9URTogVXNpbmcgVGV4dERlY29kZXIgdG8gZmFpbCBvbiBpbnZhbGlkIFVURi04XG4gICAgICAgICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFcnJvciBkZWNvZGluZyBVVEYtOCBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkRml4ZWRBcnJheShsZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMucmVhZEJ1ZmZlcihsZW4pKTtcbiAgICB9XG4gICAgcmVhZEFycmF5KGZuKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVThcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxNlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTMyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVNjRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxMjhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUyNTZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU1MTJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFN0cmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkRml4ZWRBcnJheVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkQXJyYXlcIiwgbnVsbCk7XG5leHBvcnRzLkJpbmFyeVJlYWRlciA9IEJpbmFyeVJlYWRlcjtcbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUsIHdyaXRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBtaXNzaW5nIHZhbHVlcyBwcm9wZXJseSAobWFrZSBzdXJlIHRoZXkgbmV2ZXIgcmVzdWx0IGluIGp1c3Qgc2tpcHBlZCB3cml0ZSlcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdyaXRlcltgd3JpdGUke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBmaWVsZFR5cGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGluZyBieXRlIGFycmF5IG9mIGxlbmd0aCAke2ZpZWxkVHlwZVswXX0sIGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUZpeGVkQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgZmllbGRUeXBlWzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gZmllbGRUeXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtmaWVsZFR5cGVbMV19LCBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgbnVsbCwgdmFsdWVbaV0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVBcnJheSh2YWx1ZSwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGl0ZW0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUua2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUudHlwZSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBrZXksIGZpZWxkVHlwZS5rZXksIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgdmFsLCBmaWVsZFR5cGUudmFsdWUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEZpZWxkVHlwZSAke2ZpZWxkVHlwZX0gdW5yZWNvZ25pemVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCB2YWx1ZSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQm9yc2hFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuYWRkVG9GaWVsZFBhdGgoZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcikge1xuICAgIGlmICh0eXBlb2Ygb2JqLmJvcnNoU2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqLmJvcnNoU2VyaWFsaXplKHdyaXRlcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChvYmouY29uc3RydWN0b3IpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke29iai5jb25zdHJ1Y3Rvci5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgc3RydWN0U2NoZW1hLmZpZWxkcy5tYXAoKFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0pID0+IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBvYmpbZmllbGROYW1lXSwgZmllbGRUeXBlLCB3cml0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmpbc3RydWN0U2NoZW1hLmZpZWxkXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3RydWN0U2NoZW1hLnZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KGlkeCk7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIG9ialtmaWVsZE5hbWVdLCBmaWVsZFR5cGUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkIHNjaGVtYSBraW5kOiAke3N0cnVjdFNjaGVtYS5raW5kfSBmb3IgJHtvYmouY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG59XG4vLy8gU2VyaWFsaXplIGdpdmVuIG9iamVjdCB1c2luZyBzY2hlbWEgb2YgdGhlIGZvcm06XG4vLy8geyBjbGFzc19uYW1lIC0+IFsgW2ZpZWxkX25hbWUsIGZpZWxkX3R5cGVdLCAuLiBdLCAuLiB9XG5mdW5jdGlvbiBzZXJpYWxpemUoc2NoZW1hLCBvYmosIFdyaXRlciA9IEJpbmFyeVdyaXRlcikge1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcik7XG4gICAgcmV0dXJuIHdyaXRlci50b0FycmF5KCk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkZXJbYHJlYWQke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZVswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZpeGVkQXJyYXkoZmllbGRUeXBlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBudWxsLCBmaWVsZFR5cGVbMF0sIHJlYWRlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQXJyYXkoKCkgPT4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlWzBdLCByZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlLmtpbmQgPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLnR5cGUsIHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUua2luZCA9PT0gXCJtYXBcIikge1xuICAgICAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLmtleSwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUudmFsdWUsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJvcnNoRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcikge1xuICAgIGlmICh0eXBlb2YgY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChjbGFzc1R5cGUpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke2NsYXNzVHlwZS5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSBvZiBzY2hlbWEuZ2V0KGNsYXNzVHlwZSkuZmllbGRzKSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZShyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgaWYgKGlkeCA+PSBzdHJ1Y3RTY2hlbWEudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEVudW0gaW5kZXg6ICR7aWR4fSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLCByZWFkZXIpO1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtzdHJ1Y3RTY2hlbWEua2luZH0gZm9yICR7Y2xhc3NUeXBlLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG59XG4vLy8gRGVzZXJpYWxpemVzIG9iamVjdCBmcm9tIGJ5dGVzIHVzaW5nIHNjaGVtYS5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNjaGVtYSwgY2xhc3NUeXBlLCBidWZmZXIsIFJlYWRlciA9IEJpbmFyeVJlYWRlcikge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbiAgICBpZiAocmVhZGVyLm9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgJHtidWZmZXIubGVuZ3RoIC0gcmVhZGVyLm9mZnNldH0gYnl0ZXMgYWZ0ZXIgZGVzZXJpYWxpemVkIGRhdGFgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbi8vLyBEZXNlcmlhbGl6ZXMgb2JqZWN0IGZyb20gYnl0ZXMgdXNpbmcgc2NoZW1hLCB3aXRob3V0IGNoZWNraW5nIHRoZSBsZW5ndGggcmVhZFxuZnVuY3Rpb24gZGVzZXJpYWxpemVVbmNoZWNrZWQoc2NoZW1hLCBjbGFzc1R5cGUsIGJ1ZmZlciwgUmVhZGVyID0gQmluYXJ5UmVhZGVyKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBkZXNlcmlhbGl6ZVVuY2hlY2tlZDtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2VzTW9kdWxlIiwicmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsImRlc2VyaWFsaXplVW5jaGVja2VkIiwiZGVzZXJpYWxpemUiLCJzZXJpYWxpemUiLCJCaW5hcnlSZWFkZXIiLCJCaW5hcnlXcml0ZXIiLCJCb3JzaEVycm9yIiwiYmFzZURlY29kZSIsImJhc2VFbmNvZGUiLCJibl9qc18xIiwicmVxdWlyZSIsImJzNThfMSIsImVuY29kaW5nIiwiUmVzb2x2ZWRUZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwidGV4dERlY29kZXIiLCJmYXRhbCIsIkJ1ZmZlciIsImZyb20iLCJkZWZhdWx0IiwiZW5jb2RlIiwiZGVjb2RlIiwiSU5JVElBTF9MRU5HVEgiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImZpZWxkUGF0aCIsIm9yaWdpbmFsTWVzc2FnZSIsImFkZFRvRmllbGRQYXRoIiwiZmllbGROYW1lIiwic3BsaWNlIiwiam9pbiIsImJ1ZiIsImFsbG9jIiwibWF5YmVSZXNpemUiLCJjb25jYXQiLCJ3cml0ZVU4Iiwid3JpdGVVSW50OCIsIndyaXRlVTE2Iiwid3JpdGVVSW50MTZMRSIsIndyaXRlVTMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVTY0Iiwid3JpdGVCdWZmZXIiLCJ0b0FycmF5Iiwid3JpdGVVMTI4Iiwid3JpdGVVMjU2Iiwid3JpdGVVNTEyIiwiYnVmZmVyIiwic3ViYXJyYXkiLCJ3cml0ZVN0cmluZyIsInN0ciIsImIiLCJ3cml0ZUZpeGVkQXJyYXkiLCJhcnJheSIsIndyaXRlQXJyYXkiLCJmbiIsImVsZW0iLCJoYW5kbGluZ1JhbmdlRXJyb3IiLCJwcm9wZXJ0eUtleSIsInByb3BlcnR5RGVzY3JpcHRvciIsIm9yaWdpbmFsTWV0aG9kIiwiYXJncyIsImFwcGx5IiwiZSIsIlJhbmdlRXJyb3IiLCJjb2RlIiwiaW5kZXhPZiIsIm9mZnNldCIsInJlYWRVOCIsInJlYWRVSW50OCIsInJlYWRVMTYiLCJyZWFkVUludDE2TEUiLCJyZWFkVTMyIiwicmVhZFVJbnQzMkxFIiwicmVhZFU2NCIsInJlYWRCdWZmZXIiLCJyZWFkVTEyOCIsInJlYWRVMjU2IiwicmVhZFU1MTIiLCJsZW4iLCJzbGljZSIsInJlYWRTdHJpbmciLCJyZWFkRml4ZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJyZWFkQXJyYXkiLCJBcnJheSIsInB1c2giLCJwcm90b3R5cGUiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNlcmlhbGl6ZUZpZWxkIiwic2NoZW1hIiwiZmllbGRUeXBlIiwid3JpdGVyIiwiaXRlbSIsImtpbmQiLCJ0eXBlIiwic2l6ZSIsImZvckVhY2giLCJ2YWwiLCJzZXJpYWxpemVTdHJ1Y3QiLCJlcnJvciIsIm9iaiIsImJvcnNoU2VyaWFsaXplIiwic3RydWN0U2NoZW1hIiwibmFtZSIsImZpZWxkcyIsIm1hcCIsImZpZWxkIiwiaWR4IiwidmFsdWVzIiwiV3JpdGVyIiwiZGVzZXJpYWxpemVGaWVsZCIsInJlYWRlciIsImFyciIsIm9wdGlvbiIsIk1hcCIsInNldCIsImRlc2VyaWFsaXplU3RydWN0IiwiY2xhc3NUeXBlIiwiYm9yc2hEZXNlcmlhbGl6ZSIsImZpZWxkVmFsdWUiLCJSZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nvar __createBinding = (void 0) && (void 0).__createBinding || (Object.create ? function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, {\n        enumerable: true,\n        get: function() {\n            return m[k];\n        }\n    });\n} : function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n});\nvar __setModuleDefault = (void 0) && (void 0).__setModuleDefault || (Object.create ? function(o, v) {\n    Object.defineProperty(o, \"default\", {\n        enumerable: true,\n        value: v\n    });\n} : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (void 0) && (void 0).__decorate || function(decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (void 0) && (void 0).__importStar || function(mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) {\n        for(var k in mod)if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    }\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (void 0) && (void 0).__importDefault || function(mod) {\n    return mod && mod.__esModule ? mod : {\n        \"default\": mod\n    };\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"));\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"(rsc)/./node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(__webpack_require__(/*! text-encoding-utf-8 */ \"(rsc)/./node_modules/.pnpm/text-encoding-utf-8@1.0.2/node_modules/text-encoding-utf-8/lib/encoding.lib.js\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", {\n    fatal: true\n});\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message){\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor(){\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([\n                this.buf,\n                Buffer.alloc(INITIAL_LENGTH)\n            ]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH)\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array){\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function(...args) {\n        try {\n            return originalMethod.apply(this, args);\n        } catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\n                    \"ERR_BUFFER_OUT_OF_BOUNDS\",\n                    \"ERR_OUT_OF_RANGE\"\n                ].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf){\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        } catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for(let i = 0; i < len; ++i){\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        } else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for(let i = 0; i < fieldType[1]; i++){\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            } else {\n                writer.writeArray(value, (item)=>{\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        } else if (fieldType.kind !== undefined) {\n            switch(fieldType.kind){\n                case \"option\":\n                    {\n                        if (value === null || value === undefined) {\n                            writer.writeU8(0);\n                        } else {\n                            writer.writeU8(1);\n                            serializeField(schema, fieldName, value, fieldType.type, writer);\n                        }\n                        break;\n                    }\n                case \"map\":\n                    {\n                        writer.writeU32(value.size);\n                        value.forEach((val, key)=>{\n                            serializeField(schema, fieldName, key, fieldType.key, writer);\n                            serializeField(schema, fieldName, val, fieldType.value, writer);\n                        });\n                        break;\n                    }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        } else {\n            serializeStruct(schema, value, writer);\n        }\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType])=>{\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    } else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for(let idx = 0; idx < structSchema.values.length; ++idx){\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    } else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            } else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for(let i = 0; i < fieldType[1]; i++){\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            } else {\n                return reader.readArray(()=>deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for(let i = 0; i < length; i++){\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    } catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields){\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({\n            [fieldName]: fieldValue\n        });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYm9yc2hAMC43LjAvbm9kZV9tb2R1bGVzL2JvcnNoL2xpYi9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLGtCQUFrQixDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLGVBQWUsSUFBTUMsQ0FBQUEsT0FBT0MsTUFBTSxHQUFJLFNBQVNDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEVBQUU7SUFDMUYsSUFBSUEsT0FBT0MsV0FBV0QsS0FBS0Q7SUFDM0JKLE9BQU9PLGNBQWMsQ0FBQ0wsR0FBR0csSUFBSTtRQUFFRyxZQUFZO1FBQU1DLEtBQUs7WUFBYSxPQUFPTixDQUFDLENBQUNDLEVBQUU7UUFBRTtJQUFFO0FBQ3RGLElBQU0sU0FBU0YsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRUMsRUFBRTtJQUN0QixJQUFJQSxPQUFPQyxXQUFXRCxLQUFLRDtJQUMzQkYsQ0FBQyxDQUFDRyxHQUFHLEdBQUdGLENBQUMsQ0FBQ0MsRUFBRTtBQUNoQixDQUFDO0FBQ0QsSUFBSU0scUJBQXFCLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsa0JBQWtCLElBQU1WLENBQUFBLE9BQU9DLE1BQU0sR0FBSSxTQUFTQyxDQUFDLEVBQUVTLENBQUM7SUFDekZYLE9BQU9PLGNBQWMsQ0FBQ0wsR0FBRyxXQUFXO1FBQUVNLFlBQVk7UUFBTUksT0FBT0Q7SUFBRTtBQUNyRSxJQUFLLFNBQVNULENBQUMsRUFBRVMsQ0FBQztJQUNkVCxDQUFDLENBQUMsVUFBVSxHQUFHUztBQUNuQjtBQUNBLElBQUlFLGFBQWEsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxVQUFVLElBQUssU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLEdBQUcsRUFBRUMsSUFBSTtJQUNqRixJQUFJQyxJQUFJQyxVQUFVQyxNQUFNLEVBQUVDLElBQUlILElBQUksSUFBSUgsU0FBU0UsU0FBUyxPQUFPQSxPQUFPakIsT0FB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QU94RTtBQUNYO0FBQ0FJLG1CQUFtQixHQUFHRTtBQUN0QixpRkFBaUY7QUFDakYsU0FBU0QscUJBQXFCNkYsTUFBTSxFQUFFNEIsU0FBUyxFQUFFMUUsTUFBTSxFQUFFNkUsU0FBU3pILFlBQVk7SUFDMUUsTUFBTWdILFNBQVMsSUFBSVMsT0FBTzdFO0lBQzFCLE9BQU95RSxrQkFBa0IzQixRQUFRNEIsV0FBV047QUFDaEQ7QUFDQXBILDRCQUE0QixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2JvcnNoQDAuNy4wL25vZGVfbW9kdWxlcy9ib3JzaC9saWIvaW5kZXguanM/NDkxOCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlc2VyaWFsaXplVW5jaGVja2VkID0gZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGV4cG9ydHMuc2VyaWFsaXplID0gZXhwb3J0cy5CaW5hcnlSZWFkZXIgPSBleHBvcnRzLkJpbmFyeVdyaXRlciA9IGV4cG9ydHMuQm9yc2hFcnJvciA9IGV4cG9ydHMuYmFzZURlY29kZSA9IGV4cG9ydHMuYmFzZUVuY29kZSA9IHZvaWQgMDtcbmNvbnN0IGJuX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJuLmpzXCIpKTtcbmNvbnN0IGJzNThfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYnM1OFwiKSk7XG4vLyBUT0RPOiBNYWtlIHN1cmUgdGhpcyBwb2x5ZmlsbCBub3QgaW5jbHVkZWQgd2hlbiBub3QgcmVxdWlyZWRcbmNvbnN0IGVuY29kaW5nID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJ0ZXh0LWVuY29kaW5nLXV0Zi04XCIpKTtcbmNvbnN0IFJlc29sdmVkVGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgIT09IFwiZnVuY3Rpb25cIiA/IGVuY29kaW5nLlRleHREZWNvZGVyIDogVGV4dERlY29kZXI7XG5jb25zdCB0ZXh0RGVjb2RlciA9IG5ldyBSZXNvbHZlZFRleHREZWNvZGVyKFwidXRmLThcIiwgeyBmYXRhbDogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGJhc2VFbmNvZGUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gQnVmZmVyLmZyb20odmFsdWUsIFwidXRmOFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGJzNThfMS5kZWZhdWx0LmVuY29kZShCdWZmZXIuZnJvbSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5iYXNlRW5jb2RlID0gYmFzZUVuY29kZTtcbmZ1bmN0aW9uIGJhc2VEZWNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnM1OF8xLmRlZmF1bHQuZGVjb2RlKHZhbHVlKSk7XG59XG5leHBvcnRzLmJhc2VEZWNvZGUgPSBiYXNlRGVjb2RlO1xuY29uc3QgSU5JVElBTF9MRU5HVEggPSAxMDI0O1xuY2xhc3MgQm9yc2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmZpZWxkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLm9yaWdpbmFsTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIGFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSkge1xuICAgICAgICB0aGlzLmZpZWxkUGF0aC5zcGxpY2UoMCwgMCwgZmllbGROYW1lKTtcbiAgICAgICAgLy8gTk9URTogTW9kaWZ5aW5nIG1lc3NhZ2UgZGlyZWN0bHkgYXMgamVzdCBkb2Vzbid0IHVzZSAudG9TdHJpbmcoKVxuICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLm9yaWdpbmFsTWVzc2FnZSArIFwiOiBcIiArIHRoaXMuZmllbGRQYXRoLmpvaW4oXCIuXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9yc2hFcnJvciA9IEJvcnNoRXJyb3I7XG4vLy8gQmluYXJ5IGVuY29kZXIuXG5jbGFzcyBCaW5hcnlXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvYyhJTklUSUFMX0xFTkdUSCk7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgbWF5YmVSZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGggPCAxNiArIHRoaXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW3RoaXMuYnVmLCBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVVOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDgodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMTtcbiAgICB9XG4gICAgd3JpdGVVMTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQxNkxFKHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDI7XG4gICAgfVxuICAgIHdyaXRlVTMyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSA0O1xuICAgIH1cbiAgICB3cml0ZVU2NCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDgpKSk7XG4gICAgfVxuICAgIHdyaXRlVTEyOCh2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDE2KSkpO1xuICAgIH1cbiAgICB3cml0ZVUyNTYodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCAzMikpKTtcbiAgICB9XG4gICAgd3JpdGVVNTEyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgNjQpKSk7XG4gICAgfVxuICAgIHdyaXRlQnVmZmVyKGJ1ZmZlcikge1xuICAgICAgICAvLyBCdWZmZXIuZnJvbSBpcyBuZWVkZWQgYXMgdGhpcy5idWYuc3ViYXJyYXkgY2FuIHJldHVybiBwbGFpbiBVaW50OEFycmF5IGluIGJyb3dzZXJcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgICAgICAgIEJ1ZmZlci5mcm9tKHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKSksXG4gICAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgICBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gYnVmZmVyLmxlbmd0aDtcbiAgICB9XG4gICAgd3JpdGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgY29uc3QgYiA9IEJ1ZmZlci5mcm9tKHN0ciwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihiKTtcbiAgICB9XG4gICAgd3JpdGVGaXhlZEFycmF5KGFycmF5KSB7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20oYXJyYXkpKTtcbiAgICB9XG4gICAgd3JpdGVBcnJheShhcnJheSwgZm4pIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlVTMyKGFycmF5Lmxlbmd0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbSBvZiBhcnJheSkge1xuICAgICAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICAgICAgZm4oZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9BcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9XG59XG5leHBvcnRzLkJpbmFyeVdyaXRlciA9IEJpbmFyeVdyaXRlcjtcbmZ1bmN0aW9uIGhhbmRsaW5nUmFuZ2VFcnJvcih0YXJnZXQsIHByb3BlcnR5S2V5LCBwcm9wZXJ0eURlc2NyaXB0b3IpIHtcbiAgICBjb25zdCBvcmlnaW5hbE1ldGhvZCA9IHByb3BlcnR5RGVzY3JpcHRvci52YWx1ZTtcbiAgICBwcm9wZXJ0eURlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJhbmdlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gZS5jb2RlO1xuICAgICAgICAgICAgICAgIGlmIChbXCJFUlJfQlVGRkVSX09VVF9PRl9CT1VORFNcIiwgXCJFUlJfT1VUX09GX1JBTkdFXCJdLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihcIlJlYWNoZWQgdGhlIGVuZCBvZiBidWZmZXIgd2hlbiBkZXNlcmlhbGl6aW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICB9O1xufVxuY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWYpIHtcbiAgICAgICAgdGhpcy5idWYgPSBidWY7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgcmVhZFU4KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50OCh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDE7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFUxNigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDE2TEUodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAyO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVMzIoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQzMkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gNDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTY0KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoOCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUxMjgoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigxNik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFUyNTYoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcigzMik7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZFU1MTIoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcig2NCk7XG4gICAgICAgIHJldHVybiBuZXcgYm5fanNfMS5kZWZhdWx0KGJ1ZiwgXCJsZVwiKTtcbiAgICB9XG4gICAgcmVhZEJ1ZmZlcihsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0ICsgbGVuID4gdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0ZWQgYnVmZmVyIGxlbmd0aCAke2xlbn0gaXNuJ3Qgd2l0aGluIGJvdW5kc2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYnVmLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGxlbik7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmVhZFN0cmluZygpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcihsZW4pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTk9URTogVXNpbmcgVGV4dERlY29kZXIgdG8gZmFpbCBvbiBpbnZhbGlkIFVURi04XG4gICAgICAgICAgICByZXR1cm4gdGV4dERlY29kZXIuZGVjb2RlKGJ1Zik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFcnJvciBkZWNvZGluZyBVVEYtOCBzdHJpbmc6ICR7ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkRml4ZWRBcnJheShsZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMucmVhZEJ1ZmZlcihsZW4pKTtcbiAgICB9XG4gICAgcmVhZEFycmF5KGZuKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBBcnJheSgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbigpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVThcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxNlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTMyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVNjRcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUxMjhcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUyNTZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU1MTJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFN0cmluZ1wiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkRml4ZWRBcnJheVwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkQXJyYXlcIiwgbnVsbCk7XG5leHBvcnRzLkJpbmFyeVJlYWRlciA9IEJpbmFyeVJlYWRlcjtcbmZ1bmN0aW9uIGNhcGl0YWxpemVGaXJzdExldHRlcihzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgc3RyaW5nLnNsaWNlKDEpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUsIHdyaXRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFRPRE86IEhhbmRsZSBtaXNzaW5nIHZhbHVlcyBwcm9wZXJseSAobWFrZSBzdXJlIHRoZXkgbmV2ZXIgcmVzdWx0IGluIGp1c3Qgc2tpcHBlZCB3cml0ZSlcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHdyaXRlcltgd3JpdGUke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBmaWVsZFR5cGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGluZyBieXRlIGFycmF5IG9mIGxlbmd0aCAke2ZpZWxkVHlwZVswXX0sIGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUZpeGVkQXJyYXkodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlLmxlbmd0aCA9PT0gMiAmJiB0eXBlb2YgZmllbGRUeXBlWzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gZmllbGRUeXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtmaWVsZFR5cGVbMV19LCBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgbnVsbCwgdmFsdWVbaV0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVBcnJheSh2YWx1ZSwgKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGl0ZW0sIGZpZWxkVHlwZVswXSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUua2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOCgwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbHVlLCBmaWVsZFR5cGUudHlwZSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1hcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVUzMih2YWx1ZS5zaXplKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaCgodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBrZXksIGZpZWxkVHlwZS5rZXksIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgdmFsLCBmaWVsZFR5cGUudmFsdWUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEZpZWxkVHlwZSAke2ZpZWxkVHlwZX0gdW5yZWNvZ25pemVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCB2YWx1ZSwgd3JpdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQm9yc2hFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuYWRkVG9GaWVsZFBhdGgoZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcikge1xuICAgIGlmICh0eXBlb2Ygb2JqLmJvcnNoU2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgb2JqLmJvcnNoU2VyaWFsaXplKHdyaXRlcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChvYmouY29uc3RydWN0b3IpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke29iai5jb25zdHJ1Y3Rvci5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgc3RydWN0U2NoZW1hLmZpZWxkcy5tYXAoKFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0pID0+IHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBvYmpbZmllbGROYW1lXSwgZmllbGRUeXBlLCB3cml0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBvYmpbc3RydWN0U2NoZW1hLmZpZWxkXTtcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc3RydWN0U2NoZW1hLnZhbHVlcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KGlkeCk7XG4gICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIG9ialtmaWVsZE5hbWVdLCBmaWVsZFR5cGUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkIHNjaGVtYSBraW5kOiAke3N0cnVjdFNjaGVtYS5raW5kfSBmb3IgJHtvYmouY29uc3RydWN0b3IubmFtZX1gKTtcbiAgICB9XG59XG4vLy8gU2VyaWFsaXplIGdpdmVuIG9iamVjdCB1c2luZyBzY2hlbWEgb2YgdGhlIGZvcm06XG4vLy8geyBjbGFzc19uYW1lIC0+IFsgW2ZpZWxkX25hbWUsIGZpZWxkX3R5cGVdLCAuLiBdLCAuLiB9XG5mdW5jdGlvbiBzZXJpYWxpemUoc2NoZW1hLCBvYmosIFdyaXRlciA9IEJpbmFyeVdyaXRlcikge1xuICAgIGNvbnN0IHdyaXRlciA9IG5ldyBXcml0ZXIoKTtcbiAgICBzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBvYmosIHdyaXRlcik7XG4gICAgcmV0dXJuIHdyaXRlci50b0FycmF5KCk7XG59XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcbmZ1bmN0aW9uIGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWFkZXJbYHJlYWQke2NhcGl0YWxpemVGaXJzdExldHRlcihmaWVsZFR5cGUpfWBdKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZVswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEZpeGVkQXJyYXkoZmllbGRUeXBlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkVHlwZVsxXTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBudWxsLCBmaWVsZFR5cGVbMF0sIHJlYWRlcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQXJyYXkoKCkgPT4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlWzBdLCByZWFkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlLmtpbmQgPT09IFwib3B0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgICAgIGlmIChvcHRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLnR5cGUsIHJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUua2luZCA9PT0gXCJtYXBcIikge1xuICAgICAgICAgICAgbGV0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVTMyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLmtleSwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUudmFsdWUsIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgbWFwLnNldChrZXksIHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJvcnNoRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcikge1xuICAgIGlmICh0eXBlb2YgY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gY2xhc3NUeXBlLmJvcnNoRGVzZXJpYWxpemUocmVhZGVyKTtcbiAgICB9XG4gICAgY29uc3Qgc3RydWN0U2NoZW1hID0gc2NoZW1hLmdldChjbGFzc1R5cGUpO1xuICAgIGlmICghc3RydWN0U2NoZW1hKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBDbGFzcyAke2NsYXNzVHlwZS5uYW1lfSBpcyBtaXNzaW5nIGluIHNjaGVtYWApO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwic3RydWN0XCIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSBvZiBzY2hlbWEuZ2V0KGNsYXNzVHlwZSkuZmllbGRzKSB7XG4gICAgICAgICAgICByZXN1bHRbZmllbGROYW1lXSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZShyZXN1bHQpO1xuICAgIH1cbiAgICBpZiAoc3RydWN0U2NoZW1hLmtpbmQgPT09IFwiZW51bVwiKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHJlYWRlci5yZWFkVTgoKTtcbiAgICAgICAgaWYgKGlkeCA+PSBzdHJ1Y3RTY2hlbWEudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEVudW0gaW5kZXg6ICR7aWR4fSBpcyBvdXQgb2YgcmFuZ2VgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdID0gc3RydWN0U2NoZW1hLnZhbHVlc1tpZHhdO1xuICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLCByZWFkZXIpO1xuICAgICAgICByZXR1cm4gbmV3IGNsYXNzVHlwZSh7IFtmaWVsZE5hbWVdOiBmaWVsZFZhbHVlIH0pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtzdHJ1Y3RTY2hlbWEua2luZH0gZm9yICR7Y2xhc3NUeXBlLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG59XG4vLy8gRGVzZXJpYWxpemVzIG9iamVjdCBmcm9tIGJ5dGVzIHVzaW5nIHNjaGVtYS5cbmZ1bmN0aW9uIGRlc2VyaWFsaXplKHNjaGVtYSwgY2xhc3NUeXBlLCBidWZmZXIsIFJlYWRlciA9IEJpbmFyeVJlYWRlcikge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICBjb25zdCByZXN1bHQgPSBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbiAgICBpZiAocmVhZGVyLm9mZnNldCA8IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgJHtidWZmZXIubGVuZ3RoIC0gcmVhZGVyLm9mZnNldH0gYnl0ZXMgYWZ0ZXIgZGVzZXJpYWxpemVkIGRhdGFgKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemUgPSBkZXNlcmlhbGl6ZTtcbi8vLyBEZXNlcmlhbGl6ZXMgb2JqZWN0IGZyb20gYnl0ZXMgdXNpbmcgc2NoZW1hLCB3aXRob3V0IGNoZWNraW5nIHRoZSBsZW5ndGggcmVhZFxuZnVuY3Rpb24gZGVzZXJpYWxpemVVbmNoZWNrZWQoc2NoZW1hLCBjbGFzc1R5cGUsIGJ1ZmZlciwgUmVhZGVyID0gQmluYXJ5UmVhZGVyKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKTtcbn1cbmV4cG9ydHMuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBkZXNlcmlhbGl6ZVVuY2hlY2tlZDtcbiJdLCJuYW1lcyI6WyJfX2NyZWF0ZUJpbmRpbmciLCJPYmplY3QiLCJjcmVhdGUiLCJvIiwibSIsImsiLCJrMiIsInVuZGVmaW5lZCIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsImdldCIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsInYiLCJ2YWx1ZSIsIl9fZGVjb3JhdGUiLCJkZWNvcmF0b3JzIiwidGFyZ2V0Iiwia2V5IiwiZGVzYyIsImMiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZCIsIlJlZmxlY3QiLCJkZWNvcmF0ZSIsImkiLCJfX2ltcG9ydFN0YXIiLCJtb2QiLCJfX2VzTW9kdWxlIiwicmVzdWx0IiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiX19pbXBvcnREZWZhdWx0IiwiZXhwb3J0cyIsImRlc2VyaWFsaXplVW5jaGVja2VkIiwiZGVzZXJpYWxpemUiLCJzZXJpYWxpemUiLCJCaW5hcnlSZWFkZXIiLCJCaW5hcnlXcml0ZXIiLCJCb3JzaEVycm9yIiwiYmFzZURlY29kZSIsImJhc2VFbmNvZGUiLCJibl9qc18xIiwicmVxdWlyZSIsImJzNThfMSIsImVuY29kaW5nIiwiUmVzb2x2ZWRUZXh0RGVjb2RlciIsIlRleHREZWNvZGVyIiwidGV4dERlY29kZXIiLCJmYXRhbCIsIkJ1ZmZlciIsImZyb20iLCJkZWZhdWx0IiwiZW5jb2RlIiwiZGVjb2RlIiwiSU5JVElBTF9MRU5HVEgiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwibWVzc2FnZSIsImZpZWxkUGF0aCIsIm9yaWdpbmFsTWVzc2FnZSIsImFkZFRvRmllbGRQYXRoIiwiZmllbGROYW1lIiwic3BsaWNlIiwiam9pbiIsImJ1ZiIsImFsbG9jIiwibWF5YmVSZXNpemUiLCJjb25jYXQiLCJ3cml0ZVU4Iiwid3JpdGVVSW50OCIsIndyaXRlVTE2Iiwid3JpdGVVSW50MTZMRSIsIndyaXRlVTMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVTY0Iiwid3JpdGVCdWZmZXIiLCJ0b0FycmF5Iiwid3JpdGVVMTI4Iiwid3JpdGVVMjU2Iiwid3JpdGVVNTEyIiwiYnVmZmVyIiwic3ViYXJyYXkiLCJ3cml0ZVN0cmluZyIsInN0ciIsImIiLCJ3cml0ZUZpeGVkQXJyYXkiLCJhcnJheSIsIndyaXRlQXJyYXkiLCJmbiIsImVsZW0iLCJoYW5kbGluZ1JhbmdlRXJyb3IiLCJwcm9wZXJ0eUtleSIsInByb3BlcnR5RGVzY3JpcHRvciIsIm9yaWdpbmFsTWV0aG9kIiwiYXJncyIsImFwcGx5IiwiZSIsIlJhbmdlRXJyb3IiLCJjb2RlIiwiaW5kZXhPZiIsIm9mZnNldCIsInJlYWRVOCIsInJlYWRVSW50OCIsInJlYWRVMTYiLCJyZWFkVUludDE2TEUiLCJyZWFkVTMyIiwicmVhZFVJbnQzMkxFIiwicmVhZFU2NCIsInJlYWRCdWZmZXIiLCJyZWFkVTEyOCIsInJlYWRVMjU2IiwicmVhZFU1MTIiLCJsZW4iLCJzbGljZSIsInJlYWRTdHJpbmciLCJyZWFkRml4ZWRBcnJheSIsIlVpbnQ4QXJyYXkiLCJyZWFkQXJyYXkiLCJBcnJheSIsInB1c2giLCJwcm90b3R5cGUiLCJjYXBpdGFsaXplRmlyc3RMZXR0ZXIiLCJzdHJpbmciLCJjaGFyQXQiLCJ0b1VwcGVyQ2FzZSIsInNlcmlhbGl6ZUZpZWxkIiwic2NoZW1hIiwiZmllbGRUeXBlIiwid3JpdGVyIiwiaXRlbSIsImtpbmQiLCJ0eXBlIiwic2l6ZSIsImZvckVhY2giLCJ2YWwiLCJzZXJpYWxpemVTdHJ1Y3QiLCJlcnJvciIsIm9iaiIsImJvcnNoU2VyaWFsaXplIiwic3RydWN0U2NoZW1hIiwibmFtZSIsImZpZWxkcyIsIm1hcCIsImZpZWxkIiwiaWR4IiwidmFsdWVzIiwiV3JpdGVyIiwiZGVzZXJpYWxpemVGaWVsZCIsInJlYWRlciIsImFyciIsIm9wdGlvbiIsIk1hcCIsInNldCIsImRlc2VyaWFsaXplU3RydWN0IiwiY2xhc3NUeXBlIiwiYm9yc2hEZXNlcmlhbGl6ZSIsImZpZWxkVmFsdWUiLCJSZWFkZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\n");

/***/ })

};
;