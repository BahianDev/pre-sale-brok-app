"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@solana+codecs-core@2.3.0_typescript@5.3.3";
exports.ids = ["vendor-chunks/@solana+codecs-core@2.3.0_typescript@5.3.3"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(ssr)/./node_modules/.pnpm/@solana+errors@2.3.0_typescript@5.3.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjMuMF90eXBlc2NyaXB0QDUuMy4zL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMG5CO0FBRTFuQiw0QkFBNEI7QUFFNUIsZUFBZTtBQUNmLElBQUlZLGFBQWEsQ0FBQ0M7SUFDaEIsTUFBTUMscUJBQXFCRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsTUFBTTtJQUNoRSxJQUFJSCxtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9KLFdBQVdJLE1BQU0sR0FBR0osVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJSztJQUNqRDtJQUNBLElBQUlKLG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0gsa0JBQWtCLENBQUMsRUFBRTtJQUM5QjtJQUNBLE1BQU1LLGNBQWNMLG1CQUFtQk0sTUFBTSxDQUFDLENBQUNDLE9BQU9MLE1BQVFLLFFBQVFMLElBQUlDLE1BQU0sRUFBRTtJQUNsRixNQUFNSyxTQUFTLElBQUlKLFdBQVdDO0lBQzlCLElBQUlJLFNBQVM7SUFDYlQsbUJBQW1CVSxPQUFPLENBQUMsQ0FBQ1I7UUFDMUJNLE9BQU9HLEdBQUcsQ0FBQ1QsS0FBS087UUFDaEJBLFVBQVVQLElBQUlDLE1BQU07SUFDdEI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksV0FBVyxDQUFDQyxPQUFPVjtJQUNyQixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FB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QUFJQyxPQUFPO1FBQzFITyxPQUFPLENBQUNSLE9BQU9YLE9BQU9KLFNBQVdnQixRQUFRTyxLQUFLLENBQUNnRyxNQUFNeEcsUUFBUVgsT0FBT0o7SUFDdEU7QUFDRjtBQUNBLFNBQVN3SCxpQkFBaUIvRixPQUFPLEVBQUVnRyxHQUFHO0lBQ3BDLE9BQU9qRyxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNLENBQUNlLE9BQU9tRyxVQUFVLEdBQUd6RixRQUFRRSxJQUFJLENBQUN2QixPQUFPSjtZQUMvQyxPQUFPO2dCQUFDeUgsSUFBSTFHLE9BQU9YLE9BQU9KO2dCQUFTa0g7YUFBVTtRQUMvQztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxlQUFlN0YsS0FBSyxFQUFFMEYsS0FBSyxFQUFFRSxHQUFHO0lBQ3ZDLE9BQU83RixZQUFZO1FBQ2pCLEdBQUcwRixpQkFBaUJ6RixPQUFPMEYsTUFBTTtRQUNqQzVGLE1BQU04RixNQUFNRCxpQkFBaUIzRixPQUFPNEYsS0FBSzlGLElBQUksR0FBR0UsTUFBTUYsSUFBSTtJQUM1RDtBQUNGO0FBRXV2QixDQUN2dkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmErY29kZWNzLWNvcmVAMi4zLjBfdHlwZXNjcmlwdEA1LjMuMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzPzBhNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5cbi8vIHNyYy9ieXRlcy50c1xudmFyIG1lcmdlQnl0ZXMgPSAoYnl0ZUFycmF5cykgPT4ge1xuICBjb25zdCBub25FbXB0eUJ5dGVBcnJheXMgPSBieXRlQXJyYXlzLmZpbHRlcigoYXJyKSA9PiBhcnIubGVuZ3RoKTtcbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnl0ZUFycmF5cy5sZW5ndGggPyBieXRlQXJyYXlzWzBdIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub25FbXB0eUJ5dGVBcnJheXNbMF07XG4gIH1cbiAgY29uc3QgdG90YWxMZW5ndGggPSBub25FbXB0eUJ5dGVBcnJheXMucmVkdWNlKCh0b3RhbCwgYXJyKSA9PiB0b3RhbCArIGFyci5sZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBub25FbXB0eUJ5dGVBcnJheXMuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBwYWRCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiB7XG4gIGlmIChieXRlcy5sZW5ndGggPj0gbGVuZ3RoKSByZXR1cm4gYnl0ZXM7XG4gIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKS5maWxsKDApO1xuICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMpO1xuICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59O1xudmFyIGZpeEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHBhZEJ5dGVzKGJ5dGVzLmxlbmd0aCA8PSBsZW5ndGggPyBieXRlcyA6IGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCksIGxlbmd0aCk7XG5mdW5jdGlvbiBjb250YWluc0J5dGVzKGRhdGEsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc2xpY2UgPSBvZmZzZXQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGJ5dGVzLmxlbmd0aCA/IGRhdGEgOiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMubGVuZ3RoKTtcbiAgaWYgKHNsaWNlLmxlbmd0aCAhPT0gYnl0ZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBieXRlcy5ldmVyeSgoYiwgaSkgPT4gYiA9PT0gc2xpY2VbaV0pO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gZW5jb2RlciA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuY29kZXIoZW5jb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZW5jb2RlcixcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2RlcikpO1xuICAgICAgZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyKGRlY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KVswXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5jb2RlYyxcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gY29kZWMucmVhZChieXRlcywgb2Zmc2V0KVswXSxcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgY29kZWMpKTtcbiAgICAgIGNvZGVjLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRTaXplKGNvZGVjKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGNvZGVjICYmIHR5cGVvZiBjb2RlYy5maXhlZFNpemUgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZShjb2RlYykge1xuICBpZiAoIWlzRml4ZWRTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgcmV0dXJuICFpc0ZpeGVkU2l6ZShjb2RlYyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICBpZiAoIWlzVmFyaWFibGVTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tYmluZUNvZGVjKGVuY29kZXIsIGRlY29kZXIpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICE9PSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCk7XG4gIH1cbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIuZml4ZWRTaXplICE9PSBkZWNvZGVyLmZpeGVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJGaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplLFxuICAgICAgZW5jb2RlckZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemVcbiAgICB9KTtcbiAgfVxuICBpZiAoIWlzRml4ZWRTaXplKGVuY29kZXIpICYmICFpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLm1heFNpemUgIT09IGRlY29kZXIubWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyTWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplLFxuICAgICAgZW5jb2Rlck1heFNpemU6IGVuY29kZXIubWF4U2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5lbmNvZGVyLFxuICAgIGRlY29kZTogZGVjb2Rlci5kZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGVyLmVuY29kZSxcbiAgICByZWFkOiBkZWNvZGVyLnJlYWQsXG4gICAgd3JpdGU6IGVuY29kZXIud3JpdGVcbiAgfTtcbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsKGVuY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmIChmaW5kU2VudGluZWxJbmRleChlbmNvZGVyQnl0ZXMsIHNlbnRpbmVsKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwge1xuICAgICAgICBlbmNvZGVkQnl0ZXM6IGVuY29kZXJCeXRlcyxcbiAgICAgICAgaGV4RW5jb2RlZEJ5dGVzOiBoZXhCeXRlcyhlbmNvZGVyQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KHNlbnRpbmVsLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBzZW50aW5lbC5sZW5ndGg7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCB3cml0ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5lbmNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkgKyBzZW50aW5lbC5sZW5ndGgsXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2VudGluZWwoZGVjb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2FuZGlkYXRlQnl0ZXMgPSBvZmZzZXQgPT09IDAgPyBieXRlcyA6IGJ5dGVzLnNsaWNlKG9mZnNldCk7XG4gICAgY29uc3Qgc2VudGluZWxJbmRleCA9IGZpbmRTZW50aW5lbEluZGV4KGNhbmRpZGF0ZUJ5dGVzLCBzZW50aW5lbCk7XG4gICAgaWYgKHNlbnRpbmVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywge1xuICAgICAgICBkZWNvZGVkQnl0ZXM6IGNhbmRpZGF0ZUJ5dGVzLFxuICAgICAgICBoZXhEZWNvZGVkQnl0ZXM6IGhleEJ5dGVzKGNhbmRpZGF0ZUJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwcmVTZW50aW5lbEJ5dGVzID0gY2FuZGlkYXRlQnl0ZXMuc2xpY2UoMCwgc2VudGluZWxJbmRleCk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShwcmVTZW50aW5lbEJ5dGVzKSwgb2Zmc2V0ICsgcHJlU2VudGluZWxCeXRlcy5sZW5ndGggKyBzZW50aW5lbC5sZW5ndGhdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHJlYWQgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZGVjb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGRlY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgcmVhZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCksIGFkZERlY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpKTtcbn1cbmZ1bmN0aW9uIGZpbmRTZW50aW5lbEluZGV4KGJ5dGVzLCBzZW50aW5lbCkge1xuICByZXR1cm4gYnl0ZXMuZmluZEluZGV4KChieXRlLCBpbmRleCwgYXJyKSA9PiB7XG4gICAgaWYgKHNlbnRpbmVsLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ5dGUgPT09IHNlbnRpbmVsWzBdO1xuICAgIHJldHVybiBjb250YWluc0J5dGVzKGFyciwgc2VudGluZWwsIGluZGV4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoZXhCeXRlcyhieXRlcykge1xuICByZXR1cm4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCAtIG9mZnNldCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBleHBlY3RlZCwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChieXRlc0xlbmd0aCA8IGV4cGVjdGVkKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBleHBlY3RlZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoY29kZWNEZXNjcmlwdGlvbiwgb2Zmc2V0LCBieXRlc0xlbmd0aCkge1xuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBieXRlc0xlbmd0aCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgb2Zmc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zaXplLXByZWZpeC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNpemVQcmVmaXgoZW5jb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIG9mZnNldCA9IHByZWZpeC53cml0ZShlbmNvZGVyQnl0ZXMubGVuZ3RoLCBieXRlcywgb2Zmc2V0KTtcbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZW5jb2Rlci5maXhlZFNpemUsIHdyaXRlIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGVuY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZW5jb2RlcikgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBlbmNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBlbmNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZW5jb2RlclNpemUgPSBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICByZXR1cm4gZ2V0RW5jb2RlZFNpemUoZW5jb2RlclNpemUsIHByZWZpeCkgKyBlbmNvZGVyU2l6ZTtcbiAgICB9LFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNpemVQcmVmaXgoZGVjb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IFtiaWdpbnRTaXplLCBkZWNvZGVyT2Zmc2V0XSA9IHByZWZpeC5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIoYmlnaW50U2l6ZSk7XG4gICAgb2Zmc2V0ID0gZGVjb2Rlck9mZnNldDtcbiAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBzaXplKSB7XG4gICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgfVxuICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJhZGREZWNvZGVyU2l6ZVByZWZpeFwiLCBzaXplLCBieXRlcyk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShieXRlcyksIG9mZnNldCArIHNpemVdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZGVjb2Rlci5maXhlZFNpemUsIHJlYWQgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZGVjb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSA/IGRlY29kZXIuZml4ZWRTaXplIDogZGVjb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGRlY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGRlY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSwgcmVhZCB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCksIGFkZERlY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpKTtcbn1cblxuLy8gc3JjL2ZpeC1jb2RlYy1zaXplLnRzXG5mdW5jdGlvbiBmaXhFbmNvZGVyU2l6ZShlbmNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVCeXRlQXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBmaXhlZEJ5dGVBcnJheSA9IHZhcmlhYmxlQnl0ZUFycmF5Lmxlbmd0aCA+IGZpeGVkQnl0ZXMgPyB2YXJpYWJsZUJ5dGVBcnJheS5zbGljZSgwLCBmaXhlZEJ5dGVzKSA6IHZhcmlhYmxlQnl0ZUFycmF5O1xuICAgICAgYnl0ZXMuc2V0KGZpeGVkQnl0ZUFycmF5LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGZpeGVkQnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeERlY29kZXJTaXplKGRlY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImZpeENvZGVjU2l6ZVwiLCBmaXhlZEJ5dGVzLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IGZpeGVkQnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGZpeGVkQnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIGJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt2YWx1ZV0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgZml4ZWRCeXRlc107XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeENvZGVjU2l6ZShjb2RlYywgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGZpeEVuY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSwgZml4RGVjb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpKTtcbn1cblxuLy8gc3JjL29mZnNldC1jb2RlYy50c1xuZnVuY3Rpb24gb2Zmc2V0RW5jb2RlcihlbmNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBwb3N0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdQb3N0T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXREZWNvZGVyKGRlY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBbdmFsdWUsIHBvc3RPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBuZXdQb3N0T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0Q29kZWMoY29kZWMsIGNvbmZpZykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKG9mZnNldEVuY29kZXIoY29kZWMsIGNvbmZpZyksIG9mZnNldERlY29kZXIoY29kZWMsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gbW9kdWxvKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gIGlmIChkaXZpc29yID09PSAwKSByZXR1cm4gMDtcbiAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG59XG5mdW5jdGlvbiByZXNpemVFbmNvZGVyKGVuY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZW5jb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBuZXdTaXplID0gcmVzaXplKGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKG5ld1NpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICBieXRlc0xlbmd0aDogbmV3U2l6ZSxcbiAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNpemVEZWNvZGVyKGRlY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZGVjb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRGVjb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZXI7XG59XG5mdW5jdGlvbiByZXNpemVDb2RlYyhjb2RlYywgcmVzaXplKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmVzaXplRW5jb2Rlcihjb2RlYywgcmVzaXplKSwgcmVzaXplRGVjb2Rlcihjb2RlYywgcmVzaXplKSk7XG59XG5cbi8vIHNyYy9wYWQtY29kZWMudHNcbmZ1bmN0aW9uIHBhZExlZnRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkTGVmdEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZExlZnREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZFJpZ2h0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkUmlnaHREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cblxuLy8gc3JjL3JldmVyc2UtY29kZWMudHNcbmZ1bmN0aW9uIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShzb3VyY2UsIHRhcmdldF9XSUxMX01VVEFURSwgc291cmNlT2Zmc2V0LCBzb3VyY2VMZW5ndGgsIHRhcmdldE9mZnNldCA9IDApIHtcbiAgd2hpbGUgKHNvdXJjZU9mZnNldCA8IC0tc291cmNlTGVuZ3RoKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlTGVuZ3RoXTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlTGVuZ3RoICsgdGFyZ2V0T2Zmc2V0XSA9IGxlZnRWYWx1ZTtcbiAgICBzb3VyY2VPZmZzZXQrKztcbiAgfVxuICBpZiAoc291cmNlT2Zmc2V0ID09PSBzb3VyY2VMZW5ndGgpIHtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlRW5jb2RlcihlbmNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGVuY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBuZXdPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGVuY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld09mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZURlY29kZXIoZGVjb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShkZWNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHJldmVyc2VkQnl0ZXMgPSBieXRlcy5zbGljZSgpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgcmV2ZXJzZWRCeXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBkZWNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWNvZGVyLnJlYWQocmV2ZXJzZWRCeXRlcywgb2Zmc2V0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmV2ZXJzZUVuY29kZXIoY29kZWMpLCByZXZlcnNlRGVjb2Rlcihjb2RlYykpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtLWNvZGVjLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1FbmNvZGVyKGVuY29kZXIsIHVubWFwKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5pc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKSA/IHsgLi4uZW5jb2RlciwgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodW5tYXAodmFsdWUpKSB9IDogZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiBlbmNvZGVyLndyaXRlKHVubWFwKHZhbHVlKSwgYnl0ZXMsIG9mZnNldClcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1EZWNvZGVyKGRlY29kZXIsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIFttYXAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpLCBuZXdPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYyhjb2RlYywgdW5tYXAsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgIC4uLnRyYW5zZm9ybUVuY29kZXIoY29kZWMsIHVubWFwKSxcbiAgICByZWFkOiBtYXAgPyB0cmFuc2Zvcm1EZWNvZGVyKGNvZGVjLCBtYXApLnJlYWQgOiBjb2RlYy5yZWFkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBhZGRDb2RlY1NlbnRpbmVsLCBhZGRDb2RlY1NpemVQcmVmaXgsIGFkZERlY29kZXJTZW50aW5lbCwgYWRkRGVjb2RlclNpemVQcmVmaXgsIGFkZEVuY29kZXJTZW50aW5lbCwgYWRkRW5jb2RlclNpemVQcmVmaXgsIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlLCBhc3NlcnRJc0ZpeGVkU2l6ZSwgYXNzZXJ0SXNWYXJpYWJsZVNpemUsIGNvbWJpbmVDb2RlYywgY29udGFpbnNCeXRlcywgY3JlYXRlQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGZpeEJ5dGVzLCBmaXhDb2RlY1NpemUsIGZpeERlY29kZXJTaXplLCBmaXhFbmNvZGVyU2l6ZSwgZ2V0RW5jb2RlZFNpemUsIGlzRml4ZWRTaXplLCBpc1ZhcmlhYmxlU2l6ZSwgbWVyZ2VCeXRlcywgb2Zmc2V0Q29kZWMsIG9mZnNldERlY29kZXIsIG9mZnNldEVuY29kZXIsIHBhZEJ5dGVzLCBwYWRMZWZ0Q29kZWMsIHBhZExlZnREZWNvZGVyLCBwYWRMZWZ0RW5jb2RlciwgcGFkUmlnaHRDb2RlYywgcGFkUmlnaHREZWNvZGVyLCBwYWRSaWdodEVuY29kZXIsIHJlc2l6ZUNvZGVjLCByZXNpemVEZWNvZGVyLCByZXNpemVFbmNvZGVyLCByZXZlcnNlQ29kZWMsIHJldmVyc2VEZWNvZGVyLCByZXZlcnNlRW5jb2RlciwgdHJhbnNmb3JtQ29kZWMsIHRyYW5zZm9ybURlY29kZXIsIHRyYW5zZm9ybUVuY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwibWVyZ2VCeXRlcyIsImJ5dGVBcnJheXMiLCJub25FbXB0eUJ5dGVBcnJheXMiLCJmaWx0ZXIiLCJhcnIiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJ0b3RhbCIsInJlc3VsdCIsIm9mZnNldCIsImZvckVhY2giLCJzZXQiLCJwYWRCeXRlcyIsImJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJmaWxsIiwiZml4Qnl0ZXMiLCJzbGljZSIsImNvbnRhaW5zQnl0ZXMiLCJkYXRhIiwiZXZlcnkiLCJiIiwiaSIsImdldEVuY29kZWRTaXplIiwidmFsdWUiLCJlbmNvZGVyIiwiZml4ZWRTaXplIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImNyZWF0ZUVuY29kZXIiLCJPYmplY3QiLCJmcmVlemUiLCJlbmNvZGUiLCJ3cml0ZSIsImNyZWF0ZURlY29kZXIiLCJkZWNvZGVyIiwiZGVjb2RlIiwicmVhZCIsImNyZWF0ZUNvZGVjIiwiY29kZWMiLCJpc0ZpeGVkU2l6ZSIsImFzc2VydElzRml4ZWRTaXplIiwiaXNWYXJpYWJsZVNpemUiLCJhc3NlcnRJc1ZhcmlhYmxlU2l6ZSIsImNvbWJpbmVDb2RlYyIsImRlY29kZXJGaXhlZFNpemUiLCJlbmNvZGVyRml4ZWRTaXplIiwibWF4U2l6ZSIsImRlY29kZXJNYXhTaXplIiwiZW5jb2Rlck1heFNpemUiLCJhZGRFbmNvZGVyU2VudGluZWwiLCJzZW50aW5lbCIsImVuY29kZXJCeXRlcyIsImZpbmRTZW50aW5lbEluZGV4IiwiZW5jb2RlZEJ5dGVzIiwiaGV4RW5jb2RlZEJ5dGVzIiwiaGV4Qnl0ZXMiLCJoZXhTZW50aW5lbCIsImFkZERlY29kZXJTZW50aW5lbCIsImNhbmRpZGF0ZUJ5dGVzIiwic2VudGluZWxJbmRleCIsImRlY29kZWRCeXRlcyIsImhleERlY29kZWRCeXRlcyIsInByZVNlbnRpbmVsQnl0ZXMiLCJhZGRDb2RlY1NlbnRpbmVsIiwiZmluZEluZGV4IiwiYnl0ZSIsImluZGV4Iiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiZXhwZWN0ZWQiLCJieXRlc0xlbmd0aCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsImFkZEVuY29kZXJTaXplUHJlZml4IiwicHJlZml4IiwicHJlZml4TWF4U2l6ZSIsImVuY29kZXJTaXplIiwiYWRkRGVjb2RlclNpemVQcmVmaXgiLCJiaWdpbnRTaXplIiwiZGVjb2Rlck9mZnNldCIsInNpemUiLCJOdW1iZXIiLCJhZGRDb2RlY1NpemVQcmVmaXgiLCJmaXhFbmNvZGVyU2l6ZSIsImZpeGVkQnl0ZXMiLCJ2YXJpYWJsZUJ5dGVBcnJheSIsImZpeGVkQnl0ZUFycmF5IiwiZml4RGVjb2RlclNpemUiLCJmaXhDb2RlY1NpemUiLCJvZmZzZXRFbmNvZGVyIiwiY29uZmlnIiwicHJlT2Zmc2V0Iiwid3JhcEJ5dGVzIiwibW9kdWxvIiwibmV3UHJlT2Zmc2V0IiwicG9zdE9mZnNldCIsIm5ld1Bvc3RPZmZzZXQiLCJvZmZzZXREZWNvZGVyIiwib2Zmc2V0Q29kZWMiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJyZXNpemVFbmNvZGVyIiwicmVzaXplIiwibmV3U2l6ZSIsInJlc2l6ZURlY29kZXIiLCJyZXNpemVDb2RlYyIsInBhZExlZnRFbmNvZGVyIiwicGFkUmlnaHRFbmNvZGVyIiwicGFkTGVmdERlY29kZXIiLCJwYWRSaWdodERlY29kZXIiLCJwYWRMZWZ0Q29kZWMiLCJwYWRSaWdodENvZGVjIiwiY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlIiwic291cmNlIiwidGFyZ2V0X1dJTExfTVVUQVRFIiwic291cmNlT2Zmc2V0Iiwic291cmNlTGVuZ3RoIiwidGFyZ2V0T2Zmc2V0IiwibGVmdFZhbHVlIiwicmV2ZXJzZUVuY29kZXIiLCJuZXdPZmZzZXQiLCJyZXZlcnNlRGVjb2RlciIsInJldmVyc2VkQnl0ZXMiLCJyZXZlcnNlQ29kZWMiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwidW5tYXAiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwibWFwIiwidHJhbnNmb3JtQ29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs":
/*!****************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs ***!
  \****************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addCodecSentinel: () => (/* binding */ addCodecSentinel),\n/* harmony export */   addCodecSizePrefix: () => (/* binding */ addCodecSizePrefix),\n/* harmony export */   addDecoderSentinel: () => (/* binding */ addDecoderSentinel),\n/* harmony export */   addDecoderSizePrefix: () => (/* binding */ addDecoderSizePrefix),\n/* harmony export */   addEncoderSentinel: () => (/* binding */ addEncoderSentinel),\n/* harmony export */   addEncoderSizePrefix: () => (/* binding */ addEncoderSizePrefix),\n/* harmony export */   assertByteArrayHasEnoughBytesForCodec: () => (/* binding */ assertByteArrayHasEnoughBytesForCodec),\n/* harmony export */   assertByteArrayIsNotEmptyForCodec: () => (/* binding */ assertByteArrayIsNotEmptyForCodec),\n/* harmony export */   assertByteArrayOffsetIsNotOutOfRange: () => (/* binding */ assertByteArrayOffsetIsNotOutOfRange),\n/* harmony export */   assertIsFixedSize: () => (/* binding */ assertIsFixedSize),\n/* harmony export */   assertIsVariableSize: () => (/* binding */ assertIsVariableSize),\n/* harmony export */   combineCodec: () => (/* binding */ combineCodec),\n/* harmony export */   containsBytes: () => (/* binding */ containsBytes),\n/* harmony export */   createCodec: () => (/* binding */ createCodec),\n/* harmony export */   createDecoder: () => (/* binding */ createDecoder),\n/* harmony export */   createEncoder: () => (/* binding */ createEncoder),\n/* harmony export */   fixBytes: () => (/* binding */ fixBytes),\n/* harmony export */   fixCodecSize: () => (/* binding */ fixCodecSize),\n/* harmony export */   fixDecoderSize: () => (/* binding */ fixDecoderSize),\n/* harmony export */   fixEncoderSize: () => (/* binding */ fixEncoderSize),\n/* harmony export */   getEncodedSize: () => (/* binding */ getEncodedSize),\n/* harmony export */   isFixedSize: () => (/* binding */ isFixedSize),\n/* harmony export */   isVariableSize: () => (/* binding */ isVariableSize),\n/* harmony export */   mergeBytes: () => (/* binding */ mergeBytes),\n/* harmony export */   offsetCodec: () => (/* binding */ offsetCodec),\n/* harmony export */   offsetDecoder: () => (/* binding */ offsetDecoder),\n/* harmony export */   offsetEncoder: () => (/* binding */ offsetEncoder),\n/* harmony export */   padBytes: () => (/* binding */ padBytes),\n/* harmony export */   padLeftCodec: () => (/* binding */ padLeftCodec),\n/* harmony export */   padLeftDecoder: () => (/* binding */ padLeftDecoder),\n/* harmony export */   padLeftEncoder: () => (/* binding */ padLeftEncoder),\n/* harmony export */   padRightCodec: () => (/* binding */ padRightCodec),\n/* harmony export */   padRightDecoder: () => (/* binding */ padRightDecoder),\n/* harmony export */   padRightEncoder: () => (/* binding */ padRightEncoder),\n/* harmony export */   resizeCodec: () => (/* binding */ resizeCodec),\n/* harmony export */   resizeDecoder: () => (/* binding */ resizeDecoder),\n/* harmony export */   resizeEncoder: () => (/* binding */ resizeEncoder),\n/* harmony export */   reverseCodec: () => (/* binding */ reverseCodec),\n/* harmony export */   reverseDecoder: () => (/* binding */ reverseDecoder),\n/* harmony export */   reverseEncoder: () => (/* binding */ reverseEncoder),\n/* harmony export */   transformCodec: () => (/* binding */ transformCodec),\n/* harmony export */   transformDecoder: () => (/* binding */ transformDecoder),\n/* harmony export */   transformEncoder: () => (/* binding */ transformEncoder)\n/* harmony export */ });\n/* harmony import */ var _solana_errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/errors */ \"(rsc)/./node_modules/.pnpm/@solana+errors@2.3.0_typescript@5.3.3/node_modules/@solana/errors/dist/index.node.mjs\");\n\n// src/add-codec-sentinel.ts\n// src/bytes.ts\nvar mergeBytes = (byteArrays)=>{\n    const nonEmptyByteArrays = byteArrays.filter((arr)=>arr.length);\n    if (nonEmptyByteArrays.length === 0) {\n        return byteArrays.length ? byteArrays[0] : new Uint8Array();\n    }\n    if (nonEmptyByteArrays.length === 1) {\n        return nonEmptyByteArrays[0];\n    }\n    const totalLength = nonEmptyByteArrays.reduce((total, arr)=>total + arr.length, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    nonEmptyByteArrays.forEach((arr)=>{\n        result.set(arr, offset);\n        offset += arr.length;\n    });\n    return result;\n};\nvar padBytes = (bytes, length)=>{\n    if (bytes.length >= length) return bytes;\n    const paddedBytes = new Uint8Array(length).fill(0);\n    paddedBytes.set(bytes);\n    return paddedBytes;\n};\nvar fixBytes = (bytes, length)=>padBytes(bytes.length <= length ? bytes : bytes.slice(0, length), length);\nfunction containsBytes(data, bytes, offset) {\n    const slice = offset === 0 && data.length === bytes.length ? data : data.slice(offset, offset + bytes.length);\n    if (slice.length !== bytes.length) return false;\n    return bytes.every((b, i)=>b === slice[i]);\n}\nfunction getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n}\nfunction createEncoder(encoder) {\n    return Object.freeze({\n        ...encoder,\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, encoder));\n            encoder.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction createDecoder(decoder) {\n    return Object.freeze({\n        ...decoder,\n        decode: (bytes, offset = 0)=>decoder.read(bytes, offset)[0]\n    });\n}\nfunction createCodec(codec) {\n    return Object.freeze({\n        ...codec,\n        decode: (bytes, offset = 0)=>codec.read(bytes, offset)[0],\n        encode: (value)=>{\n            const bytes = new Uint8Array(getEncodedSize(value, codec));\n            codec.write(value, bytes, 0);\n            return bytes;\n        }\n    });\n}\nfunction isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n}\nfunction assertIsFixedSize(codec) {\n    if (!isFixedSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH);\n    }\n}\nfunction isVariableSize(codec) {\n    return !isFixedSize(codec);\n}\nfunction assertIsVariableSize(codec) {\n    if (!isVariableSize(codec)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH);\n    }\n}\nfunction combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n            decoderFixedSize: decoder.fixedSize,\n            encoderFixedSize: encoder.fixedSize\n        });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n            decoderMaxSize: decoder.maxSize,\n            encoderMaxSize: encoder.maxSize\n        });\n    }\n    return {\n        ...decoder,\n        ...encoder,\n        decode: decoder.decode,\n        encode: encoder.encode,\n        read: decoder.read,\n        write: encoder.write\n    };\n}\n// src/add-codec-sentinel.ts\nfunction addEncoderSentinel(encoder, sentinel) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        if (findSentinelIndex(encoderBytes, sentinel) >= 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL, {\n                encodedBytes: encoderBytes,\n                hexEncodedBytes: hexBytes(encoderBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        bytes.set(encoderBytes, offset);\n        offset += encoderBytes.length;\n        bytes.set(sentinel, offset);\n        offset += sentinel.length;\n        return offset;\n    };\n    if (isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: encoder.fixedSize + sentinel.length,\n            write\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        ...encoder.maxSize != null ? {\n            maxSize: encoder.maxSize + sentinel.length\n        } : {},\n        getSizeFromValue: (value)=>encoder.getSizeFromValue(value) + sentinel.length,\n        write\n    });\n}\nfunction addDecoderSentinel(decoder, sentinel) {\n    const read = (bytes, offset)=>{\n        const candidateBytes = offset === 0 ? bytes : bytes.slice(offset);\n        const sentinelIndex = findSentinelIndex(candidateBytes, sentinel);\n        if (sentinelIndex === -1) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES, {\n                decodedBytes: candidateBytes,\n                hexDecodedBytes: hexBytes(candidateBytes),\n                hexSentinel: hexBytes(sentinel),\n                sentinel\n            });\n        }\n        const preSentinelBytes = candidateBytes.slice(0, sentinelIndex);\n        return [\n            decoder.decode(preSentinelBytes),\n            offset + preSentinelBytes.length + sentinel.length\n        ];\n    };\n    if (isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: decoder.fixedSize + sentinel.length,\n            read\n        });\n    }\n    return createDecoder({\n        ...decoder,\n        ...decoder.maxSize != null ? {\n            maxSize: decoder.maxSize + sentinel.length\n        } : {},\n        read\n    });\n}\nfunction addCodecSentinel(codec, sentinel) {\n    return combineCodec(addEncoderSentinel(codec, sentinel), addDecoderSentinel(codec, sentinel));\n}\nfunction findSentinelIndex(bytes, sentinel) {\n    return bytes.findIndex((byte, index, arr)=>{\n        if (sentinel.length === 1) return byte === sentinel[0];\n        return containsBytes(arr, sentinel, index);\n    });\n}\nfunction hexBytes(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\nfunction assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset = 0) {\n    if (bytes.length - offset <= 0) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n            codecDescription\n        });\n    }\n}\nfunction assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset = 0) {\n    const bytesLength = bytes.length - offset;\n    if (bytesLength < expected) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n            bytesLength,\n            codecDescription,\n            expected\n        });\n    }\n}\nfunction assertByteArrayOffsetIsNotOutOfRange(codecDescription, offset, bytesLength) {\n    if (offset < 0 || offset > bytesLength) {\n        throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE, {\n            bytesLength,\n            codecDescription,\n            offset\n        });\n    }\n}\n// src/add-codec-size-prefix.ts\nfunction addEncoderSizePrefix(encoder, prefix) {\n    const write = (value, bytes, offset)=>{\n        const encoderBytes = encoder.encode(value);\n        offset = prefix.write(encoderBytes.length, bytes, offset);\n        bytes.set(encoderBytes, offset);\n        return offset + encoderBytes.length;\n    };\n    if (isFixedSize(prefix) && isFixedSize(encoder)) {\n        return createEncoder({\n            ...encoder,\n            fixedSize: prefix.fixedSize + encoder.fixedSize,\n            write\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const encoderMaxSize = isFixedSize(encoder) ? encoder.fixedSize : encoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && encoderMaxSize !== null ? prefixMaxSize + encoderMaxSize : null;\n    return createEncoder({\n        ...encoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        getSizeFromValue: (value)=>{\n            const encoderSize = getEncodedSize(value, encoder);\n            return getEncodedSize(encoderSize, prefix) + encoderSize;\n        },\n        write\n    });\n}\nfunction addDecoderSizePrefix(decoder, prefix) {\n    const read = (bytes, offset)=>{\n        const [bigintSize, decoderOffset] = prefix.read(bytes, offset);\n        const size = Number(bigintSize);\n        offset = decoderOffset;\n        if (offset > 0 || bytes.length > size) {\n            bytes = bytes.slice(offset, offset + size);\n        }\n        assertByteArrayHasEnoughBytesForCodec(\"addDecoderSizePrefix\", size, bytes);\n        return [\n            decoder.decode(bytes),\n            offset + size\n        ];\n    };\n    if (isFixedSize(prefix) && isFixedSize(decoder)) {\n        return createDecoder({\n            ...decoder,\n            fixedSize: prefix.fixedSize + decoder.fixedSize,\n            read\n        });\n    }\n    const prefixMaxSize = isFixedSize(prefix) ? prefix.fixedSize : prefix.maxSize ?? null;\n    const decoderMaxSize = isFixedSize(decoder) ? decoder.fixedSize : decoder.maxSize ?? null;\n    const maxSize = prefixMaxSize !== null && decoderMaxSize !== null ? prefixMaxSize + decoderMaxSize : null;\n    return createDecoder({\n        ...decoder,\n        ...maxSize !== null ? {\n            maxSize\n        } : {},\n        read\n    });\n}\nfunction addCodecSizePrefix(codec, prefix) {\n    return combineCodec(addEncoderSizePrefix(codec, prefix), addDecoderSizePrefix(codec, prefix));\n}\n// src/fix-codec-size.ts\nfunction fixEncoderSize(encoder, fixedBytes) {\n    return createEncoder({\n        fixedSize: fixedBytes,\n        write: (value, bytes, offset)=>{\n            const variableByteArray = encoder.encode(value);\n            const fixedByteArray = variableByteArray.length > fixedBytes ? variableByteArray.slice(0, fixedBytes) : variableByteArray;\n            bytes.set(fixedByteArray, offset);\n            return offset + fixedBytes;\n        }\n    });\n}\nfunction fixDecoderSize(decoder, fixedBytes) {\n    return createDecoder({\n        fixedSize: fixedBytes,\n        read: (bytes, offset)=>{\n            assertByteArrayHasEnoughBytesForCodec(\"fixCodecSize\", fixedBytes, bytes, offset);\n            if (offset > 0 || bytes.length > fixedBytes) {\n                bytes = bytes.slice(offset, offset + fixedBytes);\n            }\n            if (isFixedSize(decoder)) {\n                bytes = fixBytes(bytes, decoder.fixedSize);\n            }\n            const [value] = decoder.read(bytes, 0);\n            return [\n                value,\n                offset + fixedBytes\n            ];\n        }\n    });\n}\nfunction fixCodecSize(codec, fixedBytes) {\n    return combineCodec(fixEncoderSize(codec, fixedBytes), fixDecoderSize(codec, fixedBytes));\n}\n// src/offset-codec.ts\nfunction offsetEncoder(encoder, config) {\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPreOffset, bytes.length);\n            const postOffset = encoder.write(value, bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetEncoder\", newPostOffset, bytes.length);\n            return newPostOffset;\n        }\n    });\n}\nfunction offsetDecoder(decoder, config) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, preOffset)=>{\n            const wrapBytes = (offset)=>modulo(offset, bytes.length);\n            const newPreOffset = config.preOffset ? config.preOffset({\n                bytes,\n                preOffset,\n                wrapBytes\n            }) : preOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPreOffset, bytes.length);\n            const [value, postOffset] = decoder.read(bytes, newPreOffset);\n            const newPostOffset = config.postOffset ? config.postOffset({\n                bytes,\n                newPreOffset,\n                postOffset,\n                preOffset,\n                wrapBytes\n            }) : postOffset;\n            assertByteArrayOffsetIsNotOutOfRange(\"offsetDecoder\", newPostOffset, bytes.length);\n            return [\n                value,\n                newPostOffset\n            ];\n        }\n    });\n}\nfunction offsetCodec(codec, config) {\n    return combineCodec(offsetEncoder(codec, config), offsetDecoder(codec, config));\n}\nfunction modulo(dividend, divisor) {\n    if (divisor === 0) return 0;\n    return (dividend % divisor + divisor) % divisor;\n}\nfunction resizeEncoder(encoder, resize) {\n    if (isFixedSize(encoder)) {\n        const fixedSize = resize(encoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeEncoder\"\n            });\n        }\n        return createEncoder({\n            ...encoder,\n            fixedSize\n        });\n    }\n    return createEncoder({\n        ...encoder,\n        getSizeFromValue: (value)=>{\n            const newSize = resize(encoder.getSizeFromValue(value));\n            if (newSize < 0) {\n                throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                    bytesLength: newSize,\n                    codecDescription: \"resizeEncoder\"\n                });\n            }\n            return newSize;\n        }\n    });\n}\nfunction resizeDecoder(decoder, resize) {\n    if (isFixedSize(decoder)) {\n        const fixedSize = resize(decoder.fixedSize);\n        if (fixedSize < 0) {\n            throw new _solana_errors__WEBPACK_IMPORTED_MODULE_0__.SolanaError(_solana_errors__WEBPACK_IMPORTED_MODULE_0__.SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH, {\n                bytesLength: fixedSize,\n                codecDescription: \"resizeDecoder\"\n            });\n        }\n        return createDecoder({\n            ...decoder,\n            fixedSize\n        });\n    }\n    return decoder;\n}\nfunction resizeCodec(codec, resize) {\n    return combineCodec(resizeEncoder(codec, resize), resizeDecoder(codec, resize));\n}\n// src/pad-codec.ts\nfunction padLeftEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightEncoder(encoder, offset) {\n    return offsetEncoder(resizeEncoder(encoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        preOffset: ({ preOffset })=>preOffset + offset\n    });\n}\nfunction padRightDecoder(decoder, offset) {\n    return offsetDecoder(resizeDecoder(decoder, (size)=>size + offset), {\n        postOffset: ({ postOffset })=>postOffset + offset\n    });\n}\nfunction padLeftCodec(codec, offset) {\n    return combineCodec(padLeftEncoder(codec, offset), padLeftDecoder(codec, offset));\n}\nfunction padRightCodec(codec, offset) {\n    return combineCodec(padRightEncoder(codec, offset), padRightDecoder(codec, offset));\n}\n// src/reverse-codec.ts\nfunction copySourceToTargetInReverse(source, target_WILL_MUTATE, sourceOffset, sourceLength, targetOffset = 0) {\n    while(sourceOffset < --sourceLength){\n        const leftValue = source[sourceOffset];\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceLength];\n        target_WILL_MUTATE[sourceLength + targetOffset] = leftValue;\n        sourceOffset++;\n    }\n    if (sourceOffset === sourceLength) {\n        target_WILL_MUTATE[sourceOffset + targetOffset] = source[sourceOffset];\n    }\n}\nfunction reverseEncoder(encoder) {\n    assertIsFixedSize(encoder);\n    return createEncoder({\n        ...encoder,\n        write: (value, bytes, offset)=>{\n            const newOffset = encoder.write(value, bytes, offset);\n            copySourceToTargetInReverse(bytes, bytes, offset, offset + encoder.fixedSize);\n            return newOffset;\n        }\n    });\n}\nfunction reverseDecoder(decoder) {\n    assertIsFixedSize(decoder);\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const reversedBytes = bytes.slice();\n            copySourceToTargetInReverse(bytes, reversedBytes, offset, offset + decoder.fixedSize);\n            return decoder.read(reversedBytes, offset);\n        }\n    });\n}\nfunction reverseCodec(codec) {\n    return combineCodec(reverseEncoder(codec), reverseDecoder(codec));\n}\n// src/transform-codec.ts\nfunction transformEncoder(encoder, unmap) {\n    return createEncoder({\n        ...isVariableSize(encoder) ? {\n            ...encoder,\n            getSizeFromValue: (value)=>encoder.getSizeFromValue(unmap(value))\n        } : encoder,\n        write: (value, bytes, offset)=>encoder.write(unmap(value), bytes, offset)\n    });\n}\nfunction transformDecoder(decoder, map) {\n    return createDecoder({\n        ...decoder,\n        read: (bytes, offset)=>{\n            const [value, newOffset] = decoder.read(bytes, offset);\n            return [\n                map(value, bytes, offset),\n                newOffset\n            ];\n        }\n    });\n}\nfunction transformCodec(codec, unmap, map) {\n    return createCodec({\n        ...transformEncoder(codec, unmap),\n        read: map ? transformDecoder(codec, map).read : codec.read\n    });\n}\n //# sourceMappingURL=index.node.mjs.map\n //# sourceMappingURL=index.node.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vQHNvbGFuYStjb2RlY3MtY29yZUAyLjMuMF90eXBlc2NyaXB0QDUuMy4zL25vZGVfbW9kdWxlcy9Ac29sYW5hL2NvZGVjcy1jb3JlL2Rpc3QvaW5kZXgubm9kZS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMG5CO0FBRTFuQiw0QkFBNEI7QUFFNUIsZUFBZTtBQUNmLElBQUlZLGFBQWEsQ0FBQ0M7SUFDaEIsTUFBTUMscUJBQXFCRCxXQUFXRSxNQUFNLENBQUMsQ0FBQ0MsTUFBUUEsSUFBSUMsTUFBTTtJQUNoRSxJQUFJSCxtQkFBbUJHLE1BQU0sS0FBSyxHQUFHO1FBQ25DLE9BQU9KLFdBQVdJLE1BQU0sR0FBR0osVUFBVSxDQUFDLEVBQUUsR0FBRyxJQUFJSztJQUNqRDtJQUNBLElBQUlKLG1CQUFtQkcsTUFBTSxLQUFLLEdBQUc7UUFDbkMsT0FBT0gsa0JBQWtCLENBQUMsRUFBRTtJQUM5QjtJQUNBLE1BQU1LLGNBQWNMLG1CQUFtQk0sTUFBTSxDQUFDLENBQUNDLE9BQU9MLE1BQVFLLFFBQVFMLElBQUlDLE1BQU0sRUFBRTtJQUNsRixNQUFNSyxTQUFTLElBQUlKLFdBQVdDO0lBQzlCLElBQUlJLFNBQVM7SUFDYlQsbUJBQW1CVSxPQUFPLENBQUMsQ0FBQ1I7UUFDMUJNLE9BQU9HLEdBQUcsQ0FBQ1QsS0FBS087UUFDaEJBLFVBQVVQLElBQUlDLE1BQU07SUFDdEI7SUFDQSxPQUFPSztBQUNUO0FBQ0EsSUFBSUksV0FBVyxDQUFDQyxPQUFPVjtJQUNyQixJQUFJVSxNQUFNVixNQUFNLElBQUlBLFFBQVEsT0FBT1U7SUFDbkMsTUFBTUMsY0FBYyxJQUFJVixXQUFXRCxRQUFRWSxJQUFJLENBQUM7SUFDaERELFlBQVlILEdBQUcsQ0FBQ0U7SUFDaEIsT0FBT0M7QUFDVDtBQUNBLElBQUlFLFdBQVcsQ0FBQ0gsT0FBT1YsU0FBV1MsU0FB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QUFJQyxPQUFPO1FBQzFITyxPQUFPLENBQUNSLE9BQU9YLE9BQU9KLFNBQVdnQixRQUFRTyxLQUFLLENBQUNnRyxNQUFNeEcsUUFBUVgsT0FBT0o7SUFDdEU7QUFDRjtBQUNBLFNBQVN3SCxpQkFBaUIvRixPQUFPLEVBQUVnRyxHQUFHO0lBQ3BDLE9BQU9qRyxjQUFjO1FBQ25CLEdBQUdDLE9BQU87UUFDVkUsTUFBTSxDQUFDdkIsT0FBT0o7WUFDWixNQUFNLENBQUNlLE9BQU9tRyxVQUFVLEdBQUd6RixRQUFRRSxJQUFJLENBQUN2QixPQUFPSjtZQUMvQyxPQUFPO2dCQUFDeUgsSUFBSTFHLE9BQU9YLE9BQU9KO2dCQUFTa0g7YUFBVTtRQUMvQztJQUNGO0FBQ0Y7QUFDQSxTQUFTUSxlQUFlN0YsS0FBSyxFQUFFMEYsS0FBSyxFQUFFRSxHQUFHO0lBQ3ZDLE9BQU83RixZQUFZO1FBQ2pCLEdBQUcwRixpQkFBaUJ6RixPQUFPMEYsTUFBTTtRQUNqQzVGLE1BQU04RixNQUFNRCxpQkFBaUIzRixPQUFPNEYsS0FBSzlGLElBQUksR0FBR0UsTUFBTUYsSUFBSTtJQUM1RDtBQUNGO0FBRXV2QixDQUN2dkIsdUNBQXVDO0NBQ3ZDLHVDQUF1QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByZXNhbGUtd2ViLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bzb2xhbmErY29kZWNzLWNvcmVAMi4zLjBfdHlwZXNjcmlwdEA1LjMuMy9ub2RlX21vZHVsZXMvQHNvbGFuYS9jb2RlY3MtY29yZS9kaXN0L2luZGV4Lm5vZGUubWpzPzBhNzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hRXJyb3IsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9GSVhFRF9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfU0laRV9DT01QQVRJQklMSVRZX01JU01BVENILCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0gsIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwgU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCBTT0xBTkFfRVJST1JfX0NPREVDU19fU0VOVElORUxfTUlTU0lOR19JTl9ERUNPREVEX0JZVEVTLCBTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIH0gZnJvbSAnQHNvbGFuYS9lcnJvcnMnO1xuXG4vLyBzcmMvYWRkLWNvZGVjLXNlbnRpbmVsLnRzXG5cbi8vIHNyYy9ieXRlcy50c1xudmFyIG1lcmdlQnl0ZXMgPSAoYnl0ZUFycmF5cykgPT4ge1xuICBjb25zdCBub25FbXB0eUJ5dGVBcnJheXMgPSBieXRlQXJyYXlzLmZpbHRlcigoYXJyKSA9PiBhcnIubGVuZ3RoKTtcbiAgaWYgKG5vbkVtcHR5Qnl0ZUFycmF5cy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYnl0ZUFycmF5cy5sZW5ndGggPyBieXRlQXJyYXlzWzBdIDogbmV3IFVpbnQ4QXJyYXkoKTtcbiAgfVxuICBpZiAobm9uRW1wdHlCeXRlQXJyYXlzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBub25FbXB0eUJ5dGVBcnJheXNbMF07XG4gIH1cbiAgY29uc3QgdG90YWxMZW5ndGggPSBub25FbXB0eUJ5dGVBcnJheXMucmVkdWNlKCh0b3RhbCwgYXJyKSA9PiB0b3RhbCArIGFyci5sZW5ndGgsIDApO1xuICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheSh0b3RhbExlbmd0aCk7XG4gIGxldCBvZmZzZXQgPSAwO1xuICBub25FbXB0eUJ5dGVBcnJheXMuZm9yRWFjaCgoYXJyKSA9PiB7XG4gICAgcmVzdWx0LnNldChhcnIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGFyci5sZW5ndGg7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBwYWRCeXRlcyA9IChieXRlcywgbGVuZ3RoKSA9PiB7XG4gIGlmIChieXRlcy5sZW5ndGggPj0gbGVuZ3RoKSByZXR1cm4gYnl0ZXM7XG4gIGNvbnN0IHBhZGRlZEJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKS5maWxsKDApO1xuICBwYWRkZWRCeXRlcy5zZXQoYnl0ZXMpO1xuICByZXR1cm4gcGFkZGVkQnl0ZXM7XG59O1xudmFyIGZpeEJ5dGVzID0gKGJ5dGVzLCBsZW5ndGgpID0+IHBhZEJ5dGVzKGJ5dGVzLmxlbmd0aCA8PSBsZW5ndGggPyBieXRlcyA6IGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCksIGxlbmd0aCk7XG5mdW5jdGlvbiBjb250YWluc0J5dGVzKGRhdGEsIGJ5dGVzLCBvZmZzZXQpIHtcbiAgY29uc3Qgc2xpY2UgPSBvZmZzZXQgPT09IDAgJiYgZGF0YS5sZW5ndGggPT09IGJ5dGVzLmxlbmd0aCA/IGRhdGEgOiBkYXRhLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYnl0ZXMubGVuZ3RoKTtcbiAgaWYgKHNsaWNlLmxlbmd0aCAhPT0gYnl0ZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBieXRlcy5ldmVyeSgoYiwgaSkgPT4gYiA9PT0gc2xpY2VbaV0pO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RlZFNpemUodmFsdWUsIGVuY29kZXIpIHtcbiAgcmV0dXJuIFwiZml4ZWRTaXplXCIgaW4gZW5jb2RlciA/IGVuY29kZXIuZml4ZWRTaXplIDogZW5jb2Rlci5nZXRTaXplRnJvbVZhbHVlKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuY29kZXIoZW5jb2Rlcikge1xuICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgLi4uZW5jb2RlcixcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2RlcikpO1xuICAgICAgZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVEZWNvZGVyKGRlY29kZXIpIHtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgZGVjb2RlOiAoYnl0ZXMsIG9mZnNldCA9IDApID0+IGRlY29kZXIucmVhZChieXRlcywgb2Zmc2V0KVswXVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAuLi5jb2RlYyxcbiAgICBkZWNvZGU6IChieXRlcywgb2Zmc2V0ID0gMCkgPT4gY29kZWMucmVhZChieXRlcywgb2Zmc2V0KVswXSxcbiAgICBlbmNvZGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgY29kZWMpKTtcbiAgICAgIGNvZGVjLndyaXRlKHZhbHVlLCBieXRlcywgMCk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzRml4ZWRTaXplKGNvZGVjKSB7XG4gIHJldHVybiBcImZpeGVkU2l6ZVwiIGluIGNvZGVjICYmIHR5cGVvZiBjb2RlYy5maXhlZFNpemUgPT09IFwibnVtYmVyXCI7XG59XG5mdW5jdGlvbiBhc3NlcnRJc0ZpeGVkU2l6ZShjb2RlYykge1xuICBpZiAoIWlzRml4ZWRTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfRklYRURfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNWYXJpYWJsZVNpemUoY29kZWMpIHtcbiAgcmV0dXJuICFpc0ZpeGVkU2l6ZShjb2RlYyk7XG59XG5mdW5jdGlvbiBhc3NlcnRJc1ZhcmlhYmxlU2l6ZShjb2RlYykge1xuICBpZiAoIWlzVmFyaWFibGVTaXplKGNvZGVjKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfVkFSSUFCTEVfTEVOR1RIKTtcbiAgfVxufVxuZnVuY3Rpb24gY29tYmluZUNvZGVjKGVuY29kZXIsIGRlY29kZXIpIHtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICE9PSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCk7XG4gIH1cbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpICYmIGlzRml4ZWRTaXplKGRlY29kZXIpICYmIGVuY29kZXIuZml4ZWRTaXplICE9PSBkZWNvZGVyLmZpeGVkU2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX0ZJWEVEX1NJWkVfTUlTTUFUQ0gsIHtcbiAgICAgIGRlY29kZXJGaXhlZFNpemU6IGRlY29kZXIuZml4ZWRTaXplLFxuICAgICAgZW5jb2RlckZpeGVkU2l6ZTogZW5jb2Rlci5maXhlZFNpemVcbiAgICB9KTtcbiAgfVxuICBpZiAoIWlzRml4ZWRTaXplKGVuY29kZXIpICYmICFpc0ZpeGVkU2l6ZShkZWNvZGVyKSAmJiBlbmNvZGVyLm1heFNpemUgIT09IGRlY29kZXIubWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX01BWF9TSVpFX01JU01BVENILCB7XG4gICAgICBkZWNvZGVyTWF4U2l6ZTogZGVjb2Rlci5tYXhTaXplLFxuICAgICAgZW5jb2Rlck1heFNpemU6IGVuY29kZXIubWF4U2l6ZVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgLi4uZGVjb2RlcixcbiAgICAuLi5lbmNvZGVyLFxuICAgIGRlY29kZTogZGVjb2Rlci5kZWNvZGUsXG4gICAgZW5jb2RlOiBlbmNvZGVyLmVuY29kZSxcbiAgICByZWFkOiBkZWNvZGVyLnJlYWQsXG4gICAgd3JpdGU6IGVuY29kZXIud3JpdGVcbiAgfTtcbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zZW50aW5lbC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNlbnRpbmVsKGVuY29kZXIsIHNlbnRpbmVsKSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIGlmIChmaW5kU2VudGluZWxJbmRleChlbmNvZGVyQnl0ZXMsIHNlbnRpbmVsKSA+PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VOQ09ERURfQllURVNfTVVTVF9OT1RfSU5DTFVERV9TRU5USU5FTCwge1xuICAgICAgICBlbmNvZGVkQnl0ZXM6IGVuY29kZXJCeXRlcyxcbiAgICAgICAgaGV4RW5jb2RlZEJ5dGVzOiBoZXhCeXRlcyhlbmNvZGVyQnl0ZXMpLFxuICAgICAgICBoZXhTZW50aW5lbDogaGV4Qnl0ZXMoc2VudGluZWwpLFxuICAgICAgICBzZW50aW5lbFxuICAgICAgfSk7XG4gICAgfVxuICAgIGJ5dGVzLnNldChlbmNvZGVyQnl0ZXMsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IGVuY29kZXJCeXRlcy5sZW5ndGg7XG4gICAgYnl0ZXMuc2V0KHNlbnRpbmVsLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBzZW50aW5lbC5sZW5ndGg7XG4gICAgcmV0dXJuIG9mZnNldDtcbiAgfTtcbiAgaWYgKGlzRml4ZWRTaXplKGVuY29kZXIpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemU6IGVuY29kZXIuZml4ZWRTaXplICsgc2VudGluZWwubGVuZ3RoLCB3cml0ZSB9KTtcbiAgfVxuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICAuLi5lbmNvZGVyLm1heFNpemUgIT0gbnVsbCA/IHsgbWF4U2l6ZTogZW5jb2Rlci5tYXhTaXplICsgc2VudGluZWwubGVuZ3RoIH0gOiB7fSxcbiAgICBnZXRTaXplRnJvbVZhbHVlOiAodmFsdWUpID0+IGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkgKyBzZW50aW5lbC5sZW5ndGgsXG4gICAgd3JpdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBhZGREZWNvZGVyU2VudGluZWwoZGVjb2Rlciwgc2VudGluZWwpIHtcbiAgY29uc3QgcmVhZCA9IChieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgY2FuZGlkYXRlQnl0ZXMgPSBvZmZzZXQgPT09IDAgPyBieXRlcyA6IGJ5dGVzLnNsaWNlKG9mZnNldCk7XG4gICAgY29uc3Qgc2VudGluZWxJbmRleCA9IGZpbmRTZW50aW5lbEluZGV4KGNhbmRpZGF0ZUJ5dGVzLCBzZW50aW5lbCk7XG4gICAgaWYgKHNlbnRpbmVsSW5kZXggPT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX1NFTlRJTkVMX01JU1NJTkdfSU5fREVDT0RFRF9CWVRFUywge1xuICAgICAgICBkZWNvZGVkQnl0ZXM6IGNhbmRpZGF0ZUJ5dGVzLFxuICAgICAgICBoZXhEZWNvZGVkQnl0ZXM6IGhleEJ5dGVzKGNhbmRpZGF0ZUJ5dGVzKSxcbiAgICAgICAgaGV4U2VudGluZWw6IGhleEJ5dGVzKHNlbnRpbmVsKSxcbiAgICAgICAgc2VudGluZWxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBwcmVTZW50aW5lbEJ5dGVzID0gY2FuZGlkYXRlQnl0ZXMuc2xpY2UoMCwgc2VudGluZWxJbmRleCk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShwcmVTZW50aW5lbEJ5dGVzKSwgb2Zmc2V0ICsgcHJlU2VudGluZWxCeXRlcy5sZW5ndGggKyBzZW50aW5lbC5sZW5ndGhdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7IC4uLmRlY29kZXIsIGZpeGVkU2l6ZTogZGVjb2Rlci5maXhlZFNpemUgKyBzZW50aW5lbC5sZW5ndGgsIHJlYWQgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgLi4uZGVjb2Rlci5tYXhTaXplICE9IG51bGwgPyB7IG1heFNpemU6IGRlY29kZXIubWF4U2l6ZSArIHNlbnRpbmVsLmxlbmd0aCB9IDoge30sXG4gICAgcmVhZFxuICB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2VudGluZWwoY29kZWMsIHNlbnRpbmVsKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNlbnRpbmVsKGNvZGVjLCBzZW50aW5lbCksIGFkZERlY29kZXJTZW50aW5lbChjb2RlYywgc2VudGluZWwpKTtcbn1cbmZ1bmN0aW9uIGZpbmRTZW50aW5lbEluZGV4KGJ5dGVzLCBzZW50aW5lbCkge1xuICByZXR1cm4gYnl0ZXMuZmluZEluZGV4KChieXRlLCBpbmRleCwgYXJyKSA9PiB7XG4gICAgaWYgKHNlbnRpbmVsLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ5dGUgPT09IHNlbnRpbmVsWzBdO1xuICAgIHJldHVybiBjb250YWluc0J5dGVzKGFyciwgc2VudGluZWwsIGluZGV4KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBoZXhCeXRlcyhieXRlcykge1xuICByZXR1cm4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlJc05vdEVtcHR5Rm9yQ29kZWMoY29kZWNEZXNjcmlwdGlvbiwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgaWYgKGJ5dGVzLmxlbmd0aCAtIG9mZnNldCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19DQU5OT1RfREVDT0RFX0VNUFRZX0JZVEVfQVJSQVksIHtcbiAgICAgIGNvZGVjRGVzY3JpcHRpb25cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhjb2RlY0Rlc2NyaXB0aW9uLCBleHBlY3RlZCwgYnl0ZXMsIG9mZnNldCA9IDApIHtcbiAgY29uc3QgYnl0ZXNMZW5ndGggPSBieXRlcy5sZW5ndGggLSBvZmZzZXQ7XG4gIGlmIChieXRlc0xlbmd0aCA8IGV4cGVjdGVkKSB7XG4gICAgdGhyb3cgbmV3IFNvbGFuYUVycm9yKFNPTEFOQV9FUlJPUl9fQ09ERUNTX19JTlZBTElEX0JZVEVfTEVOR1RILCB7XG4gICAgICBieXRlc0xlbmd0aCxcbiAgICAgIGNvZGVjRGVzY3JpcHRpb24sXG4gICAgICBleHBlY3RlZFxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoY29kZWNEZXNjcmlwdGlvbiwgb2Zmc2V0LCBieXRlc0xlbmd0aCkge1xuICBpZiAob2Zmc2V0IDwgMCB8fCBvZmZzZXQgPiBieXRlc0xlbmd0aCkge1xuICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSwge1xuICAgICAgYnl0ZXNMZW5ndGgsXG4gICAgICBjb2RlY0Rlc2NyaXB0aW9uLFxuICAgICAgb2Zmc2V0XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gc3JjL2FkZC1jb2RlYy1zaXplLXByZWZpeC50c1xuZnVuY3Rpb24gYWRkRW5jb2RlclNpemVQcmVmaXgoZW5jb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHdyaXRlID0gKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgY29uc3QgZW5jb2RlckJ5dGVzID0gZW5jb2Rlci5lbmNvZGUodmFsdWUpO1xuICAgIG9mZnNldCA9IHByZWZpeC53cml0ZShlbmNvZGVyQnl0ZXMubGVuZ3RoLCBieXRlcywgb2Zmc2V0KTtcbiAgICBieXRlcy5zZXQoZW5jb2RlckJ5dGVzLCBvZmZzZXQpO1xuICAgIHJldHVybiBvZmZzZXQgKyBlbmNvZGVyQnl0ZXMubGVuZ3RoO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShlbmNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVFbmNvZGVyKHsgLi4uZW5jb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZW5jb2Rlci5maXhlZFNpemUsIHdyaXRlIH0pO1xuICB9XG4gIGNvbnN0IHByZWZpeE1heFNpemUgPSBpc0ZpeGVkU2l6ZShwcmVmaXgpID8gcHJlZml4LmZpeGVkU2l6ZSA6IHByZWZpeC5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IGVuY29kZXJNYXhTaXplID0gaXNGaXhlZFNpemUoZW5jb2RlcikgPyBlbmNvZGVyLmZpeGVkU2l6ZSA6IGVuY29kZXIubWF4U2l6ZSA/PyBudWxsO1xuICBjb25zdCBtYXhTaXplID0gcHJlZml4TWF4U2l6ZSAhPT0gbnVsbCAmJiBlbmNvZGVyTWF4U2l6ZSAhPT0gbnVsbCA/IHByZWZpeE1heFNpemUgKyBlbmNvZGVyTWF4U2l6ZSA6IG51bGw7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5lbmNvZGVyLFxuICAgIC4uLm1heFNpemUgIT09IG51bGwgPyB7IG1heFNpemUgfSA6IHt9LFxuICAgIGdldFNpemVGcm9tVmFsdWU6ICh2YWx1ZSkgPT4ge1xuICAgICAgY29uc3QgZW5jb2RlclNpemUgPSBnZXRFbmNvZGVkU2l6ZSh2YWx1ZSwgZW5jb2Rlcik7XG4gICAgICByZXR1cm4gZ2V0RW5jb2RlZFNpemUoZW5jb2RlclNpemUsIHByZWZpeCkgKyBlbmNvZGVyU2l6ZTtcbiAgICB9LFxuICAgIHdyaXRlXG4gIH0pO1xufVxuZnVuY3Rpb24gYWRkRGVjb2RlclNpemVQcmVmaXgoZGVjb2RlciwgcHJlZml4KSB7XG4gIGNvbnN0IHJlYWQgPSAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IFtiaWdpbnRTaXplLCBkZWNvZGVyT2Zmc2V0XSA9IHByZWZpeC5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgIGNvbnN0IHNpemUgPSBOdW1iZXIoYmlnaW50U2l6ZSk7XG4gICAgb2Zmc2V0ID0gZGVjb2Rlck9mZnNldDtcbiAgICBpZiAob2Zmc2V0ID4gMCB8fCBieXRlcy5sZW5ndGggPiBzaXplKSB7XG4gICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc2l6ZSk7XG4gICAgfVxuICAgIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMoXCJhZGREZWNvZGVyU2l6ZVByZWZpeFwiLCBzaXplLCBieXRlcyk7XG4gICAgcmV0dXJuIFtkZWNvZGVyLmRlY29kZShieXRlcyksIG9mZnNldCArIHNpemVdO1xuICB9O1xuICBpZiAoaXNGaXhlZFNpemUocHJlZml4KSAmJiBpc0ZpeGVkU2l6ZShkZWNvZGVyKSkge1xuICAgIHJldHVybiBjcmVhdGVEZWNvZGVyKHsgLi4uZGVjb2RlciwgZml4ZWRTaXplOiBwcmVmaXguZml4ZWRTaXplICsgZGVjb2Rlci5maXhlZFNpemUsIHJlYWQgfSk7XG4gIH1cbiAgY29uc3QgcHJlZml4TWF4U2l6ZSA9IGlzRml4ZWRTaXplKHByZWZpeCkgPyBwcmVmaXguZml4ZWRTaXplIDogcHJlZml4Lm1heFNpemUgPz8gbnVsbDtcbiAgY29uc3QgZGVjb2Rlck1heFNpemUgPSBpc0ZpeGVkU2l6ZShkZWNvZGVyKSA/IGRlY29kZXIuZml4ZWRTaXplIDogZGVjb2Rlci5tYXhTaXplID8/IG51bGw7XG4gIGNvbnN0IG1heFNpemUgPSBwcmVmaXhNYXhTaXplICE9PSBudWxsICYmIGRlY29kZXJNYXhTaXplICE9PSBudWxsID8gcHJlZml4TWF4U2l6ZSArIGRlY29kZXJNYXhTaXplIDogbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCAuLi5tYXhTaXplICE9PSBudWxsID8geyBtYXhTaXplIH0gOiB7fSwgcmVhZCB9KTtcbn1cbmZ1bmN0aW9uIGFkZENvZGVjU2l6ZVByZWZpeChjb2RlYywgcHJlZml4KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMoYWRkRW5jb2RlclNpemVQcmVmaXgoY29kZWMsIHByZWZpeCksIGFkZERlY29kZXJTaXplUHJlZml4KGNvZGVjLCBwcmVmaXgpKTtcbn1cblxuLy8gc3JjL2ZpeC1jb2RlYy1zaXplLnRzXG5mdW5jdGlvbiBmaXhFbmNvZGVyU2l6ZShlbmNvZGVyLCBmaXhlZEJ5dGVzKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICBmaXhlZFNpemU6IGZpeGVkQnl0ZXMsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgdmFyaWFibGVCeXRlQXJyYXkgPSBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICBjb25zdCBmaXhlZEJ5dGVBcnJheSA9IHZhcmlhYmxlQnl0ZUFycmF5Lmxlbmd0aCA+IGZpeGVkQnl0ZXMgPyB2YXJpYWJsZUJ5dGVBcnJheS5zbGljZSgwLCBmaXhlZEJ5dGVzKSA6IHZhcmlhYmxlQnl0ZUFycmF5O1xuICAgICAgYnl0ZXMuc2V0KGZpeGVkQnl0ZUFycmF5LCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIG9mZnNldCArIGZpeGVkQnl0ZXM7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeERlY29kZXJTaXplKGRlY29kZXIsIGZpeGVkQnl0ZXMpIHtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIGZpeGVkU2l6ZTogZml4ZWRCeXRlcyxcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5SGFzRW5vdWdoQnl0ZXNGb3JDb2RlYyhcImZpeENvZGVjU2l6ZVwiLCBmaXhlZEJ5dGVzLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGlmIChvZmZzZXQgPiAwIHx8IGJ5dGVzLmxlbmd0aCA+IGZpeGVkQnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBieXRlcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGZpeGVkQnl0ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGlzRml4ZWRTaXplKGRlY29kZXIpKSB7XG4gICAgICAgIGJ5dGVzID0gZml4Qnl0ZXMoYnl0ZXMsIGRlY29kZXIuZml4ZWRTaXplKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IFt2YWx1ZV0gPSBkZWNvZGVyLnJlYWQoYnl0ZXMsIDApO1xuICAgICAgcmV0dXJuIFt2YWx1ZSwgb2Zmc2V0ICsgZml4ZWRCeXRlc107XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGZpeENvZGVjU2l6ZShjb2RlYywgZml4ZWRCeXRlcykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKGZpeEVuY29kZXJTaXplKGNvZGVjLCBmaXhlZEJ5dGVzKSwgZml4RGVjb2RlclNpemUoY29kZWMsIGZpeGVkQnl0ZXMpKTtcbn1cblxuLy8gc3JjL29mZnNldC1jb2RlYy50c1xuZnVuY3Rpb24gb2Zmc2V0RW5jb2RlcihlbmNvZGVyLCBjb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgd3JpdGU6ICh2YWx1ZSwgYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RW5jb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBwb3N0T2Zmc2V0ID0gZW5jb2Rlci53cml0ZSh2YWx1ZSwgYnl0ZXMsIG5ld1ByZU9mZnNldCk7XG4gICAgICBjb25zdCBuZXdQb3N0T2Zmc2V0ID0gY29uZmlnLnBvc3RPZmZzZXQgPyBjb25maWcucG9zdE9mZnNldCh7IGJ5dGVzLCBuZXdQcmVPZmZzZXQsIHBvc3RPZmZzZXQsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcG9zdE9mZnNldDtcbiAgICAgIGFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZShcIm9mZnNldEVuY29kZXJcIiwgbmV3UG9zdE9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIHJldHVybiBuZXdQb3N0T2Zmc2V0O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBvZmZzZXREZWNvZGVyKGRlY29kZXIsIGNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIHByZU9mZnNldCkgPT4ge1xuICAgICAgY29uc3Qgd3JhcEJ5dGVzID0gKG9mZnNldCkgPT4gbW9kdWxvKG9mZnNldCwgYnl0ZXMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1ByZU9mZnNldCA9IGNvbmZpZy5wcmVPZmZzZXQgPyBjb25maWcucHJlT2Zmc2V0KHsgYnl0ZXMsIHByZU9mZnNldCwgd3JhcEJ5dGVzIH0pIDogcHJlT2Zmc2V0O1xuICAgICAgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlKFwib2Zmc2V0RGVjb2RlclwiLCBuZXdQcmVPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBbdmFsdWUsIHBvc3RPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBuZXdQcmVPZmZzZXQpO1xuICAgICAgY29uc3QgbmV3UG9zdE9mZnNldCA9IGNvbmZpZy5wb3N0T2Zmc2V0ID8gY29uZmlnLnBvc3RPZmZzZXQoeyBieXRlcywgbmV3UHJlT2Zmc2V0LCBwb3N0T2Zmc2V0LCBwcmVPZmZzZXQsIHdyYXBCeXRlcyB9KSA6IHBvc3RPZmZzZXQ7XG4gICAgICBhc3NlcnRCeXRlQXJyYXlPZmZzZXRJc05vdE91dE9mUmFuZ2UoXCJvZmZzZXREZWNvZGVyXCIsIG5ld1Bvc3RPZmZzZXQsIGJ5dGVzLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3ZhbHVlLCBuZXdQb3N0T2Zmc2V0XTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gb2Zmc2V0Q29kZWMoY29kZWMsIGNvbmZpZykge1xuICByZXR1cm4gY29tYmluZUNvZGVjKG9mZnNldEVuY29kZXIoY29kZWMsIGNvbmZpZyksIG9mZnNldERlY29kZXIoY29kZWMsIGNvbmZpZykpO1xufVxuZnVuY3Rpb24gbW9kdWxvKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gIGlmIChkaXZpc29yID09PSAwKSByZXR1cm4gMDtcbiAgcmV0dXJuIChkaXZpZGVuZCAlIGRpdmlzb3IgKyBkaXZpc29yKSAlIGRpdmlzb3I7XG59XG5mdW5jdGlvbiByZXNpemVFbmNvZGVyKGVuY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZW5jb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZW5jb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRW5jb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoeyAuLi5lbmNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVuY29kZXIoe1xuICAgIC4uLmVuY29kZXIsXG4gICAgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBuZXdTaXplID0gcmVzaXplKGVuY29kZXIuZ2V0U2l6ZUZyb21WYWx1ZSh2YWx1ZSkpO1xuICAgICAgaWYgKG5ld1NpemUgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFFcnJvcihTT0xBTkFfRVJST1JfX0NPREVDU19fRVhQRUNURURfUE9TSVRJVkVfQllURV9MRU5HVEgsIHtcbiAgICAgICAgICBieXRlc0xlbmd0aDogbmV3U2l6ZSxcbiAgICAgICAgICBjb2RlY0Rlc2NyaXB0aW9uOiBcInJlc2l6ZUVuY29kZXJcIlxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXdTaXplO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiByZXNpemVEZWNvZGVyKGRlY29kZXIsIHJlc2l6ZSkge1xuICBpZiAoaXNGaXhlZFNpemUoZGVjb2RlcikpIHtcbiAgICBjb25zdCBmaXhlZFNpemUgPSByZXNpemUoZGVjb2Rlci5maXhlZFNpemUpO1xuICAgIGlmIChmaXhlZFNpemUgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hRXJyb3IoU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX1BPU0lUSVZFX0JZVEVfTEVOR1RILCB7XG4gICAgICAgIGJ5dGVzTGVuZ3RoOiBmaXhlZFNpemUsXG4gICAgICAgIGNvZGVjRGVzY3JpcHRpb246IFwicmVzaXplRGVjb2RlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZURlY29kZXIoeyAuLi5kZWNvZGVyLCBmaXhlZFNpemUgfSk7XG4gIH1cbiAgcmV0dXJuIGRlY29kZXI7XG59XG5mdW5jdGlvbiByZXNpemVDb2RlYyhjb2RlYywgcmVzaXplKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmVzaXplRW5jb2Rlcihjb2RlYywgcmVzaXplKSwgcmVzaXplRGVjb2Rlcihjb2RlYywgcmVzaXplKSk7XG59XG5cbi8vIHNyYy9wYWQtY29kZWMudHNcbmZ1bmN0aW9uIHBhZExlZnRFbmNvZGVyKGVuY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RW5jb2RlcihcbiAgICByZXNpemVFbmNvZGVyKGVuY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodEVuY29kZXIoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXRFbmNvZGVyKFxuICAgIHJlc2l6ZUVuY29kZXIoZW5jb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnREZWNvZGVyKGRlY29kZXIsIG9mZnNldCkge1xuICByZXR1cm4gb2Zmc2V0RGVjb2RlcihcbiAgICByZXNpemVEZWNvZGVyKGRlY29kZXIsIChzaXplKSA9PiBzaXplICsgb2Zmc2V0KSxcbiAgICB7IHByZU9mZnNldDogKHsgcHJlT2Zmc2V0IH0pID0+IHByZU9mZnNldCArIG9mZnNldCB9XG4gICk7XG59XG5mdW5jdGlvbiBwYWRSaWdodERlY29kZXIoZGVjb2Rlciwgb2Zmc2V0KSB7XG4gIHJldHVybiBvZmZzZXREZWNvZGVyKFxuICAgIHJlc2l6ZURlY29kZXIoZGVjb2RlciwgKHNpemUpID0+IHNpemUgKyBvZmZzZXQpLFxuICAgIHsgcG9zdE9mZnNldDogKHsgcG9zdE9mZnNldCB9KSA9PiBwb3N0T2Zmc2V0ICsgb2Zmc2V0IH1cbiAgKTtcbn1cbmZ1bmN0aW9uIHBhZExlZnRDb2RlYyhjb2RlYywgb2Zmc2V0KSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocGFkTGVmdEVuY29kZXIoY29kZWMsIG9mZnNldCksIHBhZExlZnREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cbmZ1bmN0aW9uIHBhZFJpZ2h0Q29kZWMoY29kZWMsIG9mZnNldCkge1xuICByZXR1cm4gY29tYmluZUNvZGVjKHBhZFJpZ2h0RW5jb2Rlcihjb2RlYywgb2Zmc2V0KSwgcGFkUmlnaHREZWNvZGVyKGNvZGVjLCBvZmZzZXQpKTtcbn1cblxuLy8gc3JjL3JldmVyc2UtY29kZWMudHNcbmZ1bmN0aW9uIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShzb3VyY2UsIHRhcmdldF9XSUxMX01VVEFURSwgc291cmNlT2Zmc2V0LCBzb3VyY2VMZW5ndGgsIHRhcmdldE9mZnNldCA9IDApIHtcbiAgd2hpbGUgKHNvdXJjZU9mZnNldCA8IC0tc291cmNlTGVuZ3RoKSB7XG4gICAgY29uc3QgbGVmdFZhbHVlID0gc291cmNlW3NvdXJjZU9mZnNldF07XG4gICAgdGFyZ2V0X1dJTExfTVVUQVRFW3NvdXJjZU9mZnNldCArIHRhcmdldE9mZnNldF0gPSBzb3VyY2Vbc291cmNlTGVuZ3RoXTtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlTGVuZ3RoICsgdGFyZ2V0T2Zmc2V0XSA9IGxlZnRWYWx1ZTtcbiAgICBzb3VyY2VPZmZzZXQrKztcbiAgfVxuICBpZiAoc291cmNlT2Zmc2V0ID09PSBzb3VyY2VMZW5ndGgpIHtcbiAgICB0YXJnZXRfV0lMTF9NVVRBVEVbc291cmNlT2Zmc2V0ICsgdGFyZ2V0T2Zmc2V0XSA9IHNvdXJjZVtzb3VyY2VPZmZzZXRdO1xuICB9XG59XG5mdW5jdGlvbiByZXZlcnNlRW5jb2RlcihlbmNvZGVyKSB7XG4gIGFzc2VydElzRml4ZWRTaXplKGVuY29kZXIpO1xuICByZXR1cm4gY3JlYXRlRW5jb2Rlcih7XG4gICAgLi4uZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiB7XG4gICAgICBjb25zdCBuZXdPZmZzZXQgPSBlbmNvZGVyLndyaXRlKHZhbHVlLCBieXRlcywgb2Zmc2V0KTtcbiAgICAgIGNvcHlTb3VyY2VUb1RhcmdldEluUmV2ZXJzZShcbiAgICAgICAgYnl0ZXMsXG4gICAgICAgIGJ5dGVzLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIG9mZnNldCArIGVuY29kZXIuZml4ZWRTaXplXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ld09mZnNldDtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZURlY29kZXIoZGVjb2Rlcikge1xuICBhc3NlcnRJc0ZpeGVkU2l6ZShkZWNvZGVyKTtcbiAgcmV0dXJuIGNyZWF0ZURlY29kZXIoe1xuICAgIC4uLmRlY29kZXIsXG4gICAgcmVhZDogKGJ5dGVzLCBvZmZzZXQpID0+IHtcbiAgICAgIGNvbnN0IHJldmVyc2VkQnl0ZXMgPSBieXRlcy5zbGljZSgpO1xuICAgICAgY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlKFxuICAgICAgICBieXRlcyxcbiAgICAgICAgcmV2ZXJzZWRCeXRlcyxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBvZmZzZXQgKyBkZWNvZGVyLmZpeGVkU2l6ZVxuICAgICAgKTtcbiAgICAgIHJldHVybiBkZWNvZGVyLnJlYWQocmV2ZXJzZWRCeXRlcywgb2Zmc2V0KTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gcmV2ZXJzZUNvZGVjKGNvZGVjKSB7XG4gIHJldHVybiBjb21iaW5lQ29kZWMocmV2ZXJzZUVuY29kZXIoY29kZWMpLCByZXZlcnNlRGVjb2Rlcihjb2RlYykpO1xufVxuXG4vLyBzcmMvdHJhbnNmb3JtLWNvZGVjLnRzXG5mdW5jdGlvbiB0cmFuc2Zvcm1FbmNvZGVyKGVuY29kZXIsIHVubWFwKSB7XG4gIHJldHVybiBjcmVhdGVFbmNvZGVyKHtcbiAgICAuLi5pc1ZhcmlhYmxlU2l6ZShlbmNvZGVyKSA/IHsgLi4uZW5jb2RlciwgZ2V0U2l6ZUZyb21WYWx1ZTogKHZhbHVlKSA9PiBlbmNvZGVyLmdldFNpemVGcm9tVmFsdWUodW5tYXAodmFsdWUpKSB9IDogZW5jb2RlcixcbiAgICB3cml0ZTogKHZhbHVlLCBieXRlcywgb2Zmc2V0KSA9PiBlbmNvZGVyLndyaXRlKHVubWFwKHZhbHVlKSwgYnl0ZXMsIG9mZnNldClcbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1EZWNvZGVyKGRlY29kZXIsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlRGVjb2Rlcih7XG4gICAgLi4uZGVjb2RlcixcbiAgICByZWFkOiAoYnl0ZXMsIG9mZnNldCkgPT4ge1xuICAgICAgY29uc3QgW3ZhbHVlLCBuZXdPZmZzZXRdID0gZGVjb2Rlci5yZWFkKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIFttYXAodmFsdWUsIGJ5dGVzLCBvZmZzZXQpLCBuZXdPZmZzZXRdO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1Db2RlYyhjb2RlYywgdW5tYXAsIG1hcCkge1xuICByZXR1cm4gY3JlYXRlQ29kZWMoe1xuICAgIC4uLnRyYW5zZm9ybUVuY29kZXIoY29kZWMsIHVubWFwKSxcbiAgICByZWFkOiBtYXAgPyB0cmFuc2Zvcm1EZWNvZGVyKGNvZGVjLCBtYXApLnJlYWQgOiBjb2RlYy5yZWFkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBhZGRDb2RlY1NlbnRpbmVsLCBhZGRDb2RlY1NpemVQcmVmaXgsIGFkZERlY29kZXJTZW50aW5lbCwgYWRkRGVjb2RlclNpemVQcmVmaXgsIGFkZEVuY29kZXJTZW50aW5lbCwgYWRkRW5jb2RlclNpemVQcmVmaXgsIGFzc2VydEJ5dGVBcnJheUhhc0Vub3VnaEJ5dGVzRm9yQ29kZWMsIGFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYywgYXNzZXJ0Qnl0ZUFycmF5T2Zmc2V0SXNOb3RPdXRPZlJhbmdlLCBhc3NlcnRJc0ZpeGVkU2l6ZSwgYXNzZXJ0SXNWYXJpYWJsZVNpemUsIGNvbWJpbmVDb2RlYywgY29udGFpbnNCeXRlcywgY3JlYXRlQ29kZWMsIGNyZWF0ZURlY29kZXIsIGNyZWF0ZUVuY29kZXIsIGZpeEJ5dGVzLCBmaXhDb2RlY1NpemUsIGZpeERlY29kZXJTaXplLCBmaXhFbmNvZGVyU2l6ZSwgZ2V0RW5jb2RlZFNpemUsIGlzRml4ZWRTaXplLCBpc1ZhcmlhYmxlU2l6ZSwgbWVyZ2VCeXRlcywgb2Zmc2V0Q29kZWMsIG9mZnNldERlY29kZXIsIG9mZnNldEVuY29kZXIsIHBhZEJ5dGVzLCBwYWRMZWZ0Q29kZWMsIHBhZExlZnREZWNvZGVyLCBwYWRMZWZ0RW5jb2RlciwgcGFkUmlnaHRDb2RlYywgcGFkUmlnaHREZWNvZGVyLCBwYWRSaWdodEVuY29kZXIsIHJlc2l6ZUNvZGVjLCByZXNpemVEZWNvZGVyLCByZXNpemVFbmNvZGVyLCByZXZlcnNlQ29kZWMsIHJldmVyc2VEZWNvZGVyLCByZXZlcnNlRW5jb2RlciwgdHJhbnNmb3JtQ29kZWMsIHRyYW5zZm9ybURlY29kZXIsIHRyYW5zZm9ybUVuY29kZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm5vZGUubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubm9kZS5tanMubWFwIl0sIm5hbWVzIjpbIlNvbGFuYUVycm9yIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0VYUEVDVEVEX0ZJWEVEX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9WQVJJQUJMRV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFUl9ERUNPREVSX1NJWkVfQ09NUEFUSUJJTElUWV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfRklYRURfU0laRV9NSVNNQVRDSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FTkNPREVSX0RFQ09ERVJfTUFYX1NJWkVfTUlTTUFUQ0giLCJTT0xBTkFfRVJST1JfX0NPREVDU19fQ0FOTk9UX0RFQ09ERV9FTVBUWV9CWVRFX0FSUkFZIiwiU09MQU5BX0VSUk9SX19DT0RFQ1NfX0lOVkFMSURfQllURV9MRU5HVEgiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fT0ZGU0VUX09VVF9PRl9SQU5HRSIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19FWFBFQ1RFRF9QT1NJVElWRV9CWVRFX0xFTkdUSCIsIlNPTEFOQV9FUlJPUl9fQ09ERUNTX19TRU5USU5FTF9NSVNTSU5HX0lOX0RFQ09ERURfQllURVMiLCJTT0xBTkFfRVJST1JfX0NPREVDU19fRU5DT0RFRF9CWVRFU19NVVNUX05PVF9JTkNMVURFX1NFTlRJTkVMIiwibWVyZ2VCeXRlcyIsImJ5dGVBcnJheXMiLCJub25FbXB0eUJ5dGVBcnJheXMiLCJmaWx0ZXIiLCJhcnIiLCJsZW5ndGgiLCJVaW50OEFycmF5IiwidG90YWxMZW5ndGgiLCJyZWR1Y2UiLCJ0b3RhbCIsInJlc3VsdCIsIm9mZnNldCIsImZvckVhY2giLCJzZXQiLCJwYWRCeXRlcyIsImJ5dGVzIiwicGFkZGVkQnl0ZXMiLCJmaWxsIiwiZml4Qnl0ZXMiLCJzbGljZSIsImNvbnRhaW5zQnl0ZXMiLCJkYXRhIiwiZXZlcnkiLCJiIiwiaSIsImdldEVuY29kZWRTaXplIiwidmFsdWUiLCJlbmNvZGVyIiwiZml4ZWRTaXplIiwiZ2V0U2l6ZUZyb21WYWx1ZSIsImNyZWF0ZUVuY29kZXIiLCJPYmplY3QiLCJmcmVlemUiLCJlbmNvZGUiLCJ3cml0ZSIsImNyZWF0ZURlY29kZXIiLCJkZWNvZGVyIiwiZGVjb2RlIiwicmVhZCIsImNyZWF0ZUNvZGVjIiwiY29kZWMiLCJpc0ZpeGVkU2l6ZSIsImFzc2VydElzRml4ZWRTaXplIiwiaXNWYXJpYWJsZVNpemUiLCJhc3NlcnRJc1ZhcmlhYmxlU2l6ZSIsImNvbWJpbmVDb2RlYyIsImRlY29kZXJGaXhlZFNpemUiLCJlbmNvZGVyRml4ZWRTaXplIiwibWF4U2l6ZSIsImRlY29kZXJNYXhTaXplIiwiZW5jb2Rlck1heFNpemUiLCJhZGRFbmNvZGVyU2VudGluZWwiLCJzZW50aW5lbCIsImVuY29kZXJCeXRlcyIsImZpbmRTZW50aW5lbEluZGV4IiwiZW5jb2RlZEJ5dGVzIiwiaGV4RW5jb2RlZEJ5dGVzIiwiaGV4Qnl0ZXMiLCJoZXhTZW50aW5lbCIsImFkZERlY29kZXJTZW50aW5lbCIsImNhbmRpZGF0ZUJ5dGVzIiwic2VudGluZWxJbmRleCIsImRlY29kZWRCeXRlcyIsImhleERlY29kZWRCeXRlcyIsInByZVNlbnRpbmVsQnl0ZXMiLCJhZGRDb2RlY1NlbnRpbmVsIiwiZmluZEluZGV4IiwiYnl0ZSIsImluZGV4Iiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCIsImFzc2VydEJ5dGVBcnJheUlzTm90RW1wdHlGb3JDb2RlYyIsImNvZGVjRGVzY3JpcHRpb24iLCJhc3NlcnRCeXRlQXJyYXlIYXNFbm91Z2hCeXRlc0ZvckNvZGVjIiwiZXhwZWN0ZWQiLCJieXRlc0xlbmd0aCIsImFzc2VydEJ5dGVBcnJheU9mZnNldElzTm90T3V0T2ZSYW5nZSIsImFkZEVuY29kZXJTaXplUHJlZml4IiwicHJlZml4IiwicHJlZml4TWF4U2l6ZSIsImVuY29kZXJTaXplIiwiYWRkRGVjb2RlclNpemVQcmVmaXgiLCJiaWdpbnRTaXplIiwiZGVjb2Rlck9mZnNldCIsInNpemUiLCJOdW1iZXIiLCJhZGRDb2RlY1NpemVQcmVmaXgiLCJmaXhFbmNvZGVyU2l6ZSIsImZpeGVkQnl0ZXMiLCJ2YXJpYWJsZUJ5dGVBcnJheSIsImZpeGVkQnl0ZUFycmF5IiwiZml4RGVjb2RlclNpemUiLCJmaXhDb2RlY1NpemUiLCJvZmZzZXRFbmNvZGVyIiwiY29uZmlnIiwicHJlT2Zmc2V0Iiwid3JhcEJ5dGVzIiwibW9kdWxvIiwibmV3UHJlT2Zmc2V0IiwicG9zdE9mZnNldCIsIm5ld1Bvc3RPZmZzZXQiLCJvZmZzZXREZWNvZGVyIiwib2Zmc2V0Q29kZWMiLCJkaXZpZGVuZCIsImRpdmlzb3IiLCJyZXNpemVFbmNvZGVyIiwicmVzaXplIiwibmV3U2l6ZSIsInJlc2l6ZURlY29kZXIiLCJyZXNpemVDb2RlYyIsInBhZExlZnRFbmNvZGVyIiwicGFkUmlnaHRFbmNvZGVyIiwicGFkTGVmdERlY29kZXIiLCJwYWRSaWdodERlY29kZXIiLCJwYWRMZWZ0Q29kZWMiLCJwYWRSaWdodENvZGVjIiwiY29weVNvdXJjZVRvVGFyZ2V0SW5SZXZlcnNlIiwic291cmNlIiwidGFyZ2V0X1dJTExfTVVUQVRFIiwic291cmNlT2Zmc2V0Iiwic291cmNlTGVuZ3RoIiwidGFyZ2V0T2Zmc2V0IiwibGVmdFZhbHVlIiwicmV2ZXJzZUVuY29kZXIiLCJuZXdPZmZzZXQiLCJyZXZlcnNlRGVjb2RlciIsInJldmVyc2VkQnl0ZXMiLCJyZXZlcnNlQ29kZWMiLCJ0cmFuc2Zvcm1FbmNvZGVyIiwidW5tYXAiLCJ0cmFuc2Zvcm1EZWNvZGVyIiwibWFwIiwidHJhbnNmb3JtQ29kZWMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.3.3/node_modules/@solana/codecs-core/dist/index.node.mjs\n");

/***/ })

};
;