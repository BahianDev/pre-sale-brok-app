"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/decimal.js@10.6.0";
exports.ids = ["vendor-chunks/decimal.js@10.6.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decimal: () => (/* binding */ Decimal),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/*!\r\n *  decimal.js v10.6.0\r\n *  An arbitrary-precision Decimal type for JavaScript.\r\n *  https://github.com/MikeMcl/decimal.js\r\n *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *  MIT Licence\r\n */ // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n// The maximum exponent magnitude.\n// The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\nvar EXP_LIMIT = 9e15, // The limit on the value of `precision`, and on the value of the first argument to\n// `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\nMAX_DIGITS = 1e9, // Base conversion alphabet.\nNUMERALS = \"0123456789abcdef\", // The natural logarithm of 10 (1025 digits).\nLN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", // Pi (1025 digits).\nPI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", // The initial configuration properties of the Decimal constructor.\nDEFAULTS = {\n    // These values must be integers within the stated ranges (inclusive).\n    // Most of these values can be changed at run-time using the `Decimal.config` method.\n    // The maximum number of significant digits of the result of a calculation or base conversion.\n    // E.g. `Decimal.config({ precision: 20 });`\n    precision: 20,\n    // The rounding mode used when rounding to `precision`.\n    //\n    // ROUND_UP         0 Away from zero.\n    // ROUND_DOWN       1 Towards zero.\n    // ROUND_CEIL       2 Towards +Infinity.\n    // ROUND_FLOOR      3 Towards -Infinity.\n    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n    //\n    // E.g.\n    // `Decimal.rounding = 4;`\n    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n    rounding: 4,\n    // The modulo mode used when calculating the modulus: a mod n.\n    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n    // The remainder (r) is calculated as: r = a - n * q.\n    //\n    // UP         0 The remainder is positive if the dividend is negative, else is negative.\n    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n    // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n    // HALF_EVEN  6 The IEEE 754 remainder function.\n    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n    //\n    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n    // division (9) are commonly used for the modulus operation. The other rounding modes can also\n    // be used, but they may not give useful results.\n    modulo: 1,\n    // The exponent value at and beneath which `toString` returns exponential notation.\n    // JavaScript numbers: -7\n    toExpNeg: -7,\n    // The exponent value at and above which `toString` returns exponential notation.\n    // JavaScript numbers: 21\n    toExpPos: 21,\n    // The minimum exponent value, beneath which underflow to zero occurs.\n    // JavaScript numbers: -324  (5e-324)\n    minE: -EXP_LIMIT,\n    // The maximum exponent value, above which overflow to Infinity occurs.\n    // JavaScript numbers: 308  (1.7976931348623157e+308)\n    maxE: EXP_LIMIT,\n    // Whether to use cryptographically-secure random number generation, if available.\n    crypto: false // true/false\n}, // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\ninexact, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", tag = \"[object Decimal]\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, // Decimal.prototype object\nP = {\n    toStringTag: tag\n};\n// Decimal prototype methods\n/*\r\n *  absoluteValue             abs\r\n *  ceil\r\n *  clampedTo                 clamp\r\n *  comparedTo                cmp\r\n *  cosine                    cos\r\n *  cubeRoot                  cbrt\r\n *  decimalPlaces             dp\r\n *  dividedBy                 div\r\n *  dividedToIntegerBy        divToInt\r\n *  equals                    eq\r\n *  floor\r\n *  greaterThan               gt\r\n *  greaterThanOrEqualTo      gte\r\n *  hyperbolicCosine          cosh\r\n *  hyperbolicSine            sinh\r\n *  hyperbolicTangent         tanh\r\n *  inverseCosine             acos\r\n *  inverseHyperbolicCosine   acosh\r\n *  inverseHyperbolicSine     asinh\r\n *  inverseHyperbolicTangent  atanh\r\n *  inverseSine               asin\r\n *  inverseTangent            atan\r\n *  isFinite\r\n *  isInteger                 isInt\r\n *  isNaN\r\n *  isNegative                isNeg\r\n *  isPositive                isPos\r\n *  isZero\r\n *  lessThan                  lt\r\n *  lessThanOrEqualTo         lte\r\n *  logarithm                 log\r\n *  [maximum]                 [max]\r\n *  [minimum]                 [min]\r\n *  minus                     sub\r\n *  modulo                    mod\r\n *  naturalExponential        exp\r\n *  naturalLogarithm          ln\r\n *  negated                   neg\r\n *  plus                      add\r\n *  precision                 sd\r\n *  round\r\n *  sine                      sin\r\n *  squareRoot                sqrt\r\n *  tangent                   tan\r\n *  times                     mul\r\n *  toBinary\r\n *  toDecimalPlaces           toDP\r\n *  toExponential\r\n *  toFixed\r\n *  toFraction\r\n *  toHexadecimal             toHex\r\n *  toNearest\r\n *  toNumber\r\n *  toOctal\r\n *  toPower                   pow\r\n *  toPrecision\r\n *  toSignificantDigits       toSD\r\n *  toString\r\n *  truncated                 trunc\r\n *  valueOf                   toJSON\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of this Decimal.\r\n *\r\n */ P.absoluteValue = P.abs = function() {\n    var x = new this.constructor(this);\n    if (x.s < 0) x.s = 1;\n    return finalise(x);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of positive Infinity.\r\n *\r\n */ P.ceil = function() {\n    return finalise(new this.constructor(this), this.e + 1, 2);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n * delineated by `min` and `max`.\r\n *\r\n * min {number|string|bigint|Decimal}\r\n * max {number|string|bigint|Decimal}\r\n *\r\n */ P.clampedTo = P.clamp = function(min, max) {\n    var k, x = this, Ctor = x.constructor;\n    min = new Ctor(min);\n    max = new Ctor(max);\n    if (!min.s || !max.s) return new Ctor(NaN);\n    if (min.gt(max)) throw Error(invalidArgument + max);\n    k = x.cmp(min);\n    return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\n};\n/*\r\n * Return\r\n *   1    if the value of this Decimal is greater than the value of `y`,\r\n *  -1    if the value of this Decimal is less than the value of `y`,\r\n *   0    if they have the same value,\r\n *   NaN  if the value of either Decimal is NaN.\r\n *\r\n */ P.comparedTo = P.cmp = function(y) {\n    var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n    // Either NaN or ±Infinity?\n    if (!xd || !yd) {\n        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n    }\n    // Either zero?\n    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n    // Signs differ?\n    if (xs !== ys) return xs;\n    // Compare exponents.\n    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n    xdL = xd.length;\n    ydL = yd.length;\n    // Compare digit by digit.\n    for(i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i){\n        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n    }\n    // Compare lengths.\n    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n};\n/*\r\n * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * cos(0)         = 1\r\n * cos(-0)        = 1\r\n * cos(Infinity)  = NaN\r\n * cos(-Infinity) = NaN\r\n * cos(NaN)       = NaN\r\n *\r\n */ P.cosine = P.cos = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.d) return new Ctor(NaN);\n    // cos(0) = cos(-0) = 1\n    if (!x.d[0]) return new Ctor(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *\r\n * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n *  cbrt(0)  =  0\r\n *  cbrt(-0) = -0\r\n *  cbrt(1)  =  1\r\n *  cbrt(-1) = -1\r\n *  cbrt(N)  =  N\r\n *  cbrt(-I) = -I\r\n *  cbrt(I)  =  I\r\n *\r\n * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n *\r\n */ P.cubeRoot = P.cbrt = function() {\n    var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    external = false;\n    // Initial estimate.\n    s = x.s * mathpow(x.s * x, 1 / 3);\n    // Math.cbrt underflow/overflow?\n    // Pass x to Math.pow as integer, then adjust the exponent of the result.\n    if (!s || Math.abs(s) == 1 / 0) {\n        n = digitsToString(x.d);\n        e = x.e;\n        // Adjust n exponent so it is a multiple of 3 away from x exponent.\n        if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n        s = mathpow(n, 1 / 3);\n        // Rarely, e may be one less than the result exponent value.\n        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n        r.s = x.s;\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Halley's method.\n    // TODO? Compare Newton's method.\n    for(;;){\n        t = r;\n        t3 = t.times(t).times(t);\n        t3plusx = t3.plus(x);\n        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n            // , i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return the number of decimal places of the value of this Decimal.\r\n *\r\n */ P.decimalPlaces = P.dp = function() {\n    var w, d = this.d, n = NaN;\n    if (d) {\n        w = d.length - 1;\n        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n        // Subtract the number of trailing zeros of the last word.\n        w = d[w];\n        if (w) for(; w % 10 == 0; w /= 10)n--;\n        if (n < 0) n = 0;\n    }\n    return n;\n};\n/*\r\n *  n / 0 = I\r\n *  n / N = N\r\n *  n / I = 0\r\n *  0 / n = 0\r\n *  0 / 0 = N\r\n *  0 / N = N\r\n *  0 / I = 0\r\n *  N / n = N\r\n *  N / 0 = N\r\n *  N / N = N\r\n *  N / I = N\r\n *  I / n = I\r\n *  I / 0 = I\r\n *  I / N = N\r\n *  I / I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedBy = P.div = function(y) {\n    return divide(this, new this.constructor(y));\n};\n/*\r\n * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.dividedToIntegerBy = P.divToInt = function(y) {\n    var x = this, Ctor = x.constructor;\n    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n};\n/*\r\n * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n *\r\n */ P.equals = P.eq = function(y) {\n    return this.cmp(y) === 0;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n * direction of negative Infinity.\r\n *\r\n */ P.floor = function() {\n    return finalise(new this.constructor(this), this.e + 1, 3);\n};\n/*\r\n * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n * false.\r\n *\r\n */ P.greaterThan = P.gt = function(y) {\n    return this.cmp(y) > 0;\n};\n/*\r\n * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n * otherwise return false.\r\n *\r\n */ P.greaterThanOrEqualTo = P.gte = function(y) {\n    var k = this.cmp(y);\n    return k == 1 || k === 0;\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [1, Infinity]\r\n *\r\n * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n *\r\n * cosh(0)         = 1\r\n * cosh(-0)        = 1\r\n * cosh(Infinity)  = Infinity\r\n * cosh(-Infinity) = Infinity\r\n * cosh(NaN)       = NaN\r\n *\r\n *  x        time taken (ms)   result\r\n * 1000      9                 9.8503555700852349694e+433\r\n * 10000     25                4.4034091128314607936e+4342\r\n * 100000    171               1.4033316802130615897e+43429\r\n * 1000000   3817              1.5166076984010437725e+434294\r\n * 10000000  abandoned after 2 minute wait\r\n *\r\n * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n *\r\n */ P.hyperbolicCosine = P.cosh = function() {\n    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n    if (x.isZero()) return one;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n    // Estimate the optimum number of times to use the argument reduction.\n    // TODO? Estimation reused from cosine() and may not be optimal here.\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        n = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        n = \"2.3283064365386962890625e-10\";\n    }\n    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n    // Reverse argument reduction\n    var cosh2_x, i = k, d8 = new Ctor(8);\n    for(; i--;){\n        cosh2_x = x.times(x);\n        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n    }\n    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n *\r\n * sinh(0)         = 0\r\n * sinh(-0)        = -0\r\n * sinh(Infinity)  = Infinity\r\n * sinh(-Infinity) = -Infinity\r\n * sinh(NaN)       = NaN\r\n *\r\n * x        time taken (ms)\r\n * 10       2 ms\r\n * 100      5 ms\r\n * 1000     14 ms\r\n * 10000    82 ms\r\n * 100000   886 ms            1.4033316802130615897e+43429\r\n * 200000   2613 ms\r\n * 300000   5407 ms\r\n * 400000   8824 ms\r\n * 500000   13026 ms          8.7080643612718084129e+217146\r\n * 1000000  48543 ms\r\n *\r\n * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n *\r\n */ P.hyperbolicSine = P.sinh = function() {\n    var k, pr, rm, len, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n    Ctor.rounding = 1;\n    len = x.d.length;\n    if (len < 3) {\n        x = taylorSeries(Ctor, 2, x, x, true);\n    } else {\n        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n        // 3 multiplications and 1 addition\n        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n        // 4 multiplications and 2 additions\n        // Estimate the optimum number of times to use the argument reduction.\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x, true);\n        // Reverse argument reduction\n        var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for(; k--;){\n            sinh2_x = x.times(x);\n            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n        }\n    }\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * tanh(x) = sinh(x) / cosh(x)\r\n *\r\n * tanh(0)         = 0\r\n * tanh(-0)        = -0\r\n * tanh(Infinity)  = 1\r\n * tanh(-Infinity) = -1\r\n * tanh(NaN)       = NaN\r\n *\r\n */ P.hyperbolicTangent = P.tanh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(x.s);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 7;\n    Ctor.rounding = 1;\n    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n};\n/*\r\n * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n * this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [0, pi]\r\n *\r\n * acos(x) = pi/2 - asin(x)\r\n *\r\n * acos(0)       = pi/2\r\n * acos(-0)      = pi/2\r\n * acos(1)       = 0\r\n * acos(-1)      = pi\r\n * acos(1/2)     = pi/3\r\n * acos(-1/2)    = 2*pi/3\r\n * acos(|x| > 1) = NaN\r\n * acos(NaN)     = NaN\r\n *\r\n */ P.inverseCosine = P.acos = function() {\n    var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n    if (k !== -1) {\n        return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n    }\n    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    // See https://github.com/MikeMcl/decimal.js/pull/217\n    x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [1, Infinity]\r\n * Range: [0, Infinity]\r\n *\r\n * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n *\r\n * acosh(x < 1)     = NaN\r\n * acosh(NaN)       = NaN\r\n * acosh(Infinity)  = Infinity\r\n * acosh(-Infinity) = NaN\r\n * acosh(0)         = NaN\r\n * acosh(-0)        = NaN\r\n * acosh(1)         = 0\r\n * acosh(-1)        = NaN\r\n *\r\n */ P.inverseHyperbolicCosine = P.acosh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n    if (!x.isFinite()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).minus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n *\r\n * asinh(NaN)       = NaN\r\n * asinh(Infinity)  = Infinity\r\n * asinh(-Infinity) = -Infinity\r\n * asinh(0)         = 0\r\n * asinh(-0)        = -0\r\n *\r\n */ P.inverseHyperbolicSine = P.asinh = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite() || x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n    Ctor.rounding = 1;\n    external = false;\n    x = x.times(x).plus(1).sqrt().plus(x);\n    external = true;\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.ln();\n};\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n * value of this Decimal.\r\n *\r\n * Domain: [-1, 1]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n *\r\n * atanh(|x| > 1)   = NaN\r\n * atanh(NaN)       = NaN\r\n * atanh(Infinity)  = NaN\r\n * atanh(-Infinity) = NaN\r\n * atanh(0)         = 0\r\n * atanh(-0)        = -0\r\n * atanh(1)         = Infinity\r\n * atanh(-1)        = -Infinity\r\n *\r\n */ P.inverseHyperbolicTangent = P.atanh = function() {\n    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    xsd = x.sd();\n    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n    Ctor.precision = wpr = xsd - x.e;\n    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n    Ctor.precision = pr + 4;\n    Ctor.rounding = 1;\n    x = x.ln();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(0.5);\n};\n/*\r\n * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n * Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n *\r\n * asin(0)       = 0\r\n * asin(-0)      = -0\r\n * asin(1/2)     = pi/6\r\n * asin(-1/2)    = -pi/6\r\n * asin(1)       = pi/2\r\n * asin(-1)      = -pi/2\r\n * asin(|x| > 1) = NaN\r\n * asin(NaN)     = NaN\r\n *\r\n * TODO? Compare performance of Taylor series.\r\n *\r\n */ P.inverseSine = P.asin = function() {\n    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n    if (x.isZero()) return new Ctor(x);\n    k = x.abs().cmp(1);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (k !== -1) {\n        // |x| is 1\n        if (k === 0) {\n            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n            halfPi.s = x.s;\n            return halfPi;\n        }\n        // |x| > 1 or x is NaN\n        return new Ctor(NaN);\n    }\n    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n    Ctor.precision = pr + 6;\n    Ctor.rounding = 1;\n    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return x.times(2);\n};\n/*\r\n * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n * of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi/2, pi/2]\r\n *\r\n * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n *\r\n * atan(0)         = 0\r\n * atan(-0)        = -0\r\n * atan(1)         = pi/4\r\n * atan(-1)        = -pi/4\r\n * atan(Infinity)  = pi/2\r\n * atan(-Infinity) = -pi/2\r\n * atan(NaN)       = NaN\r\n *\r\n */ P.inverseTangent = P.atan = function() {\n    var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n    if (!x.isFinite()) {\n        if (!x.s) return new Ctor(NaN);\n        if (pr + 4 <= PI_PRECISION) {\n            r = getPi(Ctor, pr + 4, rm).times(0.5);\n            r.s = x.s;\n            return r;\n        }\n    } else if (x.isZero()) {\n        return new Ctor(x);\n    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n        r = getPi(Ctor, pr + 4, rm).times(0.25);\n        r.s = x.s;\n        return r;\n    }\n    Ctor.precision = wpr = pr + 10;\n    Ctor.rounding = 1;\n    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n    // Argument reduction\n    // Ensure |x| < 0.42\n    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n    k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n    for(i = k; i; --i)x = x.div(x.times(x).plus(1).sqrt().plus(1));\n    external = false;\n    j = Math.ceil(wpr / LOG_BASE);\n    n = 1;\n    x2 = x.times(x);\n    r = new Ctor(x);\n    px = x;\n    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n    for(; i !== -1;){\n        px = px.times(x2);\n        t = r.minus(px.div(n += 2));\n        px = px.times(x2);\n        r = t.plus(px.div(n += 2));\n        if (r.d[j] !== void 0) for(i = j; r.d[i] === t.d[i] && i--;);\n    }\n    if (k) r = r.times(2 << k - 1);\n    external = true;\n    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n};\n/*\r\n * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n *\r\n */ P.isFinite = function() {\n    return !!this.d;\n};\n/*\r\n * Return true if the value of this Decimal is an integer, otherwise return false.\r\n *\r\n */ P.isInteger = P.isInt = function() {\n    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n};\n/*\r\n * Return true if the value of this Decimal is NaN, otherwise return false.\r\n *\r\n */ P.isNaN = function() {\n    return !this.s;\n};\n/*\r\n * Return true if the value of this Decimal is negative, otherwise return false.\r\n *\r\n */ P.isNegative = P.isNeg = function() {\n    return this.s < 0;\n};\n/*\r\n * Return true if the value of this Decimal is positive, otherwise return false.\r\n *\r\n */ P.isPositive = P.isPos = function() {\n    return this.s > 0;\n};\n/*\r\n * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n *\r\n */ P.isZero = function() {\n    return !!this.d && this.d[0] === 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n *\r\n */ P.lessThan = P.lt = function(y) {\n    return this.cmp(y) < 0;\n};\n/*\r\n * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n *\r\n */ P.lessThanOrEqualTo = P.lte = function(y) {\n    return this.cmp(y) < 1;\n};\n/*\r\n * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * If no base is specified, return log[10](arg).\r\n *\r\n * log[base](arg) = ln(arg) / ln(base)\r\n *\r\n * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n * otherwise:\r\n *\r\n * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n *\r\n * log[-b](a)       = NaN\r\n * log[0](a)        = NaN\r\n * log[1](a)        = NaN\r\n * log[NaN](a)      = NaN\r\n * log[Infinity](a) = NaN\r\n * log[b](0)        = -Infinity\r\n * log[b](-0)       = -Infinity\r\n * log[b](-a)       = NaN\r\n * log[b](1)        = 0\r\n * log[b](Infinity) = Infinity\r\n * log[b](NaN)      = NaN\r\n *\r\n * [base] {number|string|bigint|Decimal} The base of the logarithm.\r\n *\r\n */ P.logarithm = P.log = function(base) {\n    var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n    // Default base is 10.\n    if (base == null) {\n        base = new Ctor(10);\n        isBase10 = true;\n    } else {\n        base = new Ctor(base);\n        d = base.d;\n        // Return NaN if base is negative, or non-finite, or is 0 or 1.\n        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n        isBase10 = base.eq(10);\n    }\n    d = arg.d;\n    // Is arg negative, non-finite, 0 or 1?\n    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n    }\n    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n    // integer power of 10.\n    if (isBase10) {\n        if (d.length > 1) {\n            inf = true;\n        } else {\n            for(k = d[0]; k % 10 === 0;)k /= 10;\n            inf = k !== 1;\n        }\n    }\n    external = false;\n    sd = pr + guard;\n    num = naturalLogarithm(arg, sd);\n    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n    // The result will have 5 rounding digits.\n    r = divide(num, denominator, sd, 1);\n    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n    // calculate 10 further digits.\n    //\n    // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n    // that the result is above or below the boundary. Otherwise, if after calculating the 10\n    // further digits, the last 14 are nines, round up and assume the result is exact.\n    // Also assume the result is exact if the last 14 are zero.\n    //\n    // Example of a result that will be incorrectly rounded:\n    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n    // place is still 2.6.\n    if (checkRoundingDigits(r.d, k = pr, rm)) {\n        do {\n            sd += 10;\n            num = naturalLogarithm(arg, sd);\n            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n            r = divide(num, denominator, sd, 1);\n            if (!inf) {\n                // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n                if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n                    r = finalise(r, pr + 1, 0);\n                }\n                break;\n            }\n        }while (checkRoundingDigits(r.d, k += 10, rm));\n    }\n    external = true;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\nP.max = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, -1);\r\n};\r\n */ /*\r\n * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\nP.min = function () {\r\n  Array.prototype.push.call(arguments, this);\r\n  return maxOrMin(this.constructor, arguments, 1);\r\n};\r\n */ /*\r\n *  n - 0 = n\r\n *  n - N = N\r\n *  n - I = -I\r\n *  0 - n = -n\r\n *  0 - 0 = 0\r\n *  0 - N = N\r\n *  0 - I = -I\r\n *  N - n = N\r\n *  N - 0 = N\r\n *  N - N = N\r\n *  N - I = N\r\n *  I - n = I\r\n *  I - 0 = I\r\n *  I - N = N\r\n *  I - I = N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.minus = P.sub = function(y) {\n    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (x.d) y.s = -y.s;\n        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.plus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return y negated if x is zero and y is non-zero.\n        if (yd[0]) y.s = -y.s;\n        else if (xd[0]) y = new Ctor(x);\n        else return new Ctor(rm === 3 ? -0 : 0);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    e = mathfloor(y.e / LOG_BASE);\n    xe = mathfloor(x.e / LOG_BASE);\n    xd = xd.slice();\n    k = xe - e;\n    // If base 1e7 exponents differ...\n    if (k) {\n        xLTy = k < 0;\n        if (xLTy) {\n            d = xd;\n            k = -k;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = xe;\n            len = xd.length;\n        }\n        // Numbers with massively different exponents would result in a very high number of\n        // zeros needing to be prepended, but this can be avoided while still ensuring correct\n        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n        if (k > i) {\n            k = i;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents.\n        d.reverse();\n        for(i = k; i--;)d.push(0);\n        d.reverse();\n    // Base 1e7 exponents equal.\n    } else {\n        // Check digits to determine which is the bigger number.\n        i = xd.length;\n        len = yd.length;\n        xLTy = i < len;\n        if (xLTy) len = i;\n        for(i = 0; i < len; i++){\n            if (xd[i] != yd[i]) {\n                xLTy = xd[i] < yd[i];\n                break;\n            }\n        }\n        k = 0;\n    }\n    if (xLTy) {\n        d = xd;\n        xd = yd;\n        yd = d;\n        y.s = -y.s;\n    }\n    len = xd.length;\n    // Append zeros to `xd` if shorter.\n    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n    for(i = yd.length - len; i > 0; --i)xd[len++] = 0;\n    // Subtract yd from xd.\n    for(i = yd.length; i > k;){\n        if (xd[--i] < yd[i]) {\n            for(j = i; j && xd[--j] === 0;)xd[j] = BASE - 1;\n            --xd[j];\n            xd[i] += BASE;\n        }\n        xd[i] -= yd[i];\n    }\n    // Remove trailing zeros.\n    for(; xd[--len] === 0;)xd.pop();\n    // Remove leading zeros and adjust exponent accordingly.\n    for(; xd[0] === 0; xd.shift())--e;\n    // Zero?\n    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n *   n % 0 =  N\r\n *   n % N =  N\r\n *   n % I =  n\r\n *   0 % n =  0\r\n *  -0 % n = -0\r\n *   0 % 0 =  N\r\n *   0 % N =  N\r\n *   0 % I =  0\r\n *   N % n =  N\r\n *   N % 0 =  N\r\n *   N % N =  N\r\n *   N % I =  N\r\n *   I % n =  N\r\n *   I % 0 =  N\r\n *   I % N =  N\r\n *   I % I =  N\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * The result depends on the modulo mode.\r\n *\r\n */ P.modulo = P.mod = function(y) {\n    var q, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\n    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n    // Return x if y is ±Infinity or x is ±0.\n    if (!y.d || x.d && !x.d[0]) {\n        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n    }\n    // Prevent rounding of intermediate calculations.\n    external = false;\n    if (Ctor.modulo == 9) {\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\n        // result = x - q * y    where  0 <= result < abs(y)\n        q = divide(x, y.abs(), 0, 3, 1);\n        q.s *= y.s;\n    } else {\n        q = divide(x, y, 0, Ctor.modulo, 1);\n    }\n    q = q.times(y);\n    external = true;\n    return x.minus(q);\n};\n/*\r\n * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalExponential = P.exp = function() {\n    return naturalExponential(this);\n};\n/*\r\n * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n */ P.naturalLogarithm = P.ln = function() {\n    return naturalLogarithm(this);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n * -1.\r\n *\r\n */ P.negated = P.neg = function() {\n    var x = new this.constructor(this);\n    x.s = -x.s;\n    return finalise(x);\n};\n/*\r\n *  n + 0 = n\r\n *  n + N = N\r\n *  n + I = I\r\n *  0 + n = n\r\n *  0 + 0 = 0\r\n *  0 + N = N\r\n *  0 + I = I\r\n *  N + n = N\r\n *  N + 0 = N\r\n *  N + N = N\r\n *  N + I = N\r\n *  I + n = I\r\n *  I + 0 = I\r\n *  I + N = N\r\n *  I + I = I\r\n *\r\n * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n */ P.plus = P.add = function(y) {\n    var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n    y = new Ctor(y);\n    // If either is not finite...\n    if (!x.d || !y.d) {\n        // Return NaN if either is NaN.\n        if (!x.s || !y.s) y = new Ctor(NaN);\n        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n        return y;\n    }\n    // If signs differ...\n    if (x.s != y.s) {\n        y.s = -y.s;\n        return x.minus(y);\n    }\n    xd = x.d;\n    yd = y.d;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    // If either is zero...\n    if (!xd[0] || !yd[0]) {\n        // Return x if y is zero.\n        // Return y if y is non-zero.\n        if (!yd[0]) y = new Ctor(x);\n        return external ? finalise(y, pr, rm) : y;\n    }\n    // x and y are finite, non-zero numbers with the same sign.\n    // Calculate base 1e7 exponents.\n    k = mathfloor(x.e / LOG_BASE);\n    e = mathfloor(y.e / LOG_BASE);\n    xd = xd.slice();\n    i = k - e;\n    // If base 1e7 exponents differ...\n    if (i) {\n        if (i < 0) {\n            d = xd;\n            i = -i;\n            len = yd.length;\n        } else {\n            d = yd;\n            e = k;\n            len = xd.length;\n        }\n        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n        k = Math.ceil(pr / LOG_BASE);\n        len = k > len ? k + 1 : len + 1;\n        if (i > len) {\n            i = len;\n            d.length = 1;\n        }\n        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n        d.reverse();\n        for(; i--;)d.push(0);\n        d.reverse();\n    }\n    len = xd.length;\n    i = yd.length;\n    // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n    if (len - i < 0) {\n        i = len;\n        d = yd;\n        yd = xd;\n        xd = d;\n    }\n    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n    for(carry = 0; i;){\n        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n        xd[i] %= BASE;\n    }\n    if (carry) {\n        xd.unshift(carry);\n        ++e;\n    }\n    // Remove trailing zeros.\n    // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n    for(len = xd.length; xd[--len] == 0;)xd.pop();\n    y.d = xd;\n    y.e = getBase10Exponent(xd, e);\n    return external ? finalise(y, pr, rm) : y;\n};\n/*\r\n * Return the number of significant digits of the value of this Decimal.\r\n *\r\n * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n *\r\n */ P.precision = P.sd = function(z) {\n    var k, x = this;\n    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n    if (x.d) {\n        k = getPrecision(x.d);\n        if (z && x.e + 1 > k) k = x.e + 1;\n    } else {\n        k = NaN;\n    }\n    return k;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n * rounding mode `rounding`.\r\n *\r\n */ P.round = function() {\n    var x = this, Ctor = x.constructor;\n    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n};\n/*\r\n * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-1, 1]\r\n *\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n *\r\n * sin(0)         = 0\r\n * sin(-0)        = -0\r\n * sin(Infinity)  = NaN\r\n * sin(-Infinity) = NaN\r\n * sin(NaN)       = NaN\r\n *\r\n */ P.sine = P.sin = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n    Ctor.rounding = 1;\n    x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n *  sqrt(-n) =  N\r\n *  sqrt(N)  =  N\r\n *  sqrt(-I) =  N\r\n *  sqrt(I)  =  I\r\n *  sqrt(0)  =  0\r\n *  sqrt(-0) = -0\r\n *\r\n */ P.squareRoot = P.sqrt = function() {\n    var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n    // Negative/NaN/Infinity/zero?\n    if (s !== 1 || !d || !d[0]) {\n        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n    }\n    external = false;\n    // Initial estimate.\n    s = Math.sqrt(+x);\n    // Math.sqrt underflow/overflow?\n    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n    if (s == 0 || s == 1 / 0) {\n        n = digitsToString(d);\n        if ((n.length + e) % 2 == 0) n += \"0\";\n        s = Math.sqrt(n);\n        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n        if (s == 1 / 0) {\n            n = \"5e\" + e;\n        } else {\n            n = s.toExponential();\n            n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n        }\n        r = new Ctor(n);\n    } else {\n        r = new Ctor(s.toString());\n    }\n    sd = (e = Ctor.precision) + 3;\n    // Newton-Raphson iteration.\n    for(;;){\n        t = r;\n        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n        // TODO? Replace with for-loop and checkRoundingDigits.\n        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n            n = n.slice(sd - 3, sd + 1);\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n            // 4999, i.e. approaching a rounding boundary, continue the iteration.\n            if (n == \"9999\" || !rep && n == \"4999\") {\n                // On the first iteration only, check to see if rounding up gives the exact result as the\n                // nines may infinitely repeat.\n                if (!rep) {\n                    finalise(t, e + 1, 0);\n                    if (t.times(t).eq(x)) {\n                        r = t;\n                        break;\n                    }\n                }\n                sd += 4;\n                rep = 1;\n            } else {\n                // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                // If not, then there are further digits and m will be truthy.\n                if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                    // Truncate to the first rounding digit.\n                    finalise(r, e + 1, 1);\n                    m = !r.times(r).eq(x);\n                }\n                break;\n            }\n        }\n    }\n    external = true;\n    return finalise(r, e, Ctor.rounding, m);\n};\n/*\r\n * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-Infinity, Infinity]\r\n *\r\n * tan(0)         = 0\r\n * tan(-0)        = -0\r\n * tan(Infinity)  = NaN\r\n * tan(-Infinity) = NaN\r\n * tan(NaN)       = NaN\r\n *\r\n */ P.tangent = P.tan = function() {\n    var pr, rm, x = this, Ctor = x.constructor;\n    if (!x.isFinite()) return new Ctor(NaN);\n    if (x.isZero()) return new Ctor(x);\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    Ctor.precision = pr + 10;\n    Ctor.rounding = 1;\n    x = x.sin();\n    x.s = 1;\n    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n    Ctor.precision = pr;\n    Ctor.rounding = rm;\n    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n};\n/*\r\n *  n * 0 = 0\r\n *  n * N = N\r\n *  n * I = I\r\n *  0 * n = 0\r\n *  0 * 0 = 0\r\n *  0 * N = N\r\n *  0 * I = N\r\n *  N * n = N\r\n *  N * 0 = N\r\n *  N * N = N\r\n *  N * I = N\r\n *  I * n = I\r\n *  I * 0 = N\r\n *  I * N = N\r\n *  I * I = I\r\n *\r\n * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n */ P.times = P.mul = function(y) {\n    var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n    y.s *= x.s;\n    // If either is NaN, ±Infinity or ±0...\n    if (!xd || !xd[0] || !yd || !yd[0]) {\n        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n    }\n    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n    xdL = xd.length;\n    ydL = yd.length;\n    // Ensure xd points to the longer array.\n    if (xdL < ydL) {\n        r = xd;\n        xd = yd;\n        yd = r;\n        rL = xdL;\n        xdL = ydL;\n        ydL = rL;\n    }\n    // Initialise the result array with zeros.\n    r = [];\n    rL = xdL + ydL;\n    for(i = rL; i--;)r.push(0);\n    // Multiply!\n    for(i = ydL; --i >= 0;){\n        carry = 0;\n        for(k = xdL + i; k > i;){\n            t = r[k] + yd[i] * xd[k - i - 1] + carry;\n            r[k--] = t % BASE | 0;\n            carry = t / BASE | 0;\n        }\n        r[k] = (r[k] + carry) % BASE | 0;\n    }\n    // Remove trailing zeros.\n    for(; !r[--rL];)r.pop();\n    if (carry) ++e;\n    else r.shift();\n    y.d = r;\n    y.e = getBase10Exponent(r, e);\n    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toBinary = function(sd, rm) {\n    return toStringBinary(this, 2, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n *\r\n * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toDecimalPlaces = P.toDP = function(dp, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (dp === void 0) return x;\n    checkInt32(dp, 0, MAX_DIGITS);\n    if (rm === void 0) rm = Ctor.rounding;\n    else checkInt32(rm, 0, 8);\n    return finalise(x, dp + x.e + 1, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal in exponential notation rounded to\r\n * `dp` fixed decimal places using rounding mode `rounding`.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toExponential = function(dp, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x, true);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), dp + 1, rm);\n        str = finiteToString(x, true, dp + 1);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n * omitted.\r\n *\r\n * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n *\r\n * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n * (-0).toFixed(3) is '0.000'.\r\n * (-0.5).toFixed(0) is '-0'.\r\n *\r\n */ P.toFixed = function(dp, rm) {\n    var str, y, x = this, Ctor = x.constructor;\n    if (dp === void 0) {\n        str = finiteToString(x);\n    } else {\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        y = finalise(new Ctor(x), dp + x.e + 1, rm);\n        str = finiteToString(y, false, dp + y.e + 1);\n    }\n    // To determine whether to add the minus sign look at the value before it was rounded,\n    // i.e. look at `x` rather than `y`.\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n * numerator and an integer denominator.\r\n *\r\n * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n * value necessary to represent the number exactly.\r\n *\r\n * [maxD] {number|string|bigint|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n *\r\n */ P.toFraction = function(maxD) {\n    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n    if (!xd) return new Ctor(x);\n    n1 = d0 = new Ctor(1);\n    d1 = n0 = new Ctor(0);\n    d = new Ctor(d1);\n    e = d.e = getPrecision(xd) - x.e - 1;\n    k = e % LOG_BASE;\n    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n    if (maxD == null) {\n        // d is 10**e, the minimum max-denominator needed.\n        maxD = e > 0 ? d : n1;\n    } else {\n        n = new Ctor(maxD);\n        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n        maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n    }\n    external = false;\n    n = new Ctor(digitsToString(xd));\n    pr = Ctor.precision;\n    Ctor.precision = e = xd.length * LOG_BASE * 2;\n    for(;;){\n        q = divide(n, d, 0, 1, 1);\n        d2 = d0.plus(q.times(d1));\n        if (d2.cmp(maxD) == 1) break;\n        d0 = d1;\n        d1 = d2;\n        d2 = n1;\n        n1 = n0.plus(q.times(d2));\n        n0 = d2;\n        d2 = d;\n        d = n.minus(q.times(d2));\n        n = d2;\n    }\n    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n    n0 = n0.plus(d2.times(n1));\n    d0 = d0.plus(d2.times(d1));\n    n0.s = n1.s = x.s;\n    // Determine which fraction is closer to x, n0/d0 or n1/d1?\n    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [\n        n1,\n        d1\n    ] : [\n        n0,\n        d0\n    ];\n    Ctor.precision = pr;\n    external = true;\n    return r;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toHexadecimal = P.toHex = function(sd, rm) {\n    return toStringBinary(this, 16, sd, rm);\n};\n/*\r\n * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n *\r\n * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n * or `y` is NaN, in which case the return value will be also be NaN.\r\n *\r\n * The return value is not affected by the value of `precision`.\r\n *\r\n * y {number|string|bigint|Decimal} The magnitude to round to a multiple of.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toNearest() rounding mode not an integer: {rm}'\r\n * 'toNearest() rounding mode out of range: {rm}'\r\n *\r\n */ P.toNearest = function(y, rm) {\n    var x = this, Ctor = x.constructor;\n    x = new Ctor(x);\n    if (y == null) {\n        // If x is not finite, return x.\n        if (!x.d) return x;\n        y = new Ctor(1);\n        rm = Ctor.rounding;\n    } else {\n        y = new Ctor(y);\n        if (rm === void 0) {\n            rm = Ctor.rounding;\n        } else {\n            checkInt32(rm, 0, 8);\n        }\n        // If x is not finite, return x if y is not NaN, else NaN.\n        if (!x.d) return y.s ? x : y;\n        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n        if (!y.d) {\n            if (y.s) y.s = x.s;\n            return y;\n        }\n    }\n    // If y is not zero, calculate the nearest multiple of y to x.\n    if (y.d[0]) {\n        external = false;\n        x = divide(x, y, 0, rm, 1).times(y);\n        external = true;\n        finalise(x);\n    // If y is zero, return zero with the sign of x.\n    } else {\n        y.s = x.s;\n        x = y;\n    }\n    return x;\n};\n/*\r\n * Return the value of this Decimal converted to a number primitive.\r\n * Zero keeps its sign.\r\n *\r\n */ P.toNumber = function() {\n    return +this;\n};\n/*\r\n * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n * digits using rounding mode `rm`.\r\n *\r\n * If the optional `sd` argument is present then return binary exponential notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toOctal = function(sd, rm) {\n    return toStringBinary(this, 8, sd, rm);\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n * to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * ECMAScript compliant.\r\n *\r\n *   pow(x, NaN)                           = NaN\r\n *   pow(x, ±0)                            = 1\r\n\r\n *   pow(NaN, non-zero)                    = NaN\r\n *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n *   pow(abs(x) > 1, -Infinity)            = +0\r\n *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n *   pow(abs(x) < 1, +Infinity)            = +0\r\n *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n *   pow(+Infinity, y > 0)                 = +Infinity\r\n *   pow(+Infinity, y < 0)                 = +0\r\n *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n *   pow(-Infinity, even integer > 0)      = +Infinity\r\n *   pow(-Infinity, odd integer < 0)       = -0\r\n *   pow(-Infinity, even integer < 0)      = +0\r\n *   pow(+0, y > 0)                        = +0\r\n *   pow(+0, y < 0)                        = +Infinity\r\n *   pow(-0, odd integer > 0)              = -0\r\n *   pow(-0, even integer > 0)             = +0\r\n *   pow(-0, odd integer < 0)              = -Infinity\r\n *   pow(-0, even integer < 0)             = +Infinity\r\n *   pow(finite x < 0, finite non-integer) = NaN\r\n *\r\n * For non-integer or very large exponents pow(x, y) is calculated using\r\n *\r\n *   x^y = exp(y*ln(x))\r\n *\r\n * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n * probability of an incorrectly rounded result\r\n * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n * i.e. 1 in 250,000,000,000,000\r\n *\r\n * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n *\r\n * y {number|string|bigint|Decimal} The power to which to raise this Decimal.\r\n *\r\n */ P.toPower = P.pow = function(y) {\n    var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n    // Either ±Infinity, NaN or ±0?\n    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n    x = new Ctor(x);\n    if (x.eq(1)) return x;\n    pr = Ctor.precision;\n    rm = Ctor.rounding;\n    if (y.eq(1)) return finalise(x, pr, rm);\n    // y exponent\n    e = mathfloor(y.e / LOG_BASE);\n    // If y is a small integer use the 'exponentiation by squaring' algorithm.\n    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n        r = intPow(Ctor, x, k, pr);\n        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n    }\n    s = x.s;\n    // if x is negative\n    if (s < 0) {\n        // if y is not an integer\n        if (e < y.d.length - 1) return new Ctor(NaN);\n        // Result is positive if x is negative and the last digit of integer y is even.\n        if ((y.d[e] & 1) == 0) s = 1;\n        // if x.eq(-1)\n        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n            x.s = s;\n            return x;\n        }\n    }\n    // Estimate result exponent.\n    // x^y = 10^e,  where e = y * log10(x)\n    // log10(x) = log10(x_significand) + x_exponent\n    // log10(x_significand) = ln(x_significand) / ln(10)\n    k = mathpow(+x, yn);\n    e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n    // Overflow/underflow?\n    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n    external = false;\n    Ctor.rounding = x.s = 1;\n    // Estimate the extra guard digits needed to ensure five correct rounding digits from\n    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n    // new Decimal(2.32456).pow('2087987436534566.46411')\n    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n    k = Math.min(12, (e + \"\").length);\n    // r = x^y = exp(y*ln(x))\n    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n    if (r.d) {\n        // Truncate to the required precision plus five rounding digits.\n        r = finalise(r, pr + 5, 1);\n        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n        // the result.\n        if (checkRoundingDigits(r.d, pr, rm)) {\n            e = pr + 10;\n            // Truncate to the increased precision plus five rounding digits.\n            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n            // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n                r = finalise(r, pr + 1, 0);\n            }\n        }\n    }\n    r.s = s;\n    external = true;\n    Ctor.rounding = rm;\n    return finalise(r, pr, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n * the integer part of the value in normal notation.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n */ P.toPrecision = function(sd, rm) {\n    var str, x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        x = finalise(new Ctor(x), sd, rm);\n        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n    }\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n * omitted.\r\n *\r\n * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n *\r\n * 'toSD() digits out of range: {sd}'\r\n * 'toSD() digits not an integer: {sd}'\r\n * 'toSD() rounding mode not an integer: {rm}'\r\n * 'toSD() rounding mode out of range: {rm}'\r\n *\r\n */ P.toSignificantDigits = P.toSD = function(sd, rm) {\n    var x = this, Ctor = x.constructor;\n    if (sd === void 0) {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    } else {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    }\n    return finalise(new Ctor(x), sd, rm);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n *\r\n * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n *\r\n */ P.toString = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n};\n/*\r\n * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n *\r\n */ P.truncated = P.trunc = function() {\n    return finalise(new this.constructor(this), this.e + 1, 1);\n};\n/*\r\n * Return a string representing the value of this Decimal.\r\n * Unlike `toString`, negative zero will include the minus sign.\r\n *\r\n */ P.valueOf = P.toJSON = function() {\n    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n    return x.isNeg() ? \"-\" + str : str;\n};\n// Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n/*\r\n *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n *                           finiteToString, naturalExponential, naturalLogarithm\r\n *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n *  convertBase              toStringBinary, parseOther\r\n *  cos                      P.cos\r\n *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n *                           taylorSeries, atan2, parseOther\r\n *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n *                           naturalLogarithm, ceil, floor, round, trunc\r\n *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n *                           toStringBinary\r\n *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n *  getLn10                  P.logarithm, naturalLogarithm\r\n *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n *  getPrecision             P.precision, P.toFraction\r\n *  getZeroString            digitsToString, finiteToString\r\n *  intPow                   P.toPower, parseOther\r\n *  isOdd                    toLessThanHalfPi\r\n *  maxOrMin                 max, min\r\n *  naturalExponential       P.naturalExponential, P.toPower\r\n *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n *                           P.toPower, naturalExponential\r\n *  nonFiniteToString        finiteToString, toStringBinary\r\n *  parseDecimal             Decimal\r\n *  parseOther               Decimal\r\n *  sin                      P.sin\r\n *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n *  toLessThanHalfPi         P.cos, P.sin\r\n *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n *  truncate                 intPow\r\n *\r\n *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n *                           naturalLogarithm, config, parseOther, random, Decimal\r\n */ function digitsToString(d) {\n    var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n    if (indexOfLastWord > 0) {\n        str += w;\n        for(i = 1; i < indexOfLastWord; i++){\n            ws = d[i] + \"\";\n            k = LOG_BASE - ws.length;\n            if (k) str += getZeroString(k);\n            str += ws;\n        }\n        w = d[i];\n        ws = w + \"\";\n        k = LOG_BASE - ws.length;\n        if (k) str += getZeroString(k);\n    } else if (w === 0) {\n        return \"0\";\n    }\n    // Remove trailing zeros of last w.\n    for(; w % 10 === 0;)w /= 10;\n    return str + w;\n}\nfunction checkInt32(i, min, max) {\n    if (i !== ~~i || i < min || i > max) {\n        throw Error(invalidArgument + i);\n    }\n}\n/*\r\n * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n * `repeating == null` if caller is `log` or `pow`,\r\n * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n */ function checkRoundingDigits(d, i, rm, repeating) {\n    var di, k, r, rd;\n    // Get the length of the first word of the array d.\n    for(k = d[0]; k >= 10; k /= 10)--i;\n    // Is the rounding digit in the first word of d?\n    if (--i < 0) {\n        i += LOG_BASE;\n        di = 0;\n    } else {\n        di = Math.ceil((i + 1) / LOG_BASE);\n        i %= LOG_BASE;\n    }\n    // i is the index (0 - 6) of the rounding digit.\n    // E.g. if within the word 3487563 the first rounding digit is 5,\n    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n    k = mathpow(10, LOG_BASE - i);\n    rd = d[di] % k | 0;\n    if (repeating == null) {\n        if (i < 3) {\n            if (i == 0) rd = rd / 100 | 0;\n            else if (i == 1) rd = rd / 10 | 0;\n            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n        } else {\n            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n        }\n    } else {\n        if (i < 4) {\n            if (i == 0) rd = rd / 1000 | 0;\n            else if (i == 1) rd = rd / 100 | 0;\n            else if (i == 2) rd = rd / 10 | 0;\n            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n        } else {\n            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n        }\n    }\n    return r;\n}\n// Convert string of `baseIn` to an array of numbers of `baseOut`.\n// Eg. convertBase('255', 10, 16) returns [15, 15].\n// Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\nfunction convertBase(str, baseIn, baseOut) {\n    var j, arr = [\n        0\n    ], arrL, i = 0, strL = str.length;\n    for(; i < strL;){\n        for(arrL = arr.length; arrL--;)arr[arrL] *= baseIn;\n        arr[0] += NUMERALS.indexOf(str.charAt(i++));\n        for(j = 0; j < arr.length; j++){\n            if (arr[j] > baseOut - 1) {\n                if (arr[j + 1] === void 0) arr[j + 1] = 0;\n                arr[j + 1] += arr[j] / baseOut | 0;\n                arr[j] %= baseOut;\n            }\n        }\n    }\n    return arr.reverse();\n}\n/*\r\n * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n * |x| < pi/2\r\n *\r\n */ function cosine(Ctor, x) {\n    var k, len, y;\n    if (x.isZero()) return x;\n    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n    // Estimate the optimum number of times to use the argument reduction.\n    len = x.d.length;\n    if (len < 32) {\n        k = Math.ceil(len / 3);\n        y = (1 / tinyPow(4, k)).toString();\n    } else {\n        k = 16;\n        y = \"2.3283064365386962890625e-10\";\n    }\n    Ctor.precision += k;\n    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n    // Reverse argument reduction\n    for(var i = k; i--;){\n        var cos2x = x.times(x);\n        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n    }\n    Ctor.precision -= k;\n    return x;\n}\n/*\r\n * Perform division in the specified base.\r\n */ var divide = function() {\n    // Assumes non-zero x and k, and hence non-zero result.\n    function multiplyInteger(x, k, base) {\n        var temp, carry = 0, i = x.length;\n        for(x = x.slice(); i--;){\n            temp = x[i] * k + carry;\n            x[i] = temp % base | 0;\n            carry = temp / base | 0;\n        }\n        if (carry) x.unshift(carry);\n        return x;\n    }\n    function compare(a, b, aL, bL) {\n        var i, r;\n        if (aL != bL) {\n            r = aL > bL ? 1 : -1;\n        } else {\n            for(i = r = 0; i < aL; i++){\n                if (a[i] != b[i]) {\n                    r = a[i] > b[i] ? 1 : -1;\n                    break;\n                }\n            }\n        }\n        return r;\n    }\n    function subtract(a, b, aL, base) {\n        var i = 0;\n        // Subtract b from a.\n        for(; aL--;){\n            a[aL] -= i;\n            i = a[aL] < b[aL] ? 1 : 0;\n            a[aL] = i * base + a[aL] - b[aL];\n        }\n        // Remove leading zeros.\n        for(; !a[0] && a.length > 1;)a.shift();\n    }\n    return function(x, y, pr, rm, dp, base) {\n        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n        // Either NaN, Infinity or 0?\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n            return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n        }\n        if (base) {\n            logBase = 1;\n            e = x.e - y.e;\n        } else {\n            base = BASE;\n            logBase = LOG_BASE;\n            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n        }\n        yL = yd.length;\n        xL = xd.length;\n        q = new Ctor(sign);\n        qd = q.d = [];\n        // Result exponent may be one less than e.\n        // The digit array of a Decimal from toStringBinary may have trailing zeros.\n        for(i = 0; yd[i] == (xd[i] || 0); i++);\n        if (yd[i] > (xd[i] || 0)) e--;\n        if (pr == null) {\n            sd = pr = Ctor.precision;\n            rm = Ctor.rounding;\n        } else if (dp) {\n            sd = pr + (x.e - y.e) + 1;\n        } else {\n            sd = pr;\n        }\n        if (sd < 0) {\n            qd.push(1);\n            more = true;\n        } else {\n            // Convert precision in number of base 10 digits to base 1e7 digits.\n            sd = sd / logBase + 2 | 0;\n            i = 0;\n            // divisor < 1e7\n            if (yL == 1) {\n                k = 0;\n                yd = yd[0];\n                sd++;\n                // k is the carry.\n                for(; (i < xL || k) && sd--; i++){\n                    t = k * base + (xd[i] || 0);\n                    qd[i] = t / yd | 0;\n                    k = t % yd | 0;\n                }\n                more = k || i < xL;\n            // divisor >= 1e7\n            } else {\n                // Normalise xd and yd so highest order digit of yd is >= base/2\n                k = base / (yd[0] + 1) | 0;\n                if (k > 1) {\n                    yd = multiplyInteger(yd, k, base);\n                    xd = multiplyInteger(xd, k, base);\n                    yL = yd.length;\n                    xL = xd.length;\n                }\n                xi = yL;\n                rem = xd.slice(0, yL);\n                remL = rem.length;\n                // Add zeros to make remainder as long as divisor.\n                for(; remL < yL;)rem[remL++] = 0;\n                yz = yd.slice();\n                yz.unshift(0);\n                yd0 = yd[0];\n                if (yd[1] >= base / 2) ++yd0;\n                do {\n                    k = 0;\n                    // Compare divisor and remainder.\n                    cmp = compare(yd, rem, yL, remL);\n                    // If divisor < remainder.\n                    if (cmp < 0) {\n                        // Calculate trial digit, k.\n                        rem0 = rem[0];\n                        if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                        // k will be how many times the divisor goes into the current remainder.\n                        k = rem0 / yd0 | 0;\n                        //  Algorithm:\n                        //  1. product = divisor * trial digit (k)\n                        //  2. if product > remainder: product -= divisor, k--\n                        //  3. remainder -= product\n                        //  4. if product was < remainder at 2:\n                        //    5. compare new remainder and divisor\n                        //    6. If remainder > divisor: remainder -= divisor, k++\n                        if (k > 1) {\n                            if (k >= base) k = base - 1;\n                            // product = divisor * trial digit.\n                            prod = multiplyInteger(yd, k, base);\n                            prodL = prod.length;\n                            remL = rem.length;\n                            // Compare product and remainder.\n                            cmp = compare(prod, rem, prodL, remL);\n                            // product > remainder.\n                            if (cmp == 1) {\n                                k--;\n                                // Subtract divisor from product.\n                                subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                            }\n                        } else {\n                            // cmp is -1.\n                            // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                            // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                            if (k == 0) cmp = k = 1;\n                            prod = yd.slice();\n                        }\n                        prodL = prod.length;\n                        if (prodL < remL) prod.unshift(0);\n                        // Subtract product from remainder.\n                        subtract(rem, prod, remL, base);\n                        // If product was < previous remainder.\n                        if (cmp == -1) {\n                            remL = rem.length;\n                            // Compare divisor and new remainder.\n                            cmp = compare(yd, rem, yL, remL);\n                            // If divisor < new remainder, subtract divisor from remainder.\n                            if (cmp < 1) {\n                                k++;\n                                // Subtract divisor from remainder.\n                                subtract(rem, yL < remL ? yz : yd, remL, base);\n                            }\n                        }\n                        remL = rem.length;\n                    } else if (cmp === 0) {\n                        k++;\n                        rem = [\n                            0\n                        ];\n                    } // if cmp === 1, k will be 0\n                    // Add the next digit, k, to the result array.\n                    qd[i++] = k;\n                    // Update the remainder.\n                    if (cmp && rem[0]) {\n                        rem[remL++] = xd[xi] || 0;\n                    } else {\n                        rem = [\n                            xd[xi]\n                        ];\n                        remL = 1;\n                    }\n                }while ((xi++ < xL || rem[0] !== void 0) && sd--);\n                more = rem[0] !== void 0;\n            }\n            // Leading zero?\n            if (!qd[0]) qd.shift();\n        }\n        // logBase is 1 when divide is being used for base conversion.\n        if (logBase == 1) {\n            q.e = e;\n            inexact = more;\n        } else {\n            // To calculate q.e, first get the number of digits of qd[0].\n            for(i = 1, k = qd[0]; k >= 10; k /= 10)i++;\n            q.e = i + e * logBase - 1;\n            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n        }\n        return q;\n    };\n}();\n/*\r\n * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n * Check for over/under-flow.\r\n */ function finalise(x, sd, rm, isTruncated) {\n    var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n    // Don't round if sd is null or undefined.\n    out: if (sd != null) {\n        xd = x.d;\n        // Infinity/NaN.\n        if (!xd) return x;\n        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n        // w: the word of xd containing rd, a base 1e7 number.\n        // xdi: the index of w within xd.\n        // digits: the number of digits of w.\n        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n        // they had leading zeros)\n        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n        // Get the length of the first word of the digits array xd.\n        for(digits = 1, k = xd[0]; k >= 10; k /= 10)digits++;\n        i = sd - digits;\n        // Is the rounding digit in the first word of xd?\n        if (i < 0) {\n            i += LOG_BASE;\n            j = sd;\n            w = xd[xdi = 0];\n            // Get the rounding digit at index j of w.\n            rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n        } else {\n            xdi = Math.ceil((i + 1) / LOG_BASE);\n            k = xd.length;\n            if (xdi >= k) {\n                if (isTruncated) {\n                    // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n                    for(; k++ <= xdi;)xd.push(0);\n                    w = rd = 0;\n                    digits = 1;\n                    i %= LOG_BASE;\n                    j = i - LOG_BASE + 1;\n                } else {\n                    break out;\n                }\n            } else {\n                w = k = xd[xdi];\n                // Get the number of digits of w.\n                for(digits = 1; k >= 10; k /= 10)digits++;\n                // Get the index of rd within w.\n                i %= LOG_BASE;\n                // Get the index of rd within w, adjusted for leading zeros.\n                // The number of leading zeros of w is given by LOG_BASE - digits.\n                j = i - LOG_BASE + digits;\n                // Get the rounding digit at index j of w.\n                rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n            }\n        }\n        // Are there any non-zero digits after the rounding digit?\n        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n        // will give 714.\n        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n        if (sd < 1 || !xd[0]) {\n            xd.length = 0;\n            if (roundUp) {\n                // Convert sd to decimal places.\n                sd -= x.e + 1;\n                // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n                x.e = -sd || 0;\n            } else {\n                // Zero.\n                xd[0] = x.e = 0;\n            }\n            return x;\n        }\n        // Remove excess digits.\n        if (i == 0) {\n            xd.length = xdi;\n            k = 1;\n            xdi--;\n        } else {\n            xd.length = xdi + 1;\n            k = mathpow(10, LOG_BASE - i);\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n            // j > 0 means i > number of leading zeros of w.\n            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n        }\n        if (roundUp) {\n            for(;;){\n                // Is the digit to be rounded up in the first word of xd?\n                if (xdi == 0) {\n                    // i will be the length of xd[0] before k is added.\n                    for(i = 1, j = xd[0]; j >= 10; j /= 10)i++;\n                    j = xd[0] += k;\n                    for(k = 1; j >= 10; j /= 10)k++;\n                    // if i != k the length has increased.\n                    if (i != k) {\n                        x.e++;\n                        if (xd[0] == BASE) xd[0] = 1;\n                    }\n                    break;\n                } else {\n                    xd[xdi] += k;\n                    if (xd[xdi] != BASE) break;\n                    xd[xdi--] = 0;\n                    k = 1;\n                }\n            }\n        }\n        // Remove trailing zeros.\n        for(i = xd.length; xd[--i] === 0;)xd.pop();\n    }\n    if (external) {\n        // Overflow?\n        if (x.e > Ctor.maxE) {\n            // Infinity.\n            x.d = null;\n            x.e = NaN;\n        // Underflow?\n        } else if (x.e < Ctor.minE) {\n            // Zero.\n            x.e = 0;\n            x.d = [\n                0\n            ];\n        // Ctor.underflow = true;\n        } // else Ctor.underflow = false;\n    }\n    return x;\n}\nfunction finiteToString(x, isExp, sd) {\n    if (!x.isFinite()) return nonFiniteToString(x);\n    var k, e = x.e, str = digitsToString(x.d), len = str.length;\n    if (isExp) {\n        if (sd && (k = sd - len) > 0) {\n            str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n        } else if (len > 1) {\n            str = str.charAt(0) + \".\" + str.slice(1);\n        }\n        str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n    } else if (e < 0) {\n        str = \"0.\" + getZeroString(-e - 1) + str;\n        if (sd && (k = sd - len) > 0) str += getZeroString(k);\n    } else if (e >= len) {\n        str += getZeroString(e + 1 - len);\n        if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n    } else {\n        if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n        if (sd && (k = sd - len) > 0) {\n            if (e + 1 === len) str += \".\";\n            str += getZeroString(k);\n        }\n    }\n    return str;\n}\n// Calculate the base 10 exponent from the base 1e7 exponent.\nfunction getBase10Exponent(digits, e) {\n    var w = digits[0];\n    // Add the number of digits of the first word of the digits array.\n    for(e *= LOG_BASE; w >= 10; w /= 10)e++;\n    return e;\n}\nfunction getLn10(Ctor, sd, pr) {\n    if (sd > LN10_PRECISION) {\n        // Reset global state in case the exception is caught.\n        external = true;\n        if (pr) Ctor.precision = pr;\n        throw Error(precisionLimitExceeded);\n    }\n    return finalise(new Ctor(LN10), sd, 1, true);\n}\nfunction getPi(Ctor, sd, rm) {\n    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n    return finalise(new Ctor(PI), sd, rm, true);\n}\nfunction getPrecision(digits) {\n    var w = digits.length - 1, len = w * LOG_BASE + 1;\n    w = digits[w];\n    // If non-zero...\n    if (w) {\n        // Subtract the number of trailing zeros of the last word.\n        for(; w % 10 == 0; w /= 10)len--;\n        // Add the number of digits of the first word.\n        for(w = digits[0]; w >= 10; w /= 10)len++;\n    }\n    return len;\n}\nfunction getZeroString(k) {\n    var zs = \"\";\n    for(; k--;)zs += \"0\";\n    return zs;\n}\n/*\r\n * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n * integer of type number.\r\n *\r\n * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n *\r\n */ function intPow(Ctor, x, n, pr) {\n    var isTruncated, r = new Ctor(1), // Max n of 9007199254740991 takes 53 loop iterations.\n    // Maximum digits array length; leaves [28, 34] guard digits.\n    k = Math.ceil(pr / LOG_BASE + 4);\n    external = false;\n    for(;;){\n        if (n % 2) {\n            r = r.times(x);\n            if (truncate(r.d, k)) isTruncated = true;\n        }\n        n = mathfloor(n / 2);\n        if (n === 0) {\n            // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n            n = r.d.length - 1;\n            if (isTruncated && r.d[n] === 0) ++r.d[n];\n            break;\n        }\n        x = x.times(x);\n        truncate(x.d, k);\n    }\n    external = true;\n    return r;\n}\nfunction isOdd(n) {\n    return n.d[n.d.length - 1] & 1;\n}\n/*\r\n * Handle `max` (`n` is -1) and `min` (`n` is 1).\r\n */ function maxOrMin(Ctor, args, n) {\n    var k, y, x = new Ctor(args[0]), i = 0;\n    for(; ++i < args.length;){\n        y = new Ctor(args[i]);\n        // NaN?\n        if (!y.s) {\n            x = y;\n            break;\n        }\n        k = x.cmp(y);\n        if (k === n || k === 0 && x.s === n) {\n            x = y;\n        }\n    }\n    return x;\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n * Taylor/Maclaurin series.\r\n *\r\n * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n *\r\n * Argument reduction:\r\n *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n *   exp(x) = exp(x / 2^k)^(2^k)\r\n *\r\n * Previously, the argument was initially reduced by\r\n * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n * found to be slower than just dividing repeatedly by 32 as above.\r\n *\r\n * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n *\r\n *  exp(Infinity)  = Infinity\r\n *  exp(-Infinity) = 0\r\n *  exp(NaN)       = NaN\r\n *  exp(±0)        = 1\r\n *\r\n *  exp(x) is non-terminating for any finite, non-zero x.\r\n *\r\n *  The result will always be correctly rounded.\r\n *\r\n */ function naturalExponential(x, sd) {\n    var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // 0/NaN/Infinity?\n    if (!x.d || !x.d[0] || x.e > 17) {\n        return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    t = new Ctor(0.03125);\n    // while abs(x) >= 0.1\n    while(x.e > -2){\n        // x = x / 2^5\n        x = x.times(t);\n        k += 5;\n    }\n    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n    // necessary to ensure the first 4 rounding digits are correct.\n    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n    wpr += guard;\n    denominator = pow = sum = new Ctor(1);\n    Ctor.precision = wpr;\n    for(;;){\n        pow = finalise(pow.times(x), wpr, 1);\n        denominator = denominator.times(++i);\n        t = sum.plus(divide(pow, denominator, wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            j = k;\n            while(j--)sum = finalise(sum.times(sum), wpr, 1);\n            // Check to see if the first 4 rounding digits are [49]999.\n            // If so, repeat the summation with a higher precision, otherwise\n            // e.g. with precision: 18, rounding: 1\n            // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += 10;\n                    denominator = pow = t = new Ctor(1);\n                    i = 0;\n                    rep++;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n    }\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n * digits.\r\n *\r\n *  ln(-n)        = NaN\r\n *  ln(0)         = -Infinity\r\n *  ln(-0)        = -Infinity\r\n *  ln(1)         = 0\r\n *  ln(Infinity)  = Infinity\r\n *  ln(-Infinity) = NaN\r\n *  ln(NaN)       = NaN\r\n *\r\n *  ln(n) (n != 1) is non-terminating.\r\n *\r\n */ function naturalLogarithm(y, sd) {\n    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n    // Is x negative or Infinity, NaN, 0 or 1?\n    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n    }\n    if (sd == null) {\n        external = false;\n        wpr = pr;\n    } else {\n        wpr = sd;\n    }\n    Ctor.precision = wpr += guard;\n    c = digitsToString(xd);\n    c0 = c.charAt(0);\n    if (Math.abs(e = x.e) < 1.5e15) {\n        // Argument reduction.\n        // The series converges faster the closer the argument is to 1, so using\n        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n        // later be divided by this number, then separate out the power of 10 using\n        // ln(a*10^b) = ln(a) + b*ln(10).\n        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n        // max n is 6 (gives 0.7 - 1.3)\n        while(c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3){\n            x = x.times(y);\n            c = digitsToString(x.d);\n            c0 = c.charAt(0);\n            n++;\n        }\n        e = x.e;\n        if (c0 > 1) {\n            x = new Ctor(\"0.\" + c);\n            e++;\n        } else {\n            x = new Ctor(c0 + \".\" + c.slice(1));\n        }\n    } else {\n        // The argument reduction method above may result in overflow if the argument y is a massive\n        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n        // function using ln(x*10^e) = ln(x) + e*ln(10).\n        t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n        x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n        Ctor.precision = pr;\n        return sd == null ? finalise(x, pr, rm, external = true) : x;\n    }\n    // x1 is x reduced to a value near 1.\n    x1 = x;\n    // Taylor series.\n    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n    // where x = (y - 1)/(y + 1)    (|x| < 1)\n    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n    x2 = finalise(x.times(x), wpr, 1);\n    denominator = 3;\n    for(;;){\n        numerator = finalise(numerator.times(x2), wpr, 1);\n        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n            sum = sum.times(2);\n            // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n            // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n            if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n            sum = divide(sum, new Ctor(n), wpr, 1);\n            // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n            // been repeated previously) and the first 4 rounding digits 9999?\n            // If so, restart the summation with a higher precision, otherwise\n            // e.g. with precision: 12, rounding: 1\n            // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n            // `wpr - guard` is the index of first rounding digit.\n            if (sd == null) {\n                if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                    Ctor.precision = wpr += guard;\n                    t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n                    x2 = finalise(x.times(x), wpr, 1);\n                    denominator = rep = 1;\n                } else {\n                    return finalise(sum, Ctor.precision = pr, rm, external = true);\n                }\n            } else {\n                Ctor.precision = pr;\n                return sum;\n            }\n        }\n        sum = t;\n        denominator += 2;\n    }\n}\n// ±Infinity, NaN.\nfunction nonFiniteToString(x) {\n    // Unsigned.\n    return String(x.s * x.s / 0);\n}\n/*\r\n * Parse the value of a new Decimal `x` from string `str`.\r\n */ function parseDecimal(x, str) {\n    var e, i, len;\n    // TODO BigInt str: no need to check for decimal point, exponential form or leading zeros.\n    // Decimal point?\n    if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n    // Exponential form?\n    if ((i = str.search(/e/i)) > 0) {\n        // Determine exponent.\n        if (e < 0) e = i;\n        e += +str.slice(i + 1);\n        str = str.substring(0, i);\n    } else if (e < 0) {\n        // Integer.\n        e = str.length;\n    }\n    // Determine leading zeros.\n    for(i = 0; str.charCodeAt(i) === 48; i++);\n    // Determine trailing zeros.\n    for(len = str.length; str.charCodeAt(len - 1) === 48; --len);\n    str = str.slice(i, len);\n    if (str) {\n        len -= i;\n        x.e = e = e - i - 1;\n        x.d = [];\n        // Transform base\n        // e is the base 10 exponent.\n        // i is where to slice str to get the first word of the digits array.\n        i = (e + 1) % LOG_BASE;\n        if (e < 0) i += LOG_BASE;\n        if (i < len) {\n            if (i) x.d.push(+str.slice(0, i));\n            for(len -= LOG_BASE; i < len;)x.d.push(+str.slice(i, i += LOG_BASE));\n            str = str.slice(i);\n            i = LOG_BASE - str.length;\n        } else {\n            i -= len;\n        }\n        for(; i--;)str += \"0\";\n        x.d.push(+str);\n        if (external) {\n            // Overflow?\n            if (x.e > x.constructor.maxE) {\n                // Infinity.\n                x.d = null;\n                x.e = NaN;\n            // Underflow?\n            } else if (x.e < x.constructor.minE) {\n                // Zero.\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n            // x.constructor.underflow = true;\n            } // else x.constructor.underflow = false;\n        }\n    } else {\n        // Zero.\n        x.e = 0;\n        x.d = [\n            0\n        ];\n    }\n    return x;\n}\n/*\r\n * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n */ function parseOther(x, str) {\n    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n    if (str.indexOf(\"_\") > -1) {\n        str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n        if (isDecimal.test(str)) return parseDecimal(x, str);\n    } else if (str === \"Infinity\" || str === \"NaN\") {\n        if (!+str) x.s = NaN;\n        x.e = NaN;\n        x.d = null;\n        return x;\n    }\n    if (isHex.test(str)) {\n        base = 16;\n        str = str.toLowerCase();\n    } else if (isBinary.test(str)) {\n        base = 2;\n    } else if (isOctal.test(str)) {\n        base = 8;\n    } else {\n        throw Error(invalidArgument + str);\n    }\n    // Is there a binary exponent part?\n    i = str.search(/p/i);\n    if (i > 0) {\n        p = +str.slice(i + 1);\n        str = str.substring(2, i);\n    } else {\n        str = str.slice(2);\n    }\n    // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n    // fraction part will be restored.\n    i = str.indexOf(\".\");\n    isFloat = i >= 0;\n    Ctor = x.constructor;\n    if (isFloat) {\n        str = str.replace(\".\", \"\");\n        len = str.length;\n        i = len - i;\n        // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n        divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n    }\n    xd = convertBase(str, base, BASE);\n    xe = xd.length - 1;\n    // Remove trailing zeros.\n    for(i = xe; xd[i] === 0; --i)xd.pop();\n    if (i < 0) return new Ctor(x.s * 0);\n    x.e = getBase10Exponent(xd, xe);\n    x.d = xd;\n    external = false;\n    // At what precision to perform the division to ensure exact conversion?\n    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n    // Therefore using 4 * the number of digits of str will always be enough.\n    if (isFloat) x = divide(x, divisor, len * 4);\n    // Multiply by the binary exponent part if present.\n    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n    external = true;\n    return x;\n}\n/*\r\n * sin(x) = x - x^3/3! + x^5/5! - ...\r\n * |x| < pi/2\r\n *\r\n */ function sine(Ctor, x) {\n    var k, len = x.d.length;\n    if (len < 3) {\n        return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n    }\n    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n    // Estimate the optimum number of times to use the argument reduction.\n    k = 1.4 * Math.sqrt(len);\n    k = k > 16 ? 16 : k | 0;\n    x = x.times(1 / tinyPow(5, k));\n    x = taylorSeries(Ctor, 2, x, x);\n    // Reverse argument reduction\n    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n    for(; k--;){\n        sin2_x = x.times(x);\n        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n    }\n    return x;\n}\n// Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\nfunction taylorSeries(Ctor, n, x, y, isHyperbolic) {\n    var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n    external = false;\n    x2 = x.times(x);\n    u = new Ctor(y);\n    for(;;){\n        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n        u = isHyperbolic ? y.plus(t) : y.minus(t);\n        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n        t = u.plus(y);\n        if (t.d[k] !== void 0) {\n            for(j = k; t.d[j] === u.d[j] && j--;);\n            if (j == -1) break;\n        }\n        j = u;\n        u = y;\n        y = t;\n        t = j;\n        i++;\n    }\n    external = true;\n    t.d.length = k + 1;\n    return t;\n}\n// Exponent e must be positive and non-zero.\nfunction tinyPow(b, e) {\n    var n = b;\n    while(--e)n *= b;\n    return n;\n}\n// Return the absolute value of `x` reduced to less than or equal to half pi.\nfunction toLessThanHalfPi(Ctor, x) {\n    var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n    x = x.abs();\n    if (x.lte(halfPi)) {\n        quadrant = isNeg ? 4 : 1;\n        return x;\n    }\n    t = x.divToInt(pi);\n    if (t.isZero()) {\n        quadrant = isNeg ? 3 : 2;\n    } else {\n        x = x.minus(t.times(pi));\n        // 0 <= x < pi\n        if (x.lte(halfPi)) {\n            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n            return x;\n        }\n        quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n    }\n    return x.minus(pi).abs();\n}\n/*\r\n * Return the value of Decimal `x` as a string in base `baseOut`.\r\n *\r\n * If the optional `sd` argument is present include a binary exponent suffix.\r\n */ function toStringBinary(x, baseOut, sd, rm) {\n    var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n    if (isExp) {\n        checkInt32(sd, 1, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n    } else {\n        sd = Ctor.precision;\n        rm = Ctor.rounding;\n    }\n    if (!x.isFinite()) {\n        str = nonFiniteToString(x);\n    } else {\n        str = finiteToString(x);\n        i = str.indexOf(\".\");\n        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n        // minBinaryExponent = floor(decimalExponent * log[2](10))\n        // log[2](10) = 3.321928094887362347870319429489390175864\n        if (isExp) {\n            base = 2;\n            if (baseOut == 16) {\n                sd = sd * 4 - 3;\n            } else if (baseOut == 8) {\n                sd = sd * 3 - 2;\n            }\n        } else {\n            base = baseOut;\n        }\n        // Convert the number as an integer then divide the result by its base raised to a power such\n        // that the fraction part will be restored.\n        // Non-integer.\n        if (i >= 0) {\n            str = str.replace(\".\", \"\");\n            y = new Ctor(1);\n            y.e = str.length - i;\n            y.d = convertBase(finiteToString(y), 10, base);\n            y.e = y.d.length;\n        }\n        xd = convertBase(str, 10, base);\n        e = len = xd.length;\n        // Remove trailing zeros.\n        for(; xd[--len] == 0;)xd.pop();\n        if (!xd[0]) {\n            str = isExp ? \"0p+0\" : \"0\";\n        } else {\n            if (i < 0) {\n                e--;\n            } else {\n                x = new Ctor(x);\n                x.d = xd;\n                x.e = e;\n                x = divide(x, y, sd, rm, 0, base);\n                xd = x.d;\n                e = x.e;\n                roundUp = inexact;\n            }\n            // The rounding digit, i.e. the digit after the digit that may be rounded up.\n            i = xd[sd];\n            k = base / 2;\n            roundUp = roundUp || xd[sd + 1] !== void 0;\n            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n            xd.length = sd;\n            if (roundUp) {\n                // Rounding up may mean the previous digit has to be rounded up and so on.\n                for(; ++xd[--sd] > base - 1;){\n                    xd[sd] = 0;\n                    if (!sd) {\n                        ++e;\n                        xd.unshift(1);\n                    }\n                }\n            }\n            // Determine trailing zeros.\n            for(len = xd.length; !xd[len - 1]; --len);\n            // E.g. [4, 11, 15] becomes 4bf.\n            for(i = 0, str = \"\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n            // Add binary exponent suffix?\n            if (isExp) {\n                if (len > 1) {\n                    if (baseOut == 16 || baseOut == 8) {\n                        i = baseOut == 16 ? 4 : 3;\n                        for(--len; len % i; len++)str += \"0\";\n                        xd = convertBase(str, base, baseOut);\n                        for(len = xd.length; !xd[len - 1]; --len);\n                        // xd[0] will always be be 1\n                        for(i = 1, str = \"1.\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                    } else {\n                        str = str.charAt(0) + \".\" + str.slice(1);\n                    }\n                }\n                str = str + (e < 0 ? \"p\" : \"p+\") + e;\n            } else if (e < 0) {\n                for(; ++e;)str = \"0\" + str;\n                str = \"0.\" + str;\n            } else {\n                if (++e > len) for(e -= len; e--;)str += \"0\";\n                else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n            }\n        }\n        str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n    }\n    return x.s < 0 ? \"-\" + str : str;\n}\n// Does not strip trailing zeros.\nfunction truncate(arr, len) {\n    if (arr.length > len) {\n        arr.length = len;\n        return true;\n    }\n}\n// Decimal methods\n/*\r\n *  abs\r\n *  acos\r\n *  acosh\r\n *  add\r\n *  asin\r\n *  asinh\r\n *  atan\r\n *  atanh\r\n *  atan2\r\n *  cbrt\r\n *  ceil\r\n *  clamp\r\n *  clone\r\n *  config\r\n *  cos\r\n *  cosh\r\n *  div\r\n *  exp\r\n *  floor\r\n *  hypot\r\n *  ln\r\n *  log\r\n *  log2\r\n *  log10\r\n *  max\r\n *  min\r\n *  mod\r\n *  mul\r\n *  pow\r\n *  random\r\n *  round\r\n *  set\r\n *  sign\r\n *  sin\r\n *  sinh\r\n *  sqrt\r\n *  sub\r\n *  sum\r\n *  tan\r\n *  tanh\r\n *  trunc\r\n */ /*\r\n * Return a new Decimal whose value is the absolute value of `x`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function abs(x) {\n    return new this(x).abs();\n}\n/*\r\n * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function acos(x) {\n    return new this(x).acos();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function acosh(x) {\n    return new this(x).acosh();\n}\n/*\r\n * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * y {number|string|bigint|Decimal}\r\n *\r\n */ function add(x, y) {\n    return new this(x).plus(y);\n}\n/*\r\n * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function asin(x) {\n    return new this(x).asin();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function asinh(x) {\n    return new this(x).asinh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function atan(x) {\n    return new this(x).atan();\n}\n/*\r\n * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n * `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function atanh(x) {\n    return new this(x).atanh();\n}\n/*\r\n * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * Domain: [-Infinity, Infinity]\r\n * Range: [-pi, pi]\r\n *\r\n * y {number|string|bigint|Decimal} The y-coordinate.\r\n * x {number|string|bigint|Decimal} The x-coordinate.\r\n *\r\n * atan2(±0, -0)               = ±pi\r\n * atan2(±0, +0)               = ±0\r\n * atan2(±0, -x)               = ±pi for x > 0\r\n * atan2(±0, x)                = ±0 for x > 0\r\n * atan2(-y, ±0)               = -pi/2 for y > 0\r\n * atan2(y, ±0)                = pi/2 for y > 0\r\n * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n * atan2(±Infinity, +Infinity) = ±pi/4\r\n * atan2(NaN, x) = NaN\r\n * atan2(y, NaN) = NaN\r\n *\r\n */ function atan2(y, x) {\n    y = new this(y);\n    x = new this(x);\n    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n    // Either NaN\n    if (!y.s || !x.s) {\n        r = new this(NaN);\n    // Both ±Infinity\n    } else if (!y.d && !x.d) {\n        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n        r.s = y.s;\n    // x is ±Infinity or y is ±0\n    } else if (!x.d || y.isZero()) {\n        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n        r.s = y.s;\n    // y is ±Infinity or x is ±0\n    } else if (!y.d || x.isZero()) {\n        r = getPi(this, wpr, 1).times(0.5);\n        r.s = y.s;\n    // Both non-zero and finite\n    } else if (x.s < 0) {\n        this.precision = wpr;\n        this.rounding = 1;\n        r = this.atan(divide(y, x, wpr, 1));\n        x = getPi(this, wpr, 1);\n        this.precision = pr;\n        this.rounding = rm;\n        r = y.s < 0 ? r.minus(x) : r.plus(x);\n    } else {\n        r = this.atan(divide(y, x, wpr, 1));\n    }\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function cbrt(x) {\n    return new this(x).cbrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function ceil(x) {\n    return finalise(x = new this(x), x.e + 1, 2);\n}\n/*\r\n * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * min {number|string|bigint|Decimal}\r\n * max {number|string|bigint|Decimal}\r\n *\r\n */ function clamp(x, min, max) {\n    return new this(x).clamp(min, max);\n}\n/*\r\n * Configure global settings for a Decimal constructor.\r\n *\r\n * `obj` is an object with one or more of the following properties,\r\n *\r\n *   precision  {number}\r\n *   rounding   {number}\r\n *   toExpNeg   {number}\r\n *   toExpPos   {number}\r\n *   maxE       {number}\r\n *   minE       {number}\r\n *   modulo     {number}\r\n *   crypto     {boolean|number}\r\n *   defaults   {true}\r\n *\r\n * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n *\r\n */ function config(obj) {\n    if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n    var i, p, v, useDefaults = obj.defaults === true, ps = [\n        \"precision\",\n        1,\n        MAX_DIGITS,\n        \"rounding\",\n        0,\n        8,\n        \"toExpNeg\",\n        -EXP_LIMIT,\n        0,\n        \"toExpPos\",\n        0,\n        EXP_LIMIT,\n        \"maxE\",\n        0,\n        EXP_LIMIT,\n        \"minE\",\n        -EXP_LIMIT,\n        0,\n        \"modulo\",\n        0,\n        9\n    ];\n    for(i = 0; i < ps.length; i += 3){\n        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n            else throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n    if ((v = obj[p]) !== void 0) {\n        if (v === true || v === false || v === 0 || v === 1) {\n            if (v) {\n                if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                    this[p] = true;\n                } else {\n                    throw Error(cryptoUnavailable);\n                }\n            } else {\n                this[p] = false;\n            }\n        } else {\n            throw Error(invalidArgument + p + \": \" + v);\n        }\n    }\n    return this;\n}\n/*\r\n * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function cos(x) {\n    return new this(x).cos();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function cosh(x) {\n    return new this(x).cosh();\n}\n/*\r\n * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n * constructor.\r\n *\r\n */ function clone(obj) {\n    var i, p, ps;\n    /*\r\n   * The Decimal constructor and exported function.\r\n   * Return a new Decimal instance.\r\n   *\r\n   * v {number|string|bigint|Decimal} A numeric value.\r\n   *\r\n   */ function Decimal(v) {\n        var e, i, t, x = this;\n        // Decimal called without new.\n        if (!(x instanceof Decimal)) return new Decimal(v);\n        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n        // which points to Object.\n        x.constructor = Decimal;\n        if (isDecimalInstance(v)) {\n            x.s = v.s;\n            if (external) {\n                if (!v.d || v.e > Decimal.maxE) {\n                    // Infinity.\n                    x.e = NaN;\n                    x.d = null;\n                } else if (v.e < Decimal.minE) {\n                    // Zero.\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                } else {\n                    x.e = v.e;\n                    x.d = v.d.slice();\n                }\n            } else {\n                x.e = v.e;\n                x.d = v.d ? v.d.slice() : v.d;\n            }\n            return;\n        }\n        t = typeof v;\n        if (t === \"number\") {\n            if (v === 0) {\n                x.s = 1 / v < 0 ? -1 : 1;\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n                return;\n            }\n            if (v < 0) {\n                v = -v;\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n            // Fast path for small integers.\n            if (v === ~~v && v < 1e7) {\n                for(e = 0, i = v; i >= 10; i /= 10)e++;\n                if (external) {\n                    if (e > Decimal.maxE) {\n                        x.e = NaN;\n                        x.d = null;\n                    } else if (e < Decimal.minE) {\n                        x.e = 0;\n                        x.d = [\n                            0\n                        ];\n                    } else {\n                        x.e = e;\n                        x.d = [\n                            v\n                        ];\n                    }\n                } else {\n                    x.e = e;\n                    x.d = [\n                        v\n                    ];\n                }\n                return;\n            }\n            // Infinity or NaN?\n            if (v * 0 !== 0) {\n                if (!v) x.s = NaN;\n                x.e = NaN;\n                x.d = null;\n                return;\n            }\n            return parseDecimal(x, v.toString());\n        }\n        if (t === \"string\") {\n            if ((i = v.charCodeAt(0)) === 45) {\n                v = v.slice(1);\n                x.s = -1;\n            } else {\n                if (i === 43) v = v.slice(1); // plus sign\n                x.s = 1;\n            }\n            return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n        }\n        if (t === \"bigint\") {\n            if (v < 0) {\n                v = -v;\n                x.s = -1;\n            } else {\n                x.s = 1;\n            }\n            return parseDecimal(x, v.toString());\n        }\n        throw Error(invalidArgument + v);\n    }\n    Decimal.prototype = P;\n    Decimal.ROUND_UP = 0;\n    Decimal.ROUND_DOWN = 1;\n    Decimal.ROUND_CEIL = 2;\n    Decimal.ROUND_FLOOR = 3;\n    Decimal.ROUND_HALF_UP = 4;\n    Decimal.ROUND_HALF_DOWN = 5;\n    Decimal.ROUND_HALF_EVEN = 6;\n    Decimal.ROUND_HALF_CEIL = 7;\n    Decimal.ROUND_HALF_FLOOR = 8;\n    Decimal.EUCLID = 9;\n    Decimal.config = Decimal.set = config;\n    Decimal.clone = clone;\n    Decimal.isDecimal = isDecimalInstance;\n    Decimal.abs = abs;\n    Decimal.acos = acos;\n    Decimal.acosh = acosh; // ES6\n    Decimal.add = add;\n    Decimal.asin = asin;\n    Decimal.asinh = asinh; // ES6\n    Decimal.atan = atan;\n    Decimal.atanh = atanh; // ES6\n    Decimal.atan2 = atan2;\n    Decimal.cbrt = cbrt; // ES6\n    Decimal.ceil = ceil;\n    Decimal.clamp = clamp;\n    Decimal.cos = cos;\n    Decimal.cosh = cosh; // ES6\n    Decimal.div = div;\n    Decimal.exp = exp;\n    Decimal.floor = floor;\n    Decimal.hypot = hypot; // ES6\n    Decimal.ln = ln;\n    Decimal.log = log;\n    Decimal.log10 = log10; // ES6\n    Decimal.log2 = log2; // ES6\n    Decimal.max = max;\n    Decimal.min = min;\n    Decimal.mod = mod;\n    Decimal.mul = mul;\n    Decimal.pow = pow;\n    Decimal.random = random;\n    Decimal.round = round;\n    Decimal.sign = sign; // ES6\n    Decimal.sin = sin;\n    Decimal.sinh = sinh; // ES6\n    Decimal.sqrt = sqrt;\n    Decimal.sub = sub;\n    Decimal.sum = sum;\n    Decimal.tan = tan;\n    Decimal.tanh = tanh; // ES6\n    Decimal.trunc = trunc; // ES6\n    if (obj === void 0) obj = {};\n    if (obj) {\n        if (obj.defaults !== true) {\n            ps = [\n                \"precision\",\n                \"rounding\",\n                \"toExpNeg\",\n                \"toExpPos\",\n                \"maxE\",\n                \"minE\",\n                \"modulo\",\n                \"crypto\"\n            ];\n            for(i = 0; i < ps.length;)if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n        }\n    }\n    Decimal.config(obj);\n    return Decimal;\n}\n/*\r\n * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * y {number|string|bigint|Decimal}\r\n *\r\n */ function div(x, y) {\n    return new this(x).div(y);\n}\n/*\r\n * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} The power to which to raise the base of the natural log.\r\n *\r\n */ function exp(x) {\n    return new this(x).exp();\n}\n/*\r\n * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function floor(x) {\n    return finalise(x = new this(x), x.e + 1, 3);\n}\n/*\r\n * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n * rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\n */ function hypot() {\n    var i, n, t = new this(0);\n    external = false;\n    for(i = 0; i < arguments.length;){\n        n = new this(arguments[i++]);\n        if (!n.d) {\n            if (n.s) {\n                external = true;\n                return new this(1 / 0);\n            }\n            t = n;\n        } else if (t.d) {\n            t = t.plus(n.times(n));\n        }\n    }\n    external = true;\n    return t.sqrt();\n}\n/*\r\n * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n * otherwise return false.\r\n *\r\n */ function isDecimalInstance(obj) {\n    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n}\n/*\r\n * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function ln(x) {\n    return new this(x).ln();\n}\n/*\r\n * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n *\r\n * log[y](x)\r\n *\r\n * x {number|string|bigint|Decimal} The argument of the logarithm.\r\n * y {number|string|bigint|Decimal} The base of the logarithm.\r\n *\r\n */ function log(x, y) {\n    return new this(x).log(y);\n}\n/*\r\n * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function log2(x) {\n    return new this(x).log(2);\n}\n/*\r\n * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function log10(x) {\n    return new this(x).log(10);\n}\n/*\r\n * Return a new Decimal whose value is the maximum of the arguments.\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\n */ function max() {\n    return maxOrMin(this, arguments, -1);\n}\n/*\r\n * Return a new Decimal whose value is the minimum of the arguments.\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\n */ function min() {\n    return maxOrMin(this, arguments, 1);\n}\n/*\r\n * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * y {number|string|bigint|Decimal}\r\n *\r\n */ function mod(x, y) {\n    return new this(x).mod(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * y {number|string|bigint|Decimal}\r\n *\r\n */ function mul(x, y) {\n    return new this(x).mul(y);\n}\n/*\r\n * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} The base.\r\n * y {number|string|bigint|Decimal} The exponent.\r\n *\r\n */ function pow(x, y) {\n    return new this(x).pow(y);\n}\n/*\r\n * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n * are produced).\r\n *\r\n * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n *\r\n */ function random(sd) {\n    var d, e, k, n, i = 0, r = new this(1), rd = [];\n    if (sd === void 0) sd = this.precision;\n    else checkInt32(sd, 1, MAX_DIGITS);\n    k = Math.ceil(sd / LOG_BASE);\n    if (!this.crypto) {\n        for(; i < k;)rd[i++] = Math.random() * 1e7 | 0;\n    // Browsers supporting crypto.getRandomValues.\n    } else if (crypto.getRandomValues) {\n        d = crypto.getRandomValues(new Uint32Array(k));\n        for(; i < k;){\n            n = d[i];\n            // 0 <= n < 4294967296\n            // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n            if (n >= 4.29e9) {\n                d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n            } else {\n                // 0 <= n <= 4289999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd[i++] = n % 1e7;\n            }\n        }\n    // Node.js supporting crypto.randomBytes.\n    } else if (crypto.randomBytes) {\n        // buffer\n        d = crypto.randomBytes(k *= 4);\n        for(; i < k;){\n            // 0 <= n < 2147483648\n            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\n            // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n            if (n >= 2.14e9) {\n                crypto.randomBytes(4).copy(d, i);\n            } else {\n                // 0 <= n <= 2139999999\n                // 0 <= (n % 1e7) <= 9999999\n                rd.push(n % 1e7);\n                i += 4;\n            }\n        }\n        i = k / 4;\n    } else {\n        throw Error(cryptoUnavailable);\n    }\n    k = rd[--i];\n    sd %= LOG_BASE;\n    // Convert trailing digits to zeros according to sd.\n    if (k && sd) {\n        n = mathpow(10, LOG_BASE - sd);\n        rd[i] = (k / n | 0) * n;\n    }\n    // Remove trailing words which are zero.\n    for(; rd[i] === 0; i--)rd.pop();\n    // Zero?\n    if (i < 0) {\n        e = 0;\n        rd = [\n            0\n        ];\n    } else {\n        e = -1;\n        // Remove leading words which are zero and adjust exponent accordingly.\n        for(; rd[0] === 0; e -= LOG_BASE)rd.shift();\n        // Count the digits of the first word of rd to determine leading zeros.\n        for(k = 1, n = rd[0]; n >= 10; n /= 10)k++;\n        // Adjust the exponent for leading zeros of the first word of rd.\n        if (k < LOG_BASE) e -= LOG_BASE - k;\n    }\n    r.e = e;\n    r.d = rd;\n    return r;\n}\n/*\r\n * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n *\r\n * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function round(x) {\n    return finalise(x = new this(x), x.e + 1, this.rounding);\n}\n/*\r\n * Return\r\n *   1    if x > 0,\r\n *  -1    if x < 0,\r\n *   0    if x is 0,\r\n *  -0    if x is -0,\r\n *   NaN  otherwise\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function sign(x) {\n    x = new this(x);\n    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n}\n/*\r\n * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function sin(x) {\n    return new this(x).sin();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function sinh(x) {\n    return new this(x).sinh();\n}\n/*\r\n * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function sqrt(x) {\n    return new this(x).sqrt();\n}\n/*\r\n * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n * using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n * y {number|string|bigint|Decimal}\r\n *\r\n */ function sub(x, y) {\n    return new this(x).sub(y);\n}\n/*\r\n * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * Only the result is rounded, not the intermediate calculations.\r\n *\r\n * arguments {number|string|bigint|Decimal}\r\n *\r\n */ function sum() {\n    var i = 0, args = arguments, x = new this(args[i]);\n    external = false;\n    for(; x.s && ++i < args.length;)x = x.plus(args[i]);\n    external = true;\n    return finalise(x, this.precision, this.rounding);\n}\n/*\r\n * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n * digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function tan(x) {\n    return new this(x).tan();\n}\n/*\r\n * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n * significant digits using rounding mode `rounding`.\r\n *\r\n * x {number|string|bigint|Decimal} A value in radians.\r\n *\r\n */ function tanh(x) {\n    return new this(x).tanh();\n}\n/*\r\n * Return a new Decimal whose value is `x` truncated to an integer.\r\n *\r\n * x {number|string|bigint|Decimal}\r\n *\r\n */ function trunc(x) {\n    return finalise(x = new this(x), x.e + 1, 1);\n}\nP[Symbol.for(\"nodejs.util.inspect.custom\")] = P.toString;\nP[Symbol.toStringTag] = \"Decimal\";\n// Create and configure initial Decimal constructor.\nvar Decimal = P.constructor = clone(DEFAULTS);\n// Create the internal constants from their string values.\nLN10 = new Decimal(LN10);\nPI = new Decimal(PI);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Decimal);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZGVjaW1hbC5qc0AxMC42LjAvbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FHRCxrR0FBa0c7QUFHaEcsa0NBQWtDO0FBQ2xDLHVFQUF1RTtBQUN6RSxJQUFJQSxZQUFZLE1BRWQsbUZBQW1GO0FBQ25GLDBGQUEwRjtBQUMxRkMsYUFBYSxLQUViLDRCQUE0QjtBQUM1QkMsV0FBVyxvQkFFWCw2Q0FBNkM7QUFDN0NDLE9BQU8sc2dDQUVQLG9CQUFvQjtBQUNwQkMsS0FBSyxzZ0NBR0wsbUVBQW1FO0FBQ25FQyxXQUFXO0lBRVQsc0VBQXNFO0lBQ3RFLHFGQUFxRjtJQUVyRiw4RkFBOEY7SUFDOUYsNENBQTRDO0lBQzVDQyxXQUFXO0lBRVgsdURBQXVEO0lBQ3ZELEVBQUU7SUFDRixxQ0FBcUM7SUFDckMsbUNBQW1DO0lBQ25DLHdDQUF3QztJQUN4Qyx3Q0FBd0M7SUFDeEMsb0VBQW9FO0lBQ3BFLHNFQUFzRTtJQUN0RSx3RkFBd0Y7SUFDeEYsbUZBQW1GO0lBQ25GLG1GQUFtRjtJQUNuRixFQUFFO0lBQ0YsT0FBTztJQUNQLDBCQUEwQjtJQUMxQiw4Q0FBOEM7SUFDOUNDLFVBQVU7SUFFViw4REFBOEQ7SUFDOUQsdUZBQXVGO0lBQ3ZGLHFEQUFxRDtJQUNyRCxFQUFFO0lBQ0Ysd0ZBQXdGO0lBQ3hGLCtFQUErRTtJQUMvRSwwRUFBMEU7SUFDMUUsZ0RBQWdEO0lBQ2hELHFGQUFxRjtJQUNyRixFQUFFO0lBQ0YsMEZBQTBGO0lBQzFGLDhGQUE4RjtJQUM5RixpREFBaUQ7SUFDakRDLFFBQVE7SUFFUixtRkFBbUY7SUFDbkYseUJBQXlCO0lBQ3pCQyxVQUFVLENBQUM7SUFFWCxpRkFBaUY7SUFDakYseUJBQXlCO0lBQ3pCQyxVQUFXO0lBRVgsc0VBQXNFO0lBQ3RFLHFDQUFxQztJQUNyQ0MsTUFBTSxDQUFDWDtJQUVQLHVFQUF1RTtJQUN2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Q0QsU0FBU2dHLE1BQU1uTCxDQUFDO0lBQ2QsT0FBT0csU0FBU0gsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSUEsRUFBRUssQ0FBQyxHQUFHLEdBQUc7QUFDNUM7QUFHQVQsQ0FBQyxDQUFDOFIsT0FBT0MsR0FBRyxDQUFDLDhCQUE4QixHQUFHL1IsRUFBRXFELFFBQVE7QUFDeERyRCxDQUFDLENBQUM4UixPQUFPN1IsV0FBVyxDQUFDLEdBQUc7QUFFeEIsb0RBQW9EO0FBQzdDLElBQUl5UCxVQUFVMVAsRUFBRUssV0FBVyxHQUFHbVEsTUFBTXhTLFVBQVU7QUFFckQsMERBQTBEO0FBQzFERixPQUFPLElBQUk0UixRQUFRNVI7QUFDbkJDLEtBQUssSUFBSTJSLFFBQVEzUjtBQUVqQixpRUFBZTJSLE9BQU9BLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcmVzYWxlLXdlYi8uL25vZGVfbW9kdWxlcy8ucG5wbS9kZWNpbWFsLmpzQDEwLjYuMC9ub2RlX21vZHVsZXMvZGVjaW1hbC5qcy9kZWNpbWFsLm1qcz8wZDBlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gKiAgZGVjaW1hbC5qcyB2MTAuNi4wXHJcbiAqICBBbiBhcmJpdHJhcnktcHJlY2lzaW9uIERlY2ltYWwgdHlwZSBmb3IgSmF2YVNjcmlwdC5cclxuICogIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanNcclxuICogIENvcHlyaWdodCAoYykgMjAyNSBNaWNoYWVsIE1jbGF1Z2hsaW4gPE04Y2g4OGxAZ21haWwuY29tPlxyXG4gKiAgTUlUIExpY2VuY2VcclxuICovXHJcblxyXG5cclxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gIEVESVRBQkxFIERFRkFVTFRTICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblxyXG4gIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IG1hZ25pdHVkZS5cclxuICAvLyBUaGUgbGltaXQgb24gdGhlIHZhbHVlIG9mIGB0b0V4cE5lZ2AsIGB0b0V4cFBvc2AsIGBtaW5FYCBhbmQgYG1heEVgLlxyXG52YXIgRVhQX0xJTUlUID0gOWUxNSwgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5ZTE1XHJcblxyXG4gIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAsIGFuZCBvbiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50IHRvXHJcbiAgLy8gYHRvRGVjaW1hbFBsYWNlc2AsIGB0b0V4cG9uZW50aWFsYCwgYHRvRml4ZWRgLCBgdG9QcmVjaXNpb25gIGFuZCBgdG9TaWduaWZpY2FudERpZ2l0c2AuXHJcbiAgTUFYX0RJR0lUUyA9IDFlOSwgICAgICAgICAgICAgICAgICAgICAgICAvLyAwIHRvIDFlOVxyXG5cclxuICAvLyBCYXNlIGNvbnZlcnNpb24gYWxwaGFiZXQuXHJcbiAgTlVNRVJBTFMgPSAnMDEyMzQ1Njc4OWFiY2RlZicsXHJcblxyXG4gIC8vIFRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiAxMCAoMTAyNSBkaWdpdHMpLlxyXG4gIExOMTAgPSAnMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4JyxcclxuXHJcbiAgLy8gUGkgKDEwMjUgZGlnaXRzKS5cclxuICBQSSA9ICczLjE0MTU5MjY1MzU4OTc5MzIzODQ2MjY0MzM4MzI3OTUwMjg4NDE5NzE2OTM5OTM3NTEwNTgyMDk3NDk0NDU5MjMwNzgxNjQwNjI4NjIwODk5ODYyODAzNDgyNTM0MjExNzA2Nzk4MjE0ODA4NjUxMzI4MjMwNjY0NzA5Mzg0NDYwOTU1MDU4MjIzMTcyNTM1OTQwODEyODQ4MTExNzQ1MDI4NDEwMjcwMTkzODUyMTEwNTU1OTY0NDYyMjk0ODk1NDkzMDM4MTk2NDQyODgxMDk3NTY2NTkzMzQ0NjEyODQ3NTY0ODIzMzc4Njc4MzE2NTI3MTIwMTkwOTE0NTY0ODU2NjkyMzQ2MDM0ODYxMDQ1NDMyNjY0ODIxMzM5MzYwNzI2MDI0OTE0MTI3MzcyNDU4NzAwNjYwNjMxNTU4ODE3NDg4MTUyMDkyMDk2MjgyOTI1NDA5MTcxNTM2NDM2Nzg5MjU5MDM2MDAxMTMzMDUzMDU0ODgyMDQ2NjUyMTM4NDE0Njk1MTk0MTUxMTYwOTQzMzA1NzI3MDM2NTc1OTU5MTk1MzA5MjE4NjExNzM4MTkzMjYxMTc5MzEwNTExODU0ODA3NDQ2MjM3OTk2Mjc0OTU2NzM1MTg4NTc1MjcyNDg5MTIyNzkzODE4MzAxMTk0OTEyOTgzMzY3MzM2MjQ0MDY1NjY0MzA4NjAyMTM5NDk0NjM5NTIyNDczNzE5MDcwMjE3OTg2MDk0MzcwMjc3MDUzOTIxNzE3NjI5MzE3Njc1MjM4NDY3NDgxODQ2NzY2OTQwNTEzMjAwMDU2ODEyNzE0NTI2MzU2MDgyNzc4NTc3MTM0Mjc1Nzc4OTYwOTE3MzYzNzE3ODcyMTQ2ODQ0MDkwMTIyNDk1MzQzMDE0NjU0OTU4NTM3MTA1MDc5MjI3OTY4OTI1ODkyMzU0MjAxOTk1NjExMjEyOTAyMTk2MDg2NDAzNDQxODE1OTgxMzYyOTc3NDc3MTMwOTk2MDUxODcwNzIxMTM0OTk5OTk5ODM3Mjk3ODA0OTk1MTA1OTczMTczMjgxNjA5NjMxODU5NTAyNDQ1OTQ1NTM0NjkwODMwMjY0MjUyMjMwODI1MzM0NDY4NTAzNTI2MTkzMTE4ODE3MTAxMDAwMzEzNzgzODc1Mjg4NjU4NzUzMzIwODM4MTQyMDYxNzE3NzY2OTE0NzMwMzU5ODI1MzQ5MDQyODc1NTQ2ODczMTE1OTU2Mjg2Mzg4MjM1Mzc4NzU5Mzc1MTk1Nzc4MTg1Nzc4MDUzMjE3MTIyNjgwNjYxMzAwMTkyNzg3NjYxMTE5NTkwOTIxNjQyMDE5ODkzODA5NTI1NzIwMTA2NTQ4NTg2MzI3ODknLFxyXG5cclxuXHJcbiAgLy8gVGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIG9mIHRoZSBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gIERFRkFVTFRTID0ge1xyXG5cclxuICAgIC8vIFRoZXNlIHZhbHVlcyBtdXN0IGJlIGludGVnZXJzIHdpdGhpbiB0aGUgc3RhdGVkIHJhbmdlcyAoaW5jbHVzaXZlKS5cclxuICAgIC8vIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIHRoZSBgRGVjaW1hbC5jb25maWdgIG1ldGhvZC5cclxuXHJcbiAgICAvLyBUaGUgbWF4aW11bSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSByZXN1bHQgb2YgYSBjYWxjdWxhdGlvbiBvciBiYXNlIGNvbnZlcnNpb24uXHJcbiAgICAvLyBFLmcuIGBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAgfSk7YFxyXG4gICAgcHJlY2lzaW9uOiAyMCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhfRElHSVRTXHJcblxyXG4gICAgLy8gVGhlIHJvdW5kaW5nIG1vZGUgdXNlZCB3aGVuIHJvdW5kaW5nIHRvIGBwcmVjaXNpb25gLlxyXG4gICAgLy9cclxuICAgIC8vIFJPVU5EX1VQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgIC8vIFJPVU5EX0RPV04gICAgICAgMSBUb3dhcmRzIHplcm8uXHJcbiAgICAvLyBST1VORF9DRUlMICAgICAgIDIgVG93YXJkcyArSW5maW5pdHkuXHJcbiAgICAvLyBST1VORF9GTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAvLyBST1VORF9IQUxGX1VQICAgIDQgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHVwLlxyXG4gICAgLy8gUk9VTkRfSEFMRl9ET1dOICA1IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCBkb3duLlxyXG4gICAgLy8gUk9VTkRfSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgLy8gUk9VTkRfSEFMRl9DRUlMICA3IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzICtJbmZpbml0eS5cclxuICAgIC8vIFJPVU5EX0hBTEZfRkxPT1IgOCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAvL1xyXG4gICAgLy8gRS5nLlxyXG4gICAgLy8gYERlY2ltYWwucm91bmRpbmcgPSA0O2BcclxuICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQO2BcclxuICAgIHJvdW5kaW5nOiA0LCAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOFxyXG5cclxuICAgIC8vIFRoZSBtb2R1bG8gbW9kZSB1c2VkIHdoZW4gY2FsY3VsYXRpbmcgdGhlIG1vZHVsdXM6IGEgbW9kIG4uXHJcbiAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgIC8vIFRoZSByZW1haW5kZXIgKHIpIGlzIGNhbGN1bGF0ZWQgYXM6IHIgPSBhIC0gbiAqIHEuXHJcbiAgICAvL1xyXG4gICAgLy8gVVAgICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgLy8gRE9XTiAgICAgICAxIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlkZW5kIChKYXZhU2NyaXB0ICUpLlxyXG4gICAgLy8gRkxPT1IgICAgICAzIFRoZSByZW1haW5kZXIgaGFzIHRoZSBzYW1lIHNpZ24gYXMgdGhlIGRpdmlzb3IgKFB5dGhvbiAlKS5cclxuICAgIC8vIEhBTEZfRVZFTiAgNiBUaGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgLy8gRVVDTElEICAgICA5IEV1Y2xpZGlhbiBkaXZpc2lvbi4gcSA9IHNpZ24obikgKiBmbG9vcihhIC8gYWJzKG4pKS4gQWx3YXlzIHBvc2l0aXZlLlxyXG4gICAgLy9cclxuICAgIC8vIFRydW5jYXRlZCBkaXZpc2lvbiAoMSksIGZsb29yZWQgZGl2aXNpb24gKDMpLCB0aGUgSUVFRSA3NTQgcmVtYWluZGVyICg2KSwgYW5kIEV1Y2xpZGlhblxyXG4gICAgLy8gZGl2aXNpb24gKDkpIGFyZSBjb21tb25seSB1c2VkIGZvciB0aGUgbW9kdWx1cyBvcGVyYXRpb24uIFRoZSBvdGhlciByb3VuZGluZyBtb2RlcyBjYW4gYWxzb1xyXG4gICAgLy8gYmUgdXNlZCwgYnV0IHRoZXkgbWF5IG5vdCBnaXZlIHVzZWZ1bCByZXN1bHRzLlxyXG4gICAgbW9kdWxvOiAxLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBiZW5lYXRoIHdoaWNoIGB0b1N0cmluZ2AgcmV0dXJucyBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogLTdcclxuICAgIHRvRXhwTmVnOiAtNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgIC8vIFRoZSBleHBvbmVudCB2YWx1ZSBhdCBhbmQgYWJvdmUgd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAyMVxyXG4gICAgdG9FeHBQb3M6ICAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBFWFBfTElNSVRcclxuXHJcbiAgICAvLyBUaGUgbWluaW11bSBleHBvbmVudCB2YWx1ZSwgYmVuZWF0aCB3aGljaCB1bmRlcmZsb3cgdG8gemVybyBvY2N1cnMuXHJcbiAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IC0zMjQgICg1ZS0zMjQpXHJcbiAgICBtaW5FOiAtRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtRVhQX0xJTUlUXHJcblxyXG4gICAgLy8gVGhlIG1heGltdW0gZXhwb25lbnQgdmFsdWUsIGFib3ZlIHdoaWNoIG92ZXJmbG93IHRvIEluZmluaXR5IG9jY3Vycy5cclxuICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMzA4ICAoMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDgpXHJcbiAgICBtYXhFOiBFWFBfTElNSVQsICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIEVYUF9MSU1JVFxyXG5cclxuICAgIC8vIFdoZXRoZXIgdG8gdXNlIGNyeXB0b2dyYXBoaWNhbGx5LXNlY3VyZSByYW5kb20gbnVtYmVyIGdlbmVyYXRpb24sIGlmIGF2YWlsYWJsZS5cclxuICAgIGNyeXB0bzogZmFsc2UgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRydWUvZmFsc2VcclxuICB9LFxyXG5cclxuXHJcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEVORCBPRiBFRElUQUJMRSBERUZBVUxUUyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5cclxuICBpbmV4YWN0LCBxdWFkcmFudCxcclxuICBleHRlcm5hbCA9IHRydWUsXHJcblxyXG4gIGRlY2ltYWxFcnJvciA9ICdbRGVjaW1hbEVycm9yXSAnLFxyXG4gIGludmFsaWRBcmd1bWVudCA9IGRlY2ltYWxFcnJvciArICdJbnZhbGlkIGFyZ3VtZW50OiAnLFxyXG4gIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyAnUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkJyxcclxuICBjcnlwdG9VbmF2YWlsYWJsZSA9IGRlY2ltYWxFcnJvciArICdjcnlwdG8gdW5hdmFpbGFibGUnLFxyXG4gIHRhZyA9ICdbb2JqZWN0IERlY2ltYWxdJyxcclxuXHJcbiAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuICBtYXRocG93ID0gTWF0aC5wb3csXHJcblxyXG4gIGlzQmluYXJ5ID0gL14wYihbMDFdKyhcXC5bMDFdKik/fFxcLlswMV0rKShwWystXT9cXGQrKT8kL2ksXHJcbiAgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSxcclxuICBpc09jdGFsID0gL14wbyhbMC03XSsoXFwuWzAtN10qKT98XFwuWzAtN10rKShwWystXT9cXGQrKT8kL2ksXHJcbiAgaXNEZWNpbWFsID0gL14oXFxkKyhcXC5cXGQqKT98XFwuXFxkKykoZVsrLV0/XFxkKyk/JC9pLFxyXG5cclxuICBCQVNFID0gMWU3LFxyXG4gIExPR19CQVNFID0gNyxcclxuICBNQVhfU0FGRV9JTlRFR0VSID0gOTAwNzE5OTI1NDc0MDk5MSxcclxuXHJcbiAgTE4xMF9QUkVDSVNJT04gPSBMTjEwLmxlbmd0aCAtIDEsXHJcbiAgUElfUFJFQ0lTSU9OID0gUEkubGVuZ3RoIC0gMSxcclxuXHJcbiAgLy8gRGVjaW1hbC5wcm90b3R5cGUgb2JqZWN0XHJcbiAgUCA9IHsgdG9TdHJpbmdUYWc6IHRhZyB9O1xyXG5cclxuXHJcbi8vIERlY2ltYWwgcHJvdG90eXBlIG1ldGhvZHNcclxuXHJcblxyXG4vKlxyXG4gKiAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgICBhYnNcclxuICogIGNlaWxcclxuICogIGNsYW1wZWRUbyAgICAgICAgICAgICAgICAgY2xhbXBcclxuICogIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgY21wXHJcbiAqICBjb3NpbmUgICAgICAgICAgICAgICAgICAgIGNvc1xyXG4gKiAgY3ViZVJvb3QgICAgICAgICAgICAgICAgICBjYnJ0XHJcbiAqICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgIGRwXHJcbiAqICBkaXZpZGVkQnkgICAgICAgICAgICAgICAgIGRpdlxyXG4gKiAgZGl2aWRlZFRvSW50ZWdlckJ5ICAgICAgICBkaXZUb0ludFxyXG4gKiAgZXF1YWxzICAgICAgICAgICAgICAgICAgICBlcVxyXG4gKiAgZmxvb3JcclxuICogIGdyZWF0ZXJUaGFuICAgICAgICAgICAgICAgZ3RcclxuICogIGdyZWF0ZXJUaGFuT3JFcXVhbFRvICAgICAgZ3RlXHJcbiAqICBoeXBlcmJvbGljQ29zaW5lICAgICAgICAgIGNvc2hcclxuICogIGh5cGVyYm9saWNTaW5lICAgICAgICAgICAgc2luaFxyXG4gKiAgaHlwZXJib2xpY1RhbmdlbnQgICAgICAgICB0YW5oXHJcbiAqICBpbnZlcnNlQ29zaW5lICAgICAgICAgICAgIGFjb3NcclxuICogIGludmVyc2VIeXBlcmJvbGljQ29zaW5lICAgYWNvc2hcclxuICogIGludmVyc2VIeXBlcmJvbGljU2luZSAgICAgYXNpbmhcclxuICogIGludmVyc2VIeXBlcmJvbGljVGFuZ2VudCAgYXRhbmhcclxuICogIGludmVyc2VTaW5lICAgICAgICAgICAgICAgYXNpblxyXG4gKiAgaW52ZXJzZVRhbmdlbnQgICAgICAgICAgICBhdGFuXHJcbiAqICBpc0Zpbml0ZVxyXG4gKiAgaXNJbnRlZ2VyICAgICAgICAgICAgICAgICBpc0ludFxyXG4gKiAgaXNOYU5cclxuICogIGlzTmVnYXRpdmUgICAgICAgICAgICAgICAgaXNOZWdcclxuICogIGlzUG9zaXRpdmUgICAgICAgICAgICAgICAgaXNQb3NcclxuICogIGlzWmVyb1xyXG4gKiAgbGVzc1RoYW4gICAgICAgICAgICAgICAgICBsdFxyXG4gKiAgbGVzc1RoYW5PckVxdWFsVG8gICAgICAgICBsdGVcclxuICogIGxvZ2FyaXRobSAgICAgICAgICAgICAgICAgbG9nXHJcbiAqICBbbWF4aW11bV0gICAgICAgICAgICAgICAgIFttYXhdXHJcbiAqICBbbWluaW11bV0gICAgICAgICAgICAgICAgIFttaW5dXHJcbiAqICBtaW51cyAgICAgICAgICAgICAgICAgICAgIHN1YlxyXG4gKiAgbW9kdWxvICAgICAgICAgICAgICAgICAgICBtb2RcclxuICogIG5hdHVyYWxFeHBvbmVudGlhbCAgICAgICAgZXhwXHJcbiAqICBuYXR1cmFsTG9nYXJpdGhtICAgICAgICAgIGxuXHJcbiAqICBuZWdhdGVkICAgICAgICAgICAgICAgICAgIG5lZ1xyXG4gKiAgcGx1cyAgICAgICAgICAgICAgICAgICAgICBhZGRcclxuICogIHByZWNpc2lvbiAgICAgICAgICAgICAgICAgc2RcclxuICogIHJvdW5kXHJcbiAqICBzaW5lICAgICAgICAgICAgICAgICAgICAgIHNpblxyXG4gKiAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgICBzcXJ0XHJcbiAqICB0YW5nZW50ICAgICAgICAgICAgICAgICAgIHRhblxyXG4gKiAgdGltZXMgICAgICAgICAgICAgICAgICAgICBtdWxcclxuICogIHRvQmluYXJ5XHJcbiAqICB0b0RlY2ltYWxQbGFjZXMgICAgICAgICAgIHRvRFBcclxuICogIHRvRXhwb25lbnRpYWxcclxuICogIHRvRml4ZWRcclxuICogIHRvRnJhY3Rpb25cclxuICogIHRvSGV4YWRlY2ltYWwgICAgICAgICAgICAgdG9IZXhcclxuICogIHRvTmVhcmVzdFxyXG4gKiAgdG9OdW1iZXJcclxuICogIHRvT2N0YWxcclxuICogIHRvUG93ZXIgICAgICAgICAgICAgICAgICAgcG93XHJcbiAqICB0b1ByZWNpc2lvblxyXG4gKiAgdG9TaWduaWZpY2FudERpZ2l0cyAgICAgICB0b1NEXHJcbiAqICB0b1N0cmluZ1xyXG4gKiAgdHJ1bmNhdGVkICAgICAgICAgICAgICAgICB0cnVuY1xyXG4gKiAgdmFsdWVPZiAgICAgICAgICAgICAgICAgICB0b0pTT05cclxuICovXHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFic29sdXRlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICovXHJcblAuYWJzb2x1dGVWYWx1ZSA9IFAuYWJzID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgaWYgKHgucyA8IDApIHgucyA9IDE7XHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciBpbiB0aGVcclxuICogZGlyZWN0aW9uIG9mIHBvc2l0aXZlIEluZmluaXR5LlxyXG4gKlxyXG4gKi9cclxuUC5jZWlsID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMik7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBjbGFtcGVkIHRvIHRoZSByYW5nZVxyXG4gKiBkZWxpbmVhdGVkIGJ5IGBtaW5gIGFuZCBgbWF4YC5cclxuICpcclxuICogbWluIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5QLmNsYW1wZWRUbyA9IFAuY2xhbXAgPSBmdW5jdGlvbiAobWluLCBtYXgpIHtcclxuICB2YXIgayxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcbiAgbWluID0gbmV3IEN0b3IobWluKTtcclxuICBtYXggPSBuZXcgQ3RvcihtYXgpO1xyXG4gIGlmICghbWluLnMgfHwgIW1heC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAobWluLmd0KG1heCkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG1heCk7XHJcbiAgayA9IHguY21wKG1pbik7XHJcbiAgcmV0dXJuIGsgPCAwID8gbWluIDogeC5jbXAobWF4KSA+IDAgPyBtYXggOiBuZXcgQ3Rvcih4KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5cclxuICogICAxICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqICAtMSAgICBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiB0aGUgdmFsdWUgb2YgYHlgLFxyXG4gKiAgIDAgICAgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHZhbHVlLFxyXG4gKiAgIE5hTiAgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBEZWNpbWFsIGlzIE5hTi5cclxuICpcclxuICovXHJcblAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgaSwgaiwgeGRMLCB5ZEwsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIHhkID0geC5kLFxyXG4gICAgeWQgPSAoeSA9IG5ldyB4LmNvbnN0cnVjdG9yKHkpKS5kLFxyXG4gICAgeHMgPSB4LnMsXHJcbiAgICB5cyA9IHkucztcclxuXHJcbiAgLy8gRWl0aGVyIE5hTiBvciDCsUluZmluaXR5P1xyXG4gIGlmICgheGQgfHwgIXlkKSB7XHJcbiAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcclxuICB9XHJcblxyXG4gIC8vIEVpdGhlciB6ZXJvP1xyXG4gIGlmICgheGRbMF0gfHwgIXlkWzBdKSByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcclxuXHJcbiAgLy8gU2lnbnMgZGlmZmVyP1xyXG4gIGlmICh4cyAhPT0geXMpIHJldHVybiB4cztcclxuXHJcbiAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgaWYgKHguZSAhPT0geS5lKSByZXR1cm4geC5lID4geS5lIF4geHMgPCAwID8gMSA6IC0xO1xyXG5cclxuICB4ZEwgPSB4ZC5sZW5ndGg7XHJcbiAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAvLyBDb21wYXJlIGRpZ2l0IGJ5IGRpZ2l0LlxyXG4gIGZvciAoaSA9IDAsIGogPSB4ZEwgPCB5ZEwgPyB4ZEwgOiB5ZEw7IGkgPCBqOyArK2kpIHtcclxuICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pIHJldHVybiB4ZFtpXSA+IHlkW2ldIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29tcGFyZSBsZW5ndGhzLlxyXG4gIHJldHVybiB4ZEwgPT09IHlkTCA/IDAgOiB4ZEwgPiB5ZEwgXiB4cyA8IDAgPyAxIDogLTE7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLTEsIDFdXHJcbiAqXHJcbiAqIGNvcygwKSAgICAgICAgID0gMVxyXG4gKiBjb3MoLTApICAgICAgICA9IDFcclxuICogY29zKEluZmluaXR5KSAgPSBOYU5cclxuICogY29zKC1JbmZpbml0eSkgPSBOYU5cclxuICogY29zKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5kKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgLy8gY29zKDApID0gY29zKC0wKSA9IDFcclxuICBpZiAoIXguZFswXSkgcmV0dXJuIG5ldyBDdG9yKDEpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHggPSBjb3NpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSAzID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvXHJcbiAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqICBjYnJ0KDApICA9ICAwXHJcbiAqICBjYnJ0KC0wKSA9IC0wXHJcbiAqICBjYnJ0KDEpICA9ICAxXHJcbiAqICBjYnJ0KC0xKSA9IC0xXHJcbiAqICBjYnJ0KE4pICA9ICBOXHJcbiAqICBjYnJ0KC1JKSA9IC1JXHJcbiAqICBjYnJ0KEkpICA9ICBJXHJcbiAqXHJcbiAqIE1hdGguY2JydCh4KSA9ICh4IDwgMCA/IC1NYXRoLnBvdygteCwgMS8zKSA6IE1hdGgucG93KHgsIDEvMykpXHJcbiAqXHJcbiAqL1xyXG5QLmN1YmVSb290ID0gUC5jYnJ0ID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gIHMgPSB4LnMgKiBtYXRocG93KHgucyAqIHgsIDEgLyAzKTtcclxuXHJcbiAgIC8vIE1hdGguY2JydCB1bmRlcmZsb3cvb3ZlcmZsb3c/XHJcbiAgIC8vIFBhc3MgeCB0byBNYXRoLnBvdyBhcyBpbnRlZ2VyLCB0aGVuIGFkanVzdCB0aGUgZXhwb25lbnQgb2YgdGhlIHJlc3VsdC5cclxuICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcclxuICAgIG4gPSBkaWdpdHNUb1N0cmluZyh4LmQpO1xyXG4gICAgZSA9IHguZTtcclxuXHJcbiAgICAvLyBBZGp1c3QgbiBleHBvbmVudCBzbyBpdCBpcyBhIG11bHRpcGxlIG9mIDMgYXdheSBmcm9tIHggZXhwb25lbnQuXHJcbiAgICBpZiAocyA9IChlIC0gbi5sZW5ndGggKyAxKSAlIDMpIG4gKz0gKHMgPT0gMSB8fCBzID09IC0yID8gJzAnIDogJzAwJyk7XHJcbiAgICBzID0gbWF0aHBvdyhuLCAxIC8gMyk7XHJcblxyXG4gICAgLy8gUmFyZWx5LCBlIG1heSBiZSBvbmUgbGVzcyB0aGFuIHRoZSByZXN1bHQgZXhwb25lbnQgdmFsdWUuXHJcbiAgICBlID0gbWF0aGZsb29yKChlICsgMSkgLyAzKSAtIChlICUgMyA9PSAoZSA8IDAgPyAtMSA6IDIpKTtcclxuXHJcbiAgICBpZiAocyA9PSAxIC8gMCkge1xyXG4gICAgICBuID0gJzVlJyArIGU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBuID0gcy50b0V4cG9uZW50aWFsKCk7XHJcbiAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgfVxyXG5cclxuICAgIHIgPSBuZXcgQ3RvcihuKTtcclxuICAgIHIucyA9IHgucztcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IG5ldyBDdG9yKHMudG9TdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgLy8gSGFsbGV5J3MgbWV0aG9kLlxyXG4gIC8vIFRPRE8/IENvbXBhcmUgTmV3dG9uJ3MgbWV0aG9kLlxyXG4gIGZvciAoOzspIHtcclxuICAgIHQgPSByO1xyXG4gICAgdDMgPSB0LnRpbWVzKHQpLnRpbWVzKHQpO1xyXG4gICAgdDNwbHVzeCA9IHQzLnBsdXMoeCk7XHJcbiAgICByID0gZGl2aWRlKHQzcGx1c3gucGx1cyh4KS50aW1lcyh0KSwgdDNwbHVzeC5wbHVzKHQzKSwgc2QgKyAyLCAxKTtcclxuXHJcbiAgICAvLyBUT0RPPyBSZXBsYWNlIHdpdGggZm9yLWxvb3AgYW5kIGNoZWNrUm91bmRpbmdEaWdpdHMuXHJcbiAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgIG4gPSBuLnNsaWNlKHNkIC0gMywgc2QgKyAxKTtcclxuXHJcbiAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgOTk5OSBvciA0OTk5XHJcbiAgICAgIC8vICwgaS5lLiBhcHByb2FjaGluZyBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBjb250aW51ZSB0aGUgaXRlcmF0aW9uLlxyXG4gICAgICBpZiAobiA9PSAnOTk5OScgfHwgIXJlcCAmJiBuID09ICc0OTk5Jykge1xyXG5cclxuICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgIC8vIG5pbmVzIG1heSBpbmZpbml0ZWx5IHJlcGVhdC5cclxuICAgICAgICBpZiAoIXJlcCkge1xyXG4gICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgIGlmICh0LnRpbWVzKHQpLnRpbWVzKHQpLmVxKHgpKSB7XHJcbiAgICAgICAgICAgIHIgPSB0O1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgcmVwID0gMTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgLy8gSWYgbm90LCB0aGVuIHRoZXJlIGFyZSBmdXJ0aGVyIGRpZ2l0cyBhbmQgbSB3aWxsIGJlIHRydXRoeS5cclxuICAgICAgICBpZiAoIStuIHx8ICErbi5zbGljZSgxKSAmJiBuLmNoYXJBdCgwKSA9PSAnNScpIHtcclxuXHJcbiAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICBmaW5hbGlzZShyLCBlICsgMSwgMSk7XHJcbiAgICAgICAgICBtID0gIXIudGltZXMocikudGltZXMocikuZXEoeCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICovXHJcblAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHcsXHJcbiAgICBkID0gdGhpcy5kLFxyXG4gICAgbiA9IE5hTjtcclxuXHJcbiAgaWYgKGQpIHtcclxuICAgIHcgPSBkLmxlbmd0aCAtIDE7XHJcbiAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3Qgd29yZC5cclxuICAgIHcgPSBkW3ddO1xyXG4gICAgaWYgKHcpIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbi0tO1xyXG4gICAgaWYgKG4gPCAwKSBuID0gMDtcclxuICB9XHJcblxyXG4gIHJldHVybiBuO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICBuIC8gMCA9IElcclxuICogIG4gLyBOID0gTlxyXG4gKiAgbiAvIEkgPSAwXHJcbiAqICAwIC8gbiA9IDBcclxuICogIDAgLyAwID0gTlxyXG4gKiAgMCAvIE4gPSBOXHJcbiAqICAwIC8gSSA9IDBcclxuICogIE4gLyBuID0gTlxyXG4gKiAgTiAvIDAgPSBOXHJcbiAqICBOIC8gTiA9IE5cclxuICogIE4gLyBJID0gTlxyXG4gKiAgSSAvIG4gPSBJXHJcbiAqICBJIC8gMCA9IElcclxuICogIEkgLyBOID0gTlxyXG4gKiAgSSAvIEkgPSBOXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG9cclxuICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAuZGl2aWRlZEJ5ID0gUC5kaXYgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbFxyXG4gKiBieSB0aGUgdmFsdWUgb2YgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqL1xyXG5QLmRpdmlkZWRUb0ludGVnZXJCeSA9IFAuZGl2VG9JbnQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG4gIHJldHVybiBmaW5hbGlzZShkaXZpZGUoeCwgbmV3IEN0b3IoeSksIDAsIDEsIDEpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBlcXVhbCB0byB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5lcXVhbHMgPSBQLmVxID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgd2hvbGUgbnVtYmVyIGluIHRoZVxyXG4gKiBkaXJlY3Rpb24gb2YgbmVnYXRpdmUgSW5maW5pdHkuXHJcbiAqXHJcbiAqL1xyXG5QLmZsb29yID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBncmVhdGVyIHRoYW4gdGhlIHZhbHVlIG9mIGB5YCwgb3RoZXJ3aXNlIHJldHVyblxyXG4gKiBmYWxzZS5cclxuICpcclxuICovXHJcblAuZ3JlYXRlclRoYW4gPSBQLmd0ID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAqIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmdyZWF0ZXJUaGFuT3JFcXVhbFRvID0gUC5ndGUgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBrID0gdGhpcy5jbXAoeSk7XHJcbiAgcmV0dXJuIGsgPT0gMSB8fCBrID09PSAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbMSwgSW5maW5pdHldXHJcbiAqXHJcbiAqIGNvc2goeCkgPSAxICsgeF4yLzIhICsgeF40LzQhICsgeF42LzYhICsgLi4uXHJcbiAqXHJcbiAqIGNvc2goMCkgICAgICAgICA9IDFcclxuICogY29zaCgtMCkgICAgICAgID0gMVxyXG4gKiBjb3NoKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBjb3NoKC1JbmZpbml0eSkgPSBJbmZpbml0eVxyXG4gKiBjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKSAgIHJlc3VsdFxyXG4gKiAxMDAwICAgICAgOSAgICAgICAgICAgICAgICAgOS44NTAzNTU1NzAwODUyMzQ5Njk0ZSs0MzNcclxuICogMTAwMDAgICAgIDI1ICAgICAgICAgICAgICAgIDQuNDAzNDA5MTEyODMxNDYwNzkzNmUrNDM0MlxyXG4gKiAxMDAwMDAgICAgMTcxICAgICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gKiAxMDAwMDAwICAgMzgxNyAgICAgICAgICAgICAgMS41MTY2MDc2OTg0MDEwNDM3NzI1ZSs0MzQyOTRcclxuICogMTAwMDAwMDAgIGFiYW5kb25lZCBhZnRlciAyIG1pbnV0ZSB3YWl0XHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgY29zaCh4KSA9IDAuNSAqIChleHAoeCkgKyBleHAoLXgpKVxyXG4gKlxyXG4gKi9cclxuUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBrLCBuLCBwciwgcm0sIGxlbixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBvbmUgPSBuZXcgQ3RvcigxKTtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMgPyAxIC8gMCA6IE5hTik7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBvbmU7XHJcblxyXG4gIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogY29zKDR4KSA9IDEgLSA4Y29zXjIoeCkgKyA4Y29zXjQoeCkgKyAxXHJcbiAgLy8gaS5lLiBjb3MoeCkgPSAxIC0gY29zXjIoeC80KSg4IC0gOGNvc14yKHgvNCkpXHJcblxyXG4gIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAvLyBUT0RPPyBFc3RpbWF0aW9uIHJldXNlZCBmcm9tIGNvc2luZSgpIGFuZCBtYXkgbm90IGJlIG9wdGltYWwgaGVyZS5cclxuICBpZiAobGVuIDwgMzIpIHtcclxuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XHJcbiAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrID0gMTY7XHJcbiAgICBuID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gIH1cclxuXHJcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKG4pLCBuZXcgQ3RvcigxKSwgdHJ1ZSk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgdmFyIGNvc2gyX3gsXHJcbiAgICBpID0gayxcclxuICAgIGQ4ID0gbmV3IEN0b3IoOCk7XHJcbiAgZm9yICg7IGktLTspIHtcclxuICAgIGNvc2gyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogc2luaCh4KSA9IHggKyB4XjMvMyEgKyB4XjUvNSEgKyB4XjcvNyEgKyAuLi5cclxuICpcclxuICogc2luaCgwKSAgICAgICAgID0gMFxyXG4gKiBzaW5oKC0wKSAgICAgICAgPSAtMFxyXG4gKiBzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gKiBzaW5oKC1JbmZpbml0eSkgPSAtSW5maW5pdHlcclxuICogc2luaChOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqIHggICAgICAgIHRpbWUgdGFrZW4gKG1zKVxyXG4gKiAxMCAgICAgICAyIG1zXHJcbiAqIDEwMCAgICAgIDUgbXNcclxuICogMTAwMCAgICAgMTQgbXNcclxuICogMTAwMDAgICAgODIgbXNcclxuICogMTAwMDAwICAgODg2IG1zICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gKiAyMDAwMDAgICAyNjEzIG1zXHJcbiAqIDMwMDAwMCAgIDU0MDcgbXNcclxuICogNDAwMDAwICAgODgyNCBtc1xyXG4gKiA1MDAwMDAgICAxMzAyNiBtcyAgICAgICAgICA4LjcwODA2NDM2MTI3MTgwODQxMjllKzIxNzE0NlxyXG4gKiAxMDAwMDAwICA0ODU0MyBtc1xyXG4gKlxyXG4gKiBUT0RPPyBDb21wYXJlIHBlcmZvcm1hbmNlIG9mIHNpbmgoeCkgPSAwLjUgKiAoZXhwKHgpIC0gZXhwKC14KSlcclxuICpcclxuICovXHJcblAuaHlwZXJib2xpY1NpbmUgPSBQLnNpbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGssIHByLCBybSwgbGVuLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgNDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuIDwgMykge1xyXG4gICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIEFsdGVybmF0aXZlIGFyZ3VtZW50IHJlZHVjdGlvbjogc2luaCgzeCkgPSBzaW5oKHgpKDMgKyA0c2luaF4yKHgpKVxyXG4gICAgLy8gaS5lLiBzaW5oKHgpID0gc2luaCh4LzMpKDMgKyA0c2luaF4yKHgvMykpXHJcbiAgICAvLyAzIG11bHRpcGxpY2F0aW9ucyBhbmQgMSBhZGRpdGlvblxyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogc2luaCg1eCkgPSBzaW5oKHgpKDUgKyBzaW5oXjIoeCkoMjAgKyAxNnNpbmheMih4KSkpXHJcbiAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvNSkoNSArIHNpbmheMih4LzUpKDIwICsgMTZzaW5oXjIoeC81KSkpXHJcbiAgICAvLyA0IG11bHRpcGxpY2F0aW9ucyBhbmQgMiBhZGRpdGlvbnNcclxuXHJcbiAgICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICB2YXIgc2luaDJfeCxcclxuICAgICAgZDUgPSBuZXcgQ3Rvcig1KSxcclxuICAgICAgZDE2ID0gbmV3IEN0b3IoMTYpLFxyXG4gICAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgICBmb3IgKDsgay0tOykge1xyXG4gICAgICBzaW5oMl94ID0geC50aW1lcyh4KTtcclxuICAgICAgeCA9IHgudGltZXMoZDUucGx1cyhzaW5oMl94LnRpbWVzKGQxNi50aW1lcyhzaW5oMl94KS5wbHVzKGQyMCkpKSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIHByLCBybSwgdHJ1ZSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAqIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLTEsIDFdXHJcbiAqXHJcbiAqIHRhbmgoeCkgPSBzaW5oKHgpIC8gY29zaCh4KVxyXG4gKlxyXG4gKiB0YW5oKDApICAgICAgICAgPSAwXHJcbiAqIHRhbmgoLTApICAgICAgICA9IC0wXHJcbiAqIHRhbmgoSW5maW5pdHkpICA9IDFcclxuICogdGFuaCgtSW5maW5pdHkpID0gLTFcclxuICogdGFuaChOYU4pICAgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmh5cGVyYm9saWNUYW5nZW50ID0gUC50YW5oID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgucyk7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHJldHVybiBkaXZpZGUoeC5zaW5oKCksIHguY29zaCgpLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgKGludmVyc2UgY29zaW5lKSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZSBvZlxyXG4gKiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy0xLCAxXVxyXG4gKiBSYW5nZTogWzAsIHBpXVxyXG4gKlxyXG4gKiBhY29zKHgpID0gcGkvMiAtIGFzaW4oeClcclxuICpcclxuICogYWNvcygwKSAgICAgICA9IHBpLzJcclxuICogYWNvcygtMCkgICAgICA9IHBpLzJcclxuICogYWNvcygxKSAgICAgICA9IDBcclxuICogYWNvcygtMSkgICAgICA9IHBpXHJcbiAqIGFjb3MoMS8yKSAgICAgPSBwaS8zXHJcbiAqIGFjb3MoLTEvMikgICAgPSAyKnBpLzNcclxuICogYWNvcyh8eHwgPiAxKSA9IE5hTlxyXG4gKiBhY29zKE5hTikgICAgID0gTmFOXHJcbiAqXHJcbiAqL1xyXG5QLmludmVyc2VDb3NpbmUgPSBQLmFjb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBrID0geC5hYnMoKS5jbXAoMSksXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICBpZiAoayAhPT0gLTEpIHtcclxuICAgIHJldHVybiBrID09PSAwXHJcbiAgICAgIC8vIHx4fCBpcyAxXHJcbiAgICAgID8geC5pc05lZygpID8gZ2V0UGkoQ3RvciwgcHIsIHJtKSA6IG5ldyBDdG9yKDApXHJcbiAgICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgICAgOiBuZXcgQ3RvcihOYU4pO1xyXG4gIH1cclxuXHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG5cclxuICAvLyBUT0RPPyBTcGVjaWFsIGNhc2UgYWNvcygwLjUpID0gcGkvMyBhbmQgYWNvcygtMC41KSA9IDIqcGkvM1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWtlTWNsL2RlY2ltYWwuanMvcHVsbC8yMTdcclxuICB4ID0gbmV3IEN0b3IoMSkubWludXMoeCkuZGl2KHgucGx1cygxKSkuc3FydCgpLmF0YW4oKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LnRpbWVzKDIpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBpbiByYWRpYW5zIG9mIHRoZVxyXG4gKiB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWzEsIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWzAsIEluZmluaXR5XVxyXG4gKlxyXG4gKiBhY29zaCh4KSA9IGxuKHggKyBzcXJ0KHheMiAtIDEpKVxyXG4gKlxyXG4gKiBhY29zaCh4IDwgMSkgICAgID0gTmFOXHJcbiAqIGFjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICogYWNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAqIGFjb3NoKC1JbmZpbml0eSkgPSBOYU5cclxuICogYWNvc2goMCkgICAgICAgICA9IE5hTlxyXG4gKiBhY29zaCgtMCkgICAgICAgID0gTmFOXHJcbiAqIGFjb3NoKDEpICAgICAgICAgPSAwXHJcbiAqIGFjb3NoKC0xKSAgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNDb3NpbmUgPSBQLmFjb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoeC5sdGUoMSkpIHJldHVybiBuZXcgQ3Rvcih4LmVxKDEpID8gMCA6IE5hTik7XHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA0O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIHggPSB4LnRpbWVzKHgpLm1pbnVzKDEpLnNxcnQoKS5wbHVzKHgpO1xyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LmxuKCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgc2luZSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogYXNpbmgoeCkgPSBsbih4ICsgc3FydCh4XjIgKyAxKSlcclxuICpcclxuICogYXNpbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gKiBhc2luaChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogYXNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gKiBhc2luaCgwKSAgICAgICAgID0gMFxyXG4gKiBhc2luaCgtMCkgICAgICAgID0gLTBcclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNTaW5lID0gUC5hc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIHggPSB4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIHgubG4oKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IGluIHJhZGlhbnMgb2YgdGhlXHJcbiAqIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLTEsIDFdXHJcbiAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICpcclxuICogYXRhbmgoeCkgPSAwLjUgKiBsbigoMSArIHgpIC8gKDEgLSB4KSlcclxuICpcclxuICogYXRhbmgofHh8ID4gMSkgICA9IE5hTlxyXG4gKiBhdGFuaChOYU4pICAgICAgID0gTmFOXHJcbiAqIGF0YW5oKEluZmluaXR5KSAgPSBOYU5cclxuICogYXRhbmgoLUluZmluaXR5KSA9IE5hTlxyXG4gKiBhdGFuaCgwKSAgICAgICAgID0gMFxyXG4gKiBhdGFuaCgtMCkgICAgICAgID0gLTBcclxuICogYXRhbmgoMSkgICAgICAgICA9IEluZmluaXR5XHJcbiAqIGF0YW5oKC0xKSAgICAgICAgPSAtSW5maW5pdHlcclxuICpcclxuICovXHJcblAuaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ID0gUC5hdGFuaCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgcHIsIHJtLCB3cHIsIHhzZCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAoeC5lID49IDApIHJldHVybiBuZXcgQ3Rvcih4LmFicygpLmVxKDEpID8geC5zIC8gMCA6IHguaXNaZXJvKCkgPyB4IDogTmFOKTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgeHNkID0geC5zZCgpO1xyXG5cclxuICBpZiAoTWF0aC5tYXgoeHNkLCBwcikgPCAyICogLXguZSAtIDEpIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgcHIsIHJtLCB0cnVlKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSB4c2QgLSB4LmU7XHJcblxyXG4gIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHgubG4oKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiB4LnRpbWVzKDAuNSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3NpbmUgKGludmVyc2Ugc2luZSkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gKiBEZWNpbWFsLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1waS8yLCBwaS8yXVxyXG4gKlxyXG4gKiBhc2luKHgpID0gMiphdGFuKHgvKDEgKyBzcXJ0KDEgLSB4XjIpKSlcclxuICpcclxuICogYXNpbigwKSAgICAgICA9IDBcclxuICogYXNpbigtMCkgICAgICA9IC0wXHJcbiAqIGFzaW4oMS8yKSAgICAgPSBwaS82XHJcbiAqIGFzaW4oLTEvMikgICAgPSAtcGkvNlxyXG4gKiBhc2luKDEpICAgICAgID0gcGkvMlxyXG4gKiBhc2luKC0xKSAgICAgID0gLXBpLzJcclxuICogYXNpbih8eHwgPiAxKSA9IE5hTlxyXG4gKiBhc2luKE5hTikgICAgID0gTmFOXHJcbiAqXHJcbiAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgVGF5bG9yIHNlcmllcy5cclxuICpcclxuICovXHJcblAuaW52ZXJzZVNpbmUgPSBQLmFzaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIGhhbGZQaSwgayxcclxuICAgIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICh4LmlzWmVybygpKSByZXR1cm4gbmV3IEN0b3IoeCk7XHJcblxyXG4gIGsgPSB4LmFicygpLmNtcCgxKTtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgaWYgKGsgIT09IC0xKSB7XHJcblxyXG4gICAgLy8gfHh8IGlzIDFcclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIGhhbGZQaSA9IGdldFBpKEN0b3IsIHByICsgNCwgcm0pLnRpbWVzKDAuNSk7XHJcbiAgICAgIGhhbGZQaS5zID0geC5zO1xyXG4gICAgICByZXR1cm4gaGFsZlBpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gIH1cclxuXHJcbiAgLy8gVE9ETz8gU3BlY2lhbCBjYXNlIGFzaW4oMS8yKSA9IHBpLzYgYW5kIGFzaW4oLTEvMikgPSAtcGkvNlxyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgNjtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgeCA9IHguZGl2KG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKS5wbHVzKDEpKS5hdGFuKCk7XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICByZXR1cm4geC50aW1lcygyKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCAoaW52ZXJzZSB0YW5nZW50KSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAqXHJcbiAqIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAqXHJcbiAqIGF0YW4oMCkgICAgICAgICA9IDBcclxuICogYXRhbigtMCkgICAgICAgID0gLTBcclxuICogYXRhbigxKSAgICAgICAgID0gcGkvNFxyXG4gKiBhdGFuKC0xKSAgICAgICAgPSAtcGkvNFxyXG4gKiBhdGFuKEluZmluaXR5KSAgPSBwaS8yXHJcbiAqIGF0YW4oLUluZmluaXR5KSA9IC1waS8yXHJcbiAqIGF0YW4oTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC5pbnZlcnNlVGFuZ2VudCA9IFAuYXRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgaSwgaiwgaywgbiwgcHgsIHQsIHIsIHdwciwgeDIsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgaWYgKCF4LmlzRmluaXRlKCkpIHtcclxuICAgIGlmICgheC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgIGlmIChwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICAgIHIgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG4gICAgICByLnMgPSB4LnM7XHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG4gIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG4gIH0gZWxzZSBpZiAoeC5hYnMoKS5lcSgxKSAmJiBwciArIDQgPD0gUElfUFJFQ0lTSU9OKSB7XHJcbiAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XHJcbiAgICByLnMgPSB4LnM7XHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG4gIEN0b3IucHJlY2lzaW9uID0gd3ByID0gcHIgKyAxMDtcclxuICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgLy8gVE9ETz8gaWYgKHggPj0gMSAmJiBwciA8PSBQSV9QUkVDSVNJT04pIGF0YW4oeCkgPSBoYWxmUGkgKiB4LnMgLSBhdGFuKDEgLyB4KTtcclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgLy8gRW5zdXJlIHx4fCA8IDAuNDJcclxuICAvLyBhdGFuKHgpID0gMiAqIGF0YW4oeCAvICgxICsgc3FydCgxICsgeF4yKSkpXHJcblxyXG4gIGsgPSBNYXRoLm1pbigyOCwgd3ByIC8gTE9HX0JBU0UgKyAyIHwgMCk7XHJcblxyXG4gIGZvciAoaSA9IGs7IGk7IC0taSkgeCA9IHguZGl2KHgudGltZXMoeCkucGx1cygxKS5zcXJ0KCkucGx1cygxKSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gIGogPSBNYXRoLmNlaWwod3ByIC8gTE9HX0JBU0UpO1xyXG4gIG4gPSAxO1xyXG4gIHgyID0geC50aW1lcyh4KTtcclxuICByID0gbmV3IEN0b3IoeCk7XHJcbiAgcHggPSB4O1xyXG5cclxuICAvLyBhdGFuKHgpID0geCAtIHheMy8zICsgeF41LzUgLSB4XjcvNyArIC4uLlxyXG4gIGZvciAoOyBpICE9PSAtMTspIHtcclxuICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xyXG5cclxuICAgIHB4ID0gcHgudGltZXMoeDIpO1xyXG4gICAgciA9IHQucGx1cyhweC5kaXYobiArPSAyKSk7XHJcblxyXG4gICAgaWYgKHIuZFtqXSAhPT0gdm9pZCAwKSBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07KTtcclxuICB9XHJcblxyXG4gIGlmIChrKSByID0gci50aW1lcygyIDw8IChrIC0gMSkpO1xyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgYSBmaW5pdGUgbnVtYmVyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc0Zpbml0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gISF0aGlzLmQ7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhbiBpbnRlZ2VyLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5pc0ludGVnZXIgPSBQLmlzSW50ID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhdGhpcy5zO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbmVnYXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzTmVnYXRpdmUgPSBQLmlzTmVnID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnMgPCAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgcG9zaXRpdmUsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAqXHJcbiAqL1xyXG5QLmlzUG9zaXRpdmUgPSBQLmlzUG9zID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiB0aGlzLnMgPiAwO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcblAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiAhIXRoaXMuZCAmJiB0aGlzLmRbMF0gPT09IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5sZXNzVGhhbiA9IFAubHQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHJldHVybiB0aGlzLmNtcCh5KSA8IDA7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYHlgLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gKlxyXG4gKi9cclxuUC5sZXNzVGhhbk9yRXF1YWxUbyA9IFAubHRlID0gZnVuY3Rpb24gKHkpIHtcclxuICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgdG8gdGhlIHNwZWNpZmllZCBiYXNlLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIElmIG5vIGJhc2UgaXMgc3BlY2lmaWVkLCByZXR1cm4gbG9nWzEwXShhcmcpLlxyXG4gKlxyXG4gKiBsb2dbYmFzZV0oYXJnKSA9IGxuKGFyZykgLyBsbihiYXNlKVxyXG4gKlxyXG4gKiBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkIGlmIHRoZSBiYXNlIG9mIHRoZSBsb2cgaXMgMTAsIGFuZCAnYWxtb3N0IGFsd2F5cydcclxuICogb3RoZXJ3aXNlOlxyXG4gKlxyXG4gKiBEZXBlbmRpbmcgb24gdGhlIHJvdW5kaW5nIG1vZGUsIHRoZSByZXN1bHQgbWF5IGJlIGluY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGZpcnN0IGZpZnRlZW5cclxuICogcm91bmRpbmcgZGlnaXRzIGFyZSBbNDldOTk5OTk5OTk5OTk5OTkgb3IgWzUwXTAwMDAwMDAwMDAwMDAwLiBJbiB0aGF0IGNhc2UsIHRoZSBtYXhpbXVtIGVycm9yXHJcbiAqIGJldHdlZW4gdGhlIHJlc3VsdCBhbmQgdGhlIGNvcnJlY3RseSByb3VuZGVkIHJlc3VsdCB3aWxsIGJlIG9uZSB1bHAgKHVuaXQgaW4gdGhlIGxhc3QgcGxhY2UpLlxyXG4gKlxyXG4gKiBsb2dbLWJdKGEpICAgICAgID0gTmFOXHJcbiAqIGxvZ1swXShhKSAgICAgICAgPSBOYU5cclxuICogbG9nWzFdKGEpICAgICAgICA9IE5hTlxyXG4gKiBsb2dbTmFOXShhKSAgICAgID0gTmFOXHJcbiAqIGxvZ1tJbmZpbml0eV0oYSkgPSBOYU5cclxuICogbG9nW2JdKDApICAgICAgICA9IC1JbmZpbml0eVxyXG4gKiBsb2dbYl0oLTApICAgICAgID0gLUluZmluaXR5XHJcbiAqIGxvZ1tiXSgtYSkgICAgICAgPSBOYU5cclxuICogbG9nW2JdKDEpICAgICAgICA9IDBcclxuICogbG9nW2JdKEluZmluaXR5KSA9IEluZmluaXR5XHJcbiAqIGxvZ1tiXShOYU4pICAgICAgPSBOYU5cclxuICpcclxuICogW2Jhc2VdIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgYmFzZSBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gKlxyXG4gKi9cclxuUC5sb2dhcml0aG0gPSBQLmxvZyA9IGZ1bmN0aW9uIChiYXNlKSB7XHJcbiAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLFxyXG4gICAgYXJnID0gdGhpcyxcclxuICAgIEN0b3IgPSBhcmcuY29uc3RydWN0b3IsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nLFxyXG4gICAgZ3VhcmQgPSA1O1xyXG5cclxuICAvLyBEZWZhdWx0IGJhc2UgaXMgMTAuXHJcbiAgaWYgKGJhc2UgPT0gbnVsbCkge1xyXG4gICAgYmFzZSA9IG5ldyBDdG9yKDEwKTtcclxuICAgIGlzQmFzZTEwID0gdHJ1ZTtcclxuICB9IGVsc2Uge1xyXG4gICAgYmFzZSA9IG5ldyBDdG9yKGJhc2UpO1xyXG4gICAgZCA9IGJhc2UuZDtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIGJhc2UgaXMgbmVnYXRpdmUsIG9yIG5vbi1maW5pdGUsIG9yIGlzIDAgb3IgMS5cclxuICAgIGlmIChiYXNlLnMgPCAwIHx8ICFkIHx8ICFkWzBdIHx8IGJhc2UuZXEoMSkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIGlzQmFzZTEwID0gYmFzZS5lcSgxMCk7XHJcbiAgfVxyXG5cclxuICBkID0gYXJnLmQ7XHJcblxyXG4gIC8vIElzIGFyZyBuZWdhdGl2ZSwgbm9uLWZpbml0ZSwgMCBvciAxP1xyXG4gIGlmIChhcmcucyA8IDAgfHwgIWQgfHwgIWRbMF0gfHwgYXJnLmVxKDEpKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoZCAmJiAhZFswXSA/IC0xIC8gMCA6IGFyZy5zICE9IDEgPyBOYU4gOiBkID8gMCA6IDEgLyAwKTtcclxuICB9XHJcblxyXG4gIC8vIFRoZSByZXN1bHQgd2lsbCBoYXZlIGEgbm9uLXRlcm1pbmF0aW5nIGRlY2ltYWwgZXhwYW5zaW9uIGlmIGJhc2UgaXMgMTAgYW5kIGFyZyBpcyBub3QgYW5cclxuICAvLyBpbnRlZ2VyIHBvd2VyIG9mIDEwLlxyXG4gIGlmIChpc0Jhc2UxMCkge1xyXG4gICAgaWYgKGQubGVuZ3RoID4gMSkge1xyXG4gICAgICBpbmYgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZm9yIChrID0gZFswXTsgayAlIDEwID09PSAwOykgayAvPSAxMDtcclxuICAgICAgaW5mID0gayAhPT0gMTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgc2QgPSBwciArIGd1YXJkO1xyXG4gIG51bSA9IG5hdHVyYWxMb2dhcml0aG0oYXJnLCBzZCk7XHJcbiAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcclxuXHJcbiAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgNSByb3VuZGluZyBkaWdpdHMuXHJcbiAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XHJcblxyXG4gIC8vIElmIGF0IGEgcm91bmRpbmcgYm91bmRhcnksIGkuZS4gdGhlIHJlc3VsdCdzIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTkgb3IgWzUwXTAwMDAsXHJcbiAgLy8gY2FsY3VsYXRlIDEwIGZ1cnRoZXIgZGlnaXRzLlxyXG4gIC8vXHJcbiAgLy8gSWYgdGhlIHJlc3VsdCBpcyBrbm93biB0byBoYXZlIGFuIGluZmluaXRlIGRlY2ltYWwgZXhwYW5zaW9uLCByZXBlYXQgdGhpcyB1bnRpbCBpdCBpcyBjbGVhclxyXG4gIC8vIHRoYXQgdGhlIHJlc3VsdCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgYm91bmRhcnkuIE90aGVyd2lzZSwgaWYgYWZ0ZXIgY2FsY3VsYXRpbmcgdGhlIDEwXHJcbiAgLy8gZnVydGhlciBkaWdpdHMsIHRoZSBsYXN0IDE0IGFyZSBuaW5lcywgcm91bmQgdXAgYW5kIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0LlxyXG4gIC8vIEFsc28gYXNzdW1lIHRoZSByZXN1bHQgaXMgZXhhY3QgaWYgdGhlIGxhc3QgMTQgYXJlIHplcm8uXHJcbiAgLy9cclxuICAvLyBFeGFtcGxlIG9mIGEgcmVzdWx0IHRoYXQgd2lsbCBiZSBpbmNvcnJlY3RseSByb3VuZGVkOlxyXG4gIC8vIGxvZ1sxMDQ4NTc2XSg0NTAzNTk5NjI3MzcwNTAyKSA9IDIuNjAwMDAwMDAwMDAwMDAwMDk2MTAyNzk1MTE0NDQ3NDYuLi5cclxuICAvLyBUaGUgYWJvdmUgcmVzdWx0IGNvcnJlY3RseSByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsIHBsYWNlIHNob3VsZCBiZSAyLjcsIGJ1dCBpdFxyXG4gIC8vIHdpbGwgYmUgZ2l2ZW4gYXMgMi42IGFzIHRoZXJlIGFyZSAxNSB6ZXJvcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgcmVxdWVzdGVkIGRlY2ltYWwgcGxhY2UsIHNvXHJcbiAgLy8gdGhlIGV4YWN0IHJlc3VsdCB3b3VsZCBiZSBhc3N1bWVkIHRvIGJlIDIuNiwgd2hpY2ggcm91bmRlZCB1c2luZyBST1VORF9DRUlMIHRvIDEgZGVjaW1hbFxyXG4gIC8vIHBsYWNlIGlzIHN0aWxsIDIuNi5cclxuICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgPSBwciwgcm0pKSB7XHJcblxyXG4gICAgZG8ge1xyXG4gICAgICBzZCArPSAxMDtcclxuICAgICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcclxuICAgICAgZGVub21pbmF0b3IgPSBpc0Jhc2UxMCA/IGdldExuMTAoQ3Rvciwgc2QgKyAxMCkgOiBuYXR1cmFsTG9nYXJpdGhtKGJhc2UsIHNkKTtcclxuICAgICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XHJcblxyXG4gICAgICBpZiAoIWluZikge1xyXG5cclxuICAgICAgICAvLyBDaGVjayBmb3IgMTQgbmluZXMgZnJvbSB0aGUgMm5kIHJvdW5kaW5nIGRpZ2l0LCBhcyB0aGUgZmlyc3QgbWF5IGJlIDQuXHJcbiAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKGsgKyAxLCBrICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9IHdoaWxlIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayArPSAxMCwgcm0pKTtcclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIHByLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cyBhbmQgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG5QLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMuY29uc3RydWN0b3IsIGFyZ3VtZW50cywgLTEpO1xyXG59O1xyXG4gKi9cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcblAubWluID0gZnVuY3Rpb24gKCkge1xyXG4gIEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwoYXJndW1lbnRzLCB0aGlzKTtcclxuICByZXR1cm4gbWF4T3JNaW4odGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCAxKTtcclxufTtcclxuICovXHJcblxyXG5cclxuLypcclxuICogIG4gLSAwID0gblxyXG4gKiAgbiAtIE4gPSBOXHJcbiAqICBuIC0gSSA9IC1JXHJcbiAqICAwIC0gbiA9IC1uXHJcbiAqICAwIC0gMCA9IDBcclxuICogIDAgLSBOID0gTlxyXG4gKiAgMCAtIEkgPSAtSVxyXG4gKiAgTiAtIG4gPSBOXHJcbiAqICBOIC0gMCA9IE5cclxuICogIE4gLSBOID0gTlxyXG4gKiAgTiAtIEkgPSBOXHJcbiAqICBJIC0gbiA9IElcclxuICogIEkgLSAwID0gSVxyXG4gKiAgSSAtIE4gPSBOXHJcbiAqICBJIC0gSSA9IE5cclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtaW51cyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGQsIGUsIGksIGosIGssIGxlbiwgcHIsIHJtLCB4ZCwgeGUsIHhMVHksIHlkLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAvLyBJZiBlaXRoZXIgaXMgbm90IGZpbml0ZS4uLlxyXG4gIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIGVpdGhlciBpcyBOYU4uXHJcbiAgICBpZiAoIXgucyB8fCAheS5zKSB5ID0gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAvLyBSZXR1cm4geSBuZWdhdGVkIGlmIHggaXMgZmluaXRlIGFuZCB5IGlzIMKxSW5maW5pdHkuXHJcbiAgICBlbHNlIGlmICh4LmQpIHkucyA9IC15LnM7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyBmaW5pdGUgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgIC8vIFJldHVybiB4IGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCBkaWZmZXJlbnQgc2lnbnMuXHJcbiAgICAvLyBSZXR1cm4gTmFOIGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG4gICAgZWxzZSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyAhPT0geS5zID8geCA6IE5hTik7XHJcblxyXG4gICAgcmV0dXJuIHk7XHJcbiAgfVxyXG5cclxuICAvLyBJZiBzaWducyBkaWZmZXIuLi5cclxuICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgeS5zID0gLXkucztcclxuICAgIHJldHVybiB4LnBsdXMoeSk7XHJcbiAgfVxyXG5cclxuICB4ZCA9IHguZDtcclxuICB5ZCA9IHkuZDtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgLy8gSWYgZWl0aGVyIGlzIHplcm8uLi5cclxuICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xyXG5cclxuICAgIC8vIFJldHVybiB5IG5lZ2F0ZWQgaWYgeCBpcyB6ZXJvIGFuZCB5IGlzIG5vbi16ZXJvLlxyXG4gICAgaWYgKHlkWzBdKSB5LnMgPSAteS5zO1xyXG5cclxuICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVybyBhbmQgeCBpcyBub24temVyby5cclxuICAgIGVsc2UgaWYgKHhkWzBdKSB5ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gICAgLy8gUmV0dXJuIHplcm8gaWYgYm90aCBhcmUgemVyby5cclxuICAgIC8vIEZyb20gSUVFRSA3NTQgKDIwMDgpIDYuMzogMCAtIDAgPSAtMCAtIC0wID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHkuXHJcbiAgICBlbHNlIHJldHVybiBuZXcgQ3RvcihybSA9PT0gMyA/IC0wIDogMCk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbiAgfVxyXG5cclxuICAvLyB4IGFuZCB5IGFyZSBmaW5pdGUsIG5vbi16ZXJvIG51bWJlcnMgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG5cclxuICAvLyBDYWxjdWxhdGUgYmFzZSAxZTcgZXhwb25lbnRzLlxyXG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gIHhlID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcclxuXHJcbiAgeGQgPSB4ZC5zbGljZSgpO1xyXG4gIGsgPSB4ZSAtIGU7XHJcblxyXG4gIC8vIElmIGJhc2UgMWU3IGV4cG9uZW50cyBkaWZmZXIuLi5cclxuICBpZiAoaykge1xyXG4gICAgeExUeSA9IGsgPCAwO1xyXG5cclxuICAgIGlmICh4TFR5KSB7XHJcbiAgICAgIGQgPSB4ZDtcclxuICAgICAgayA9IC1rO1xyXG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkID0geWQ7XHJcbiAgICAgIGUgPSB4ZTtcclxuICAgICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE51bWJlcnMgd2l0aCBtYXNzaXZlbHkgZGlmZmVyZW50IGV4cG9uZW50cyB3b3VsZCByZXN1bHQgaW4gYSB2ZXJ5IGhpZ2ggbnVtYmVyIG9mXHJcbiAgICAvLyB6ZXJvcyBuZWVkaW5nIHRvIGJlIHByZXBlbmRlZCwgYnV0IHRoaXMgY2FuIGJlIGF2b2lkZWQgd2hpbGUgc3RpbGwgZW5zdXJpbmcgY29ycmVjdFxyXG4gICAgLy8gcm91bmRpbmcgYnkgbGltaXRpbmcgdGhlIG51bWJlciBvZiB6ZXJvcyB0byBgTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpICsgMmAuXHJcbiAgICBpID0gTWF0aC5tYXgoTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpLCBsZW4pICsgMjtcclxuXHJcbiAgICBpZiAoayA+IGkpIHtcclxuICAgICAgayA9IGk7XHJcbiAgICAgIGQubGVuZ3RoID0gMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgIGQucmV2ZXJzZSgpO1xyXG4gICAgZm9yIChpID0gazsgaS0tOykgZC5wdXNoKDApO1xyXG4gICAgZC5yZXZlcnNlKCk7XHJcblxyXG4gIC8vIEJhc2UgMWU3IGV4cG9uZW50cyBlcXVhbC5cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIENoZWNrIGRpZ2l0cyB0byBkZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcblxyXG4gICAgaSA9IHhkLmxlbmd0aDtcclxuICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgIHhMVHkgPSBpIDwgbGVuO1xyXG4gICAgaWYgKHhMVHkpIGxlbiA9IGk7XHJcblxyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcbiAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xyXG4gICAgICAgIHhMVHkgPSB4ZFtpXSA8IHlkW2ldO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgayA9IDA7XHJcbiAgfVxyXG5cclxuICBpZiAoeExUeSkge1xyXG4gICAgZCA9IHhkO1xyXG4gICAgeGQgPSB5ZDtcclxuICAgIHlkID0gZDtcclxuICAgIHkucyA9IC15LnM7XHJcbiAgfVxyXG5cclxuICBsZW4gPSB4ZC5sZW5ndGg7XHJcblxyXG4gIC8vIEFwcGVuZCB6ZXJvcyB0byBgeGRgIGlmIHNob3J0ZXIuXHJcbiAgLy8gRG9uJ3QgYWRkIHplcm9zIHRvIGB5ZGAgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IGB5ZGAgbGVuZ3RoLlxyXG4gIGZvciAoaSA9IHlkLmxlbmd0aCAtIGxlbjsgaSA+IDA7IC0taSkgeGRbbGVuKytdID0gMDtcclxuXHJcbiAgLy8gU3VidHJhY3QgeWQgZnJvbSB4ZC5cclxuICBmb3IgKGkgPSB5ZC5sZW5ndGg7IGkgPiBrOykge1xyXG5cclxuICAgIGlmICh4ZFstLWldIDwgeWRbaV0pIHtcclxuICAgICAgZm9yIChqID0gaTsgaiAmJiB4ZFstLWpdID09PSAwOykgeGRbal0gPSBCQVNFIC0gMTtcclxuICAgICAgLS14ZFtqXTtcclxuICAgICAgeGRbaV0gKz0gQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICB4ZFtpXSAtPSB5ZFtpXTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICBmb3IgKDsgeGRbLS1sZW5dID09PSAwOykgeGQucG9wKCk7XHJcblxyXG4gIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zIGFuZCBhZGp1c3QgZXhwb25lbnQgYWNjb3JkaW5nbHkuXHJcbiAgZm9yICg7IHhkWzBdID09PSAwOyB4ZC5zaGlmdCgpKSAtLWU7XHJcblxyXG4gIC8vIFplcm8/XHJcbiAgaWYgKCF4ZFswXSkgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcclxuXHJcbiAgeS5kID0geGQ7XHJcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xyXG5cclxuICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiAgIG4gJSAwID0gIE5cclxuICogICBuICUgTiA9ICBOXHJcbiAqICAgbiAlIEkgPSAgblxyXG4gKiAgIDAgJSBuID0gIDBcclxuICogIC0wICUgbiA9IC0wXHJcbiAqICAgMCAlIDAgPSAgTlxyXG4gKiAgIDAgJSBOID0gIE5cclxuICogICAwICUgSSA9ICAwXHJcbiAqICAgTiAlIG4gPSAgTlxyXG4gKiAgIE4gJSAwID0gIE5cclxuICogICBOICUgTiA9ICBOXHJcbiAqICAgTiAlIEkgPSAgTlxyXG4gKiAgIEkgJSBuID0gIE5cclxuICogICBJICUgMCA9ICBOXHJcbiAqICAgSSAlIE4gPSAgTlxyXG4gKiAgIEkgJSBJID0gIE5cclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvXHJcbiAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgbW9kdWxvIG1vZGUuXHJcbiAqXHJcbiAqL1xyXG5QLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHkpIHtcclxuICB2YXIgcSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHkgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIMKxSW5maW5pdHkgb3IgTmFOLCBvciB5IGlzIE5hTiBvciDCsTAuXHJcbiAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gIC8vIFJldHVybiB4IGlmIHkgaXMgwrFJbmZpbml0eSBvciB4IGlzIMKxMC5cclxuICBpZiAoIXkuZCB8fCB4LmQgJiYgIXguZFswXSkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgfVxyXG5cclxuICAvLyBQcmV2ZW50IHJvdW5kaW5nIG9mIGludGVybWVkaWF0ZSBjYWxjdWxhdGlvbnMuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgaWYgKEN0b3IubW9kdWxvID09IDkpIHtcclxuXHJcbiAgICAvLyBFdWNsaWRpYW4gZGl2aXNpb246IHEgPSBzaWduKHkpICogZmxvb3IoeCAvIGFicyh5KSlcclxuICAgIC8vIHJlc3VsdCA9IHggLSBxICogeSAgICB3aGVyZSAgMCA8PSByZXN1bHQgPCBhYnMoeSlcclxuICAgIHEgPSBkaXZpZGUoeCwgeS5hYnMoKSwgMCwgMywgMSk7XHJcbiAgICBxLnMgKj0geS5zO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBxID0gZGl2aWRlKHgsIHksIDAsIEN0b3IubW9kdWxvLCAxKTtcclxuICB9XHJcblxyXG4gIHEgPSBxLnRpbWVzKHkpO1xyXG5cclxuICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gIHJldHVybiB4Lm1pbnVzKHEpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAqIGkuZS4gdGhlIGJhc2UgZSByYWlzZWQgdG8gdGhlIHBvd2VyIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAubmF0dXJhbEV4cG9uZW50aWFsID0gUC5leHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgcmV0dXJuIG5hdHVyYWxFeHBvbmVudGlhbCh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCxcclxuICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5uYXR1cmFsTG9nYXJpdGhtID0gUC5sbiA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gbmF0dXJhbExvZ2FyaXRobSh0aGlzKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIG5lZ2F0ZWQsIGkuZS4gYXMgaWYgbXVsdGlwbGllZCBieVxyXG4gKiAtMS5cclxuICpcclxuICovXHJcblAubmVnYXRlZCA9IFAubmVnID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgeC5zID0gLXgucztcclxuICByZXR1cm4gZmluYWxpc2UoeCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogIG4gKyAwID0gblxyXG4gKiAgbiArIE4gPSBOXHJcbiAqICBuICsgSSA9IElcclxuICogIDAgKyBuID0gblxyXG4gKiAgMCArIDAgPSAwXHJcbiAqICAwICsgTiA9IE5cclxuICogIDAgKyBJID0gSVxyXG4gKiAgTiArIG4gPSBOXHJcbiAqICBOICsgMCA9IE5cclxuICogIE4gKyBOID0gTlxyXG4gKiAgTiArIEkgPSBOXHJcbiAqICBJICsgbiA9IElcclxuICogIEkgKyAwID0gSVxyXG4gKiAgSSArIE4gPSBOXHJcbiAqICBJICsgSSA9IElcclxuICpcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBwbHVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5wbHVzID0gUC5hZGQgPSBmdW5jdGlvbiAoeSkge1xyXG4gIHZhciBjYXJyeSwgZCwgZSwgaSwgaywgbGVuLCBwciwgcm0sIHhkLCB5ZCxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIHkgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICBpZiAoIXguZCB8fCAheS5kKSB7XHJcblxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyBmaW5pdGUgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgIC8vIFJldHVybiB4IGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCB0aGUgc2FtZSBzaWduLlxyXG4gICAgLy8gUmV0dXJuIE5hTiBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgLy8gUmV0dXJuIHkgaWYgeCBpcyBmaW5pdGUgYW5kIHkgaXMgwrFJbmZpbml0eS5cclxuICAgIGVsc2UgaWYgKCF4LmQpIHkgPSBuZXcgQ3Rvcih5LmQgfHwgeC5zID09PSB5LnMgPyB4IDogTmFOKTtcclxuXHJcbiAgICByZXR1cm4geTtcclxuICB9XHJcblxyXG4gICAvLyBJZiBzaWducyBkaWZmZXIuLi5cclxuICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgeS5zID0gLXkucztcclxuICAgIHJldHVybiB4Lm1pbnVzKHkpO1xyXG4gIH1cclxuXHJcbiAgeGQgPSB4LmQ7XHJcbiAgeWQgPSB5LmQ7XHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIC8vIElmIGVpdGhlciBpcyB6ZXJvLi4uXHJcbiAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAvLyBSZXR1cm4geCBpZiB5IGlzIHplcm8uXHJcbiAgICAvLyBSZXR1cm4geSBpZiB5IGlzIG5vbi16ZXJvLlxyXG4gICAgaWYgKCF5ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gIH1cclxuXHJcbiAgLy8geCBhbmQgeSBhcmUgZmluaXRlLCBub24temVybyBudW1iZXJzIHdpdGggdGhlIHNhbWUgc2lnbi5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICBrID0gbWF0aGZsb29yKHguZSAvIExPR19CQVNFKTtcclxuICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgeGQgPSB4ZC5zbGljZSgpO1xyXG4gIGkgPSBrIC0gZTtcclxuXHJcbiAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gIGlmIChpKSB7XHJcblxyXG4gICAgaWYgKGkgPCAwKSB7XHJcbiAgICAgIGQgPSB4ZDtcclxuICAgICAgaSA9IC1pO1xyXG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBkID0geWQ7XHJcbiAgICAgIGUgPSBrO1xyXG4gICAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTGltaXQgbnVtYmVyIG9mIHplcm9zIHByZXBlbmRlZCB0byBtYXgoY2VpbChwciAvIExPR19CQVNFKSwgbGVuKSArIDEuXHJcbiAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xyXG4gICAgbGVuID0gayA+IGxlbiA/IGsgKyAxIDogbGVuICsgMTtcclxuXHJcbiAgICBpZiAoaSA+IGxlbikge1xyXG4gICAgICBpID0gbGVuO1xyXG4gICAgICBkLmxlbmd0aCA9IDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIE5vdGU6IEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgZC5yZXZlcnNlKCk7XHJcbiAgICBmb3IgKDsgaS0tOykgZC5wdXNoKDApO1xyXG4gICAgZC5yZXZlcnNlKCk7XHJcbiAgfVxyXG5cclxuICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgaSA9IHlkLmxlbmd0aDtcclxuXHJcbiAgLy8gSWYgeWQgaXMgbG9uZ2VyIHRoYW4geGQsIHN3YXAgeGQgYW5kIHlkIHNvIHhkIHBvaW50cyB0byB0aGUgbG9uZ2VyIGFycmF5LlxyXG4gIGlmIChsZW4gLSBpIDwgMCkge1xyXG4gICAgaSA9IGxlbjtcclxuICAgIGQgPSB5ZDtcclxuICAgIHlkID0geGQ7XHJcbiAgICB4ZCA9IGQ7XHJcbiAgfVxyXG5cclxuICAvLyBPbmx5IHN0YXJ0IGFkZGluZyBhdCB5ZC5sZW5ndGggLSAxIGFzIHRoZSBmdXJ0aGVyIGRpZ2l0cyBvZiB4ZCBjYW4gYmUgbGVmdCBhcyB0aGV5IGFyZS5cclxuICBmb3IgKGNhcnJ5ID0gMDsgaTspIHtcclxuICAgIGNhcnJ5ID0gKHhkWy0taV0gPSB4ZFtpXSArIHlkW2ldICsgY2FycnkpIC8gQkFTRSB8IDA7XHJcbiAgICB4ZFtpXSAlPSBCQVNFO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhcnJ5KSB7XHJcbiAgICB4ZC51bnNoaWZ0KGNhcnJ5KTtcclxuICAgICsrZTtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgZm9yIChsZW4gPSB4ZC5sZW5ndGg7IHhkWy0tbGVuXSA9PSAwOykgeGQucG9wKCk7XHJcblxyXG4gIHkuZCA9IHhkO1xyXG4gIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIHRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgZGlnaXRzIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIFt6XSB7Ym9vbGVhbnxudW1iZXJ9IFdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gKlxyXG4gKi9cclxuUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcclxuICB2YXIgayxcclxuICAgIHggPSB0aGlzO1xyXG5cclxuICBpZiAoeiAhPT0gdm9pZCAwICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDApIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHopO1xyXG5cclxuICBpZiAoeC5kKSB7XHJcbiAgICBrID0gZ2V0UHJlY2lzaW9uKHguZCk7XHJcbiAgICBpZiAoeiAmJiB4LmUgKyAxID4gaykgayA9IHguZSArIDE7XHJcbiAgfSBlbHNlIHtcclxuICAgIGsgPSBOYU47XHJcbiAgfVxyXG5cclxuICByZXR1cm4gaztcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgdXNpbmdcclxuICogcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKi9cclxuUC5yb3VuZCA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCB4LmUgKyAxLCBDdG9yLnJvdW5kaW5nKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAqIFJhbmdlOiBbLTEsIDFdXHJcbiAqXHJcbiAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICpcclxuICogc2luKDApICAgICAgICAgPSAwXHJcbiAqIHNpbigtMCkgICAgICAgID0gLTBcclxuICogc2luKEluZmluaXR5KSAgPSBOYU5cclxuICogc2luKC1JbmZpbml0eSkgPSBOYU5cclxuICogc2luKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICovXHJcblAuc2luZSA9IFAuc2luID0gZnVuY3Rpb24gKCkge1xyXG4gIHZhciBwciwgcm0sXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xyXG4gIEN0b3Iucm91bmRpbmcgPSAxO1xyXG5cclxuICB4ID0gc2luZShDdG9yLCB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpKTtcclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShxdWFkcmFudCA+IDIgPyB4Lm5lZygpIDogeCwgcHIsIHJtLCB0cnVlKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqICBzcXJ0KC1uKSA9ICBOXHJcbiAqICBzcXJ0KE4pICA9ICBOXHJcbiAqICBzcXJ0KC1JKSA9ICBOXHJcbiAqICBzcXJ0KEkpICA9ICBJXHJcbiAqICBzcXJ0KDApICA9ICAwXHJcbiAqICBzcXJ0KC0wKSA9IC0wXHJcbiAqXHJcbiAqL1xyXG5QLnNxdWFyZVJvb3QgPSBQLnNxcnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIG0sIG4sIHNkLCByLCByZXAsIHQsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIGQgPSB4LmQsXHJcbiAgICBlID0geC5lLFxyXG4gICAgcyA9IHgucyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAvLyBOZWdhdGl2ZS9OYU4vSW5maW5pdHkvemVybz9cclxuICBpZiAocyAhPT0gMSB8fCAhZCB8fCAhZFswXSkge1xyXG4gICAgcmV0dXJuIG5ldyBDdG9yKCFzIHx8IHMgPCAwICYmICghZCB8fCBkWzBdKSA/IE5hTiA6IGQgPyB4IDogMSAvIDApO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICBzID0gTWF0aC5zcXJ0KCt4KTtcclxuXHJcbiAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAvLyBQYXNzIHggdG8gTWF0aC5zcXJ0IGFzIGludGVnZXIsIHRoZW4gYWRqdXN0IHRoZSBleHBvbmVudCBvZiB0aGUgcmVzdWx0LlxyXG4gIGlmIChzID09IDAgfHwgcyA9PSAxIC8gMCkge1xyXG4gICAgbiA9IGRpZ2l0c1RvU3RyaW5nKGQpO1xyXG5cclxuICAgIGlmICgobi5sZW5ndGggKyBlKSAlIDIgPT0gMCkgbiArPSAnMCc7XHJcbiAgICBzID0gTWF0aC5zcXJ0KG4pO1xyXG4gICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgIGlmIChzID09IDEgLyAwKSB7XHJcbiAgICAgIG4gPSAnNWUnICsgZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIG4gPSBzLnRvRXhwb25lbnRpYWwoKTtcclxuICAgICAgbiA9IG4uc2xpY2UoMCwgbi5pbmRleE9mKCdlJykgKyAxKSArIGU7XHJcbiAgICB9XHJcblxyXG4gICAgciA9IG5ldyBDdG9yKG4pO1xyXG4gIH0gZWxzZSB7XHJcbiAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICB9XHJcblxyXG4gIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xyXG5cclxuICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IHI7XHJcbiAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xyXG5cclxuICAgIC8vIFRPRE8/IFJlcGxhY2Ugd2l0aCBmb3ItbG9vcCBhbmQgY2hlY2tSb3VuZGluZ0RpZ2l0cy5cclxuICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcclxuICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgLy8gVGhlIDR0aCByb3VuZGluZyBkaWdpdCBtYXkgYmUgaW4gZXJyb3IgYnkgLTEgc28gaWYgdGhlIDQgcm91bmRpbmcgZGlnaXRzIGFyZSA5OTk5IG9yXHJcbiAgICAgIC8vIDQ5OTksIGkuZS4gYXBwcm9hY2hpbmcgYSByb3VuZGluZyBib3VuZGFyeSwgY29udGludWUgdGhlIGl0ZXJhdGlvbi5cclxuICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgLy8gT24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBvbmx5LCBjaGVjayB0byBzZWUgaWYgcm91bmRpbmcgdXAgZ2l2ZXMgdGhlIGV4YWN0IHJlc3VsdCBhcyB0aGVcclxuICAgICAgICAvLyBuaW5lcyBtYXkgaW5maW5pdGVseSByZXBlYXQuXHJcbiAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgIGZpbmFsaXNlKHQsIGUgKyAxLCAwKTtcclxuXHJcbiAgICAgICAgICBpZiAodC50aW1lcyh0KS5lcSh4KSkge1xyXG4gICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzZCArPSA0O1xyXG4gICAgICAgIHJlcCA9IDE7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIElmIHRoZSByb3VuZGluZyBkaWdpdHMgYXJlIG51bGwsIDB7MCw0fSBvciA1MHswLDN9LCBjaGVjayBmb3IgYW4gZXhhY3QgcmVzdWx0LlxyXG4gICAgICAgIC8vIElmIG5vdCwgdGhlbiB0aGVyZSBhcmUgZnVydGhlciBkaWdpdHMgYW5kIG0gd2lsbCBiZSB0cnV0aHkuXHJcbiAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgLy8gVHJ1bmNhdGUgdG8gdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgICAgZmluYWxpc2UociwgZSArIDEsIDEpO1xyXG4gICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHIsIGUsIEN0b3Iucm91bmRpbmcsIG0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXMgRGVjaW1hbC5cclxuICpcclxuICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICogUmFuZ2U6IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKlxyXG4gKiB0YW4oMCkgICAgICAgICA9IDBcclxuICogdGFuKC0wKSAgICAgICAgPSAtMFxyXG4gKiB0YW4oSW5maW5pdHkpICA9IE5hTlxyXG4gKiB0YW4oLUluZmluaXR5KSA9IE5hTlxyXG4gKiB0YW4oTmFOKSAgICAgICA9IE5hTlxyXG4gKlxyXG4gKi9cclxuUC50YW5nZW50ID0gUC50YW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHByLCBybSxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICBDdG9yLnByZWNpc2lvbiA9IHByICsgMTA7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gIHggPSB4LnNpbigpO1xyXG4gIHgucyA9IDE7XHJcbiAgeCA9IGRpdmlkZSh4LCBuZXcgQ3RvcigxKS5taW51cyh4LnRpbWVzKHgpKS5zcXJ0KCksIHByICsgMTAsIDApO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gNCA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqICBuICogMCA9IDBcclxuICogIG4gKiBOID0gTlxyXG4gKiAgbiAqIEkgPSBJXHJcbiAqICAwICogbiA9IDBcclxuICogIDAgKiAwID0gMFxyXG4gKiAgMCAqIE4gPSBOXHJcbiAqICAwICogSSA9IE5cclxuICogIE4gKiBuID0gTlxyXG4gKiAgTiAqIDAgPSBOXHJcbiAqICBOICogTiA9IE5cclxuICogIE4gKiBJID0gTlxyXG4gKiAgSSAqIG4gPSBJXHJcbiAqICBJICogMCA9IE5cclxuICogIEkgKiBOID0gTlxyXG4gKiAgSSAqIEkgPSBJXHJcbiAqXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoaXMgRGVjaW1hbCB0aW1lcyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICovXHJcblAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGNhcnJ5LCBlLCBpLCBrLCByLCByTCwgdCwgeGRMLCB5ZEwsXHJcbiAgICB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICB5ZCA9ICh5ID0gbmV3IEN0b3IoeSkpLmQ7XHJcblxyXG4gIHkucyAqPSB4LnM7XHJcblxyXG4gICAvLyBJZiBlaXRoZXIgaXMgTmFOLCDCsUluZmluaXR5IG9yIMKxMC4uLlxyXG4gIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcclxuXHJcbiAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGRcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiB4IGlzIMKxMCBhbmQgeSBpcyDCsUluZmluaXR5LCBvciB5IGlzIMKxMCBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgICA/IE5hTlxyXG5cclxuICAgICAgLy8gUmV0dXJuIMKxSW5maW5pdHkgaWYgZWl0aGVyIGlzIMKxSW5maW5pdHkuXHJcbiAgICAgIC8vIFJldHVybiDCsTAgaWYgZWl0aGVyIGlzIMKxMC5cclxuICAgICAgOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xyXG4gIH1cclxuXHJcbiAgZSA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSkgKyBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gIHhkTCA9IHhkLmxlbmd0aDtcclxuICB5ZEwgPSB5ZC5sZW5ndGg7XHJcblxyXG4gIC8vIEVuc3VyZSB4ZCBwb2ludHMgdG8gdGhlIGxvbmdlciBhcnJheS5cclxuICBpZiAoeGRMIDwgeWRMKSB7XHJcbiAgICByID0geGQ7XHJcbiAgICB4ZCA9IHlkO1xyXG4gICAgeWQgPSByO1xyXG4gICAgckwgPSB4ZEw7XHJcbiAgICB4ZEwgPSB5ZEw7XHJcbiAgICB5ZEwgPSByTDtcclxuICB9XHJcblxyXG4gIC8vIEluaXRpYWxpc2UgdGhlIHJlc3VsdCBhcnJheSB3aXRoIHplcm9zLlxyXG4gIHIgPSBbXTtcclxuICByTCA9IHhkTCArIHlkTDtcclxuICBmb3IgKGkgPSByTDsgaS0tOykgci5wdXNoKDApO1xyXG5cclxuICAvLyBNdWx0aXBseSFcclxuICBmb3IgKGkgPSB5ZEw7IC0taSA+PSAwOykge1xyXG4gICAgY2FycnkgPSAwO1xyXG4gICAgZm9yIChrID0geGRMICsgaTsgayA+IGk7KSB7XHJcbiAgICAgIHQgPSByW2tdICsgeWRbaV0gKiB4ZFtrIC0gaSAtIDFdICsgY2Fycnk7XHJcbiAgICAgIHJbay0tXSA9IHQgJSBCQVNFIHwgMDtcclxuICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XHJcbiAgICB9XHJcblxyXG4gICAgcltrXSA9IChyW2tdICsgY2FycnkpICUgQkFTRSB8IDA7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yICg7ICFyWy0tckxdOykgci5wb3AoKTtcclxuXHJcbiAgaWYgKGNhcnJ5KSArK2U7XHJcbiAgZWxzZSByLnNoaWZ0KCk7XHJcblxyXG4gIHkuZCA9IHI7XHJcbiAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQociwgZSk7XHJcblxyXG4gIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKSA6IHk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgMiwgcm91bmQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLlxyXG4gKlxyXG4gKiBJZiB0aGUgb3B0aW9uYWwgYHNkYCBhcmd1bWVudCBpcyBwcmVzZW50IHRoZW4gcmV0dXJuIGJpbmFyeSBleHBvbmVudGlhbCBub3RhdGlvbi5cclxuICpcclxuICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICovXHJcblAudG9CaW5hcnkgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgcmV0dXJuIHRvU3RyaW5nQmluYXJ5KHRoaXMsIDIsIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGEgbWF4aW11bSBvZiBgZHBgXHJcbiAqIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCBvciBgcm91bmRpbmdgIGlmIGBybWAgaXMgb21pdHRlZC5cclxuICpcclxuICogSWYgYGRwYCBpcyBvbWl0dGVkLCByZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvRGVjaW1hbFBsYWNlcyA9IFAudG9EUCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gIGlmIChkcCA9PT0gdm9pZCAwKSByZXR1cm4geDtcclxuXHJcbiAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsaXNlKHgsIGRwICsgeC5lICsgMSwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBleHBvbmVudGlhbCBub3RhdGlvbiByb3VuZGVkIHRvXHJcbiAqIGBkcGAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvRXhwb25lbnRpYWwgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgdmFyIHN0cixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB0cnVlKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUsIGRwICsgMSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBub3JtYWwgKGZpeGVkLXBvaW50KSBub3RhdGlvbiB0b1xyXG4gKiBgZHBgIGZpeGVkIGRlY2ltYWwgcGxhY2VzIGFuZCByb3VuZGVkIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCBvciBgcm91bmRpbmdgIGlmIGBybWAgaXNcclxuICogb21pdHRlZC5cclxuICpcclxuICogQXMgd2l0aCBKYXZhU2NyaXB0IG51bWJlcnMsICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCBlLmcuICgtMC4wMDAwMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKlxyXG4gKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gKiAoLTApLnRvRml4ZWQoMSkgaXMgJzAuMCcsIGJ1dCAoLTAuMDEpLnRvRml4ZWQoMSkgaXMgJy0wLjAnLlxyXG4gKiAoLTApLnRvRml4ZWQoMykgaXMgJzAuMDAwJy5cclxuICogKC0wLjUpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICpcclxuICovXHJcblAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICB2YXIgc3RyLCB5LFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKGRwID09PSB2b2lkIDApIHtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICB5ID0gZmluYWxpc2UobmV3IEN0b3IoeCksIGRwICsgeC5lICsgMSwgcm0pO1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeSwgZmFsc2UsIGRwICsgeS5lICsgMSk7XHJcbiAgfVxyXG5cclxuICAvLyBUbyBkZXRlcm1pbmUgd2hldGhlciB0byBhZGQgdGhlIG1pbnVzIHNpZ24gbG9vayBhdCB0aGUgdmFsdWUgYmVmb3JlIGl0IHdhcyByb3VuZGVkLFxyXG4gIC8vIGkuZS4gbG9vayBhdCBgeGAgcmF0aGVyIHRoYW4gYHlgLlxyXG4gIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGFzIGEgc2ltcGxlIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlclxyXG4gKiBudW1lcmF0b3IgYW5kIGFuIGludGVnZXIgZGVub21pbmF0b3IuXHJcbiAqXHJcbiAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bVxyXG4gKiBkZW5vbWluYXRvci4gSWYgYSBtYXhpbXVtIGRlbm9taW5hdG9yIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBkZW5vbWluYXRvciB3aWxsIGJlIHRoZSBsb3dlc3RcclxuICogdmFsdWUgbmVjZXNzYXJ5IHRvIHJlcHJlc2VudCB0aGUgbnVtYmVyIGV4YWN0bHkuXHJcbiAqXHJcbiAqIFttYXhEXSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gTWF4aW11bSBkZW5vbWluYXRvci4gSW50ZWdlciA+PSAxIGFuZCA8IEluZmluaXR5LlxyXG4gKlxyXG4gKi9cclxuUC50b0ZyYWN0aW9uID0gZnVuY3Rpb24gKG1heEQpIHtcclxuICB2YXIgZCwgZDAsIGQxLCBkMiwgZSwgaywgbiwgbjAsIG4xLCBwciwgcSwgcixcclxuICAgIHggPSB0aGlzLFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKCF4ZCkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICBuMSA9IGQwID0gbmV3IEN0b3IoMSk7XHJcbiAgZDEgPSBuMCA9IG5ldyBDdG9yKDApO1xyXG5cclxuICBkID0gbmV3IEN0b3IoZDEpO1xyXG4gIGUgPSBkLmUgPSBnZXRQcmVjaXNpb24oeGQpIC0geC5lIC0gMTtcclxuICBrID0gZSAlIExPR19CQVNFO1xyXG4gIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XHJcblxyXG4gIGlmIChtYXhEID09IG51bGwpIHtcclxuXHJcbiAgICAvLyBkIGlzIDEwKiplLCB0aGUgbWluaW11bSBtYXgtZGVub21pbmF0b3IgbmVlZGVkLlxyXG4gICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBuID0gbmV3IEN0b3IobWF4RCk7XHJcbiAgICBpZiAoIW4uaXNJbnQoKSB8fCBuLmx0KG4xKSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XHJcbiAgICBtYXhEID0gbi5ndChkKSA/IChlID4gMCA/IGQgOiBuMSkgOiBuO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICBuID0gbmV3IEN0b3IoZGlnaXRzVG9TdHJpbmcoeGQpKTtcclxuICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcclxuXHJcbiAgZm9yICg7OykgIHtcclxuICAgIHEgPSBkaXZpZGUobiwgZCwgMCwgMSwgMSk7XHJcbiAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgaWYgKGQyLmNtcChtYXhEKSA9PSAxKSBicmVhaztcclxuICAgIGQwID0gZDE7XHJcbiAgICBkMSA9IGQyO1xyXG4gICAgZDIgPSBuMTtcclxuICAgIG4xID0gbjAucGx1cyhxLnRpbWVzKGQyKSk7XHJcbiAgICBuMCA9IGQyO1xyXG4gICAgZDIgPSBkO1xyXG4gICAgZCA9IG4ubWludXMocS50aW1lcyhkMikpO1xyXG4gICAgbiA9IGQyO1xyXG4gIH1cclxuXHJcbiAgZDIgPSBkaXZpZGUobWF4RC5taW51cyhkMCksIGQxLCAwLCAxLCAxKTtcclxuICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICBkMCA9IGQwLnBsdXMoZDIudGltZXMoZDEpKTtcclxuICBuMC5zID0gbjEucyA9IHgucztcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMT9cclxuICByID0gZGl2aWRlKG4xLCBkMSwgZSwgMSkubWludXMoeCkuYWJzKCkuY21wKGRpdmlkZShuMCwgZDAsIGUsIDEpLm1pbnVzKHgpLmFicygpKSA8IDFcclxuICAgICAgPyBbbjEsIGQxXSA6IFtuMCwgZDBdO1xyXG5cclxuICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGJhc2UgMTYsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICpcclxuICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAxIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAqXHJcbiAqL1xyXG5QLnRvSGV4YWRlY2ltYWwgPSBQLnRvSGV4ID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYHlgIGluIHRoZSBkaXJlY3Rpb24gb2Ygcm91bmRpbmdcclxuICogbW9kZSBgcm1gLCBvciBgRGVjaW1hbC5yb3VuZGluZ2AgaWYgYHJtYCBpcyBvbWl0dGVkLCB0byB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgc2lnbiBhcyB0aGlzIERlY2ltYWwsIHVubGVzcyBlaXRoZXIgdGhpcyBEZWNpbWFsXHJcbiAqIG9yIGB5YCBpcyBOYU4sIGluIHdoaWNoIGNhc2UgdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFsc28gYmUgTmFOLlxyXG4gKlxyXG4gKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAuXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSBtYWduaXR1ZGUgdG8gcm91bmQgdG8gYSBtdWx0aXBsZSBvZi5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKiAndG9OZWFyZXN0KCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gKlxyXG4gKi9cclxuUC50b05lYXJlc3QgPSBmdW5jdGlvbiAoeSwgcm0pIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICBpZiAoeSA9PSBudWxsKSB7XHJcblxyXG4gICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geC5cclxuICAgIGlmICgheC5kKSByZXR1cm4geDtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgfSBlbHNlIHtcclxuICAgIHkgPSBuZXcgQ3Rvcih5KTtcclxuICAgIGlmIChybSA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHggaXMgbm90IGZpbml0ZSwgcmV0dXJuIHggaWYgeSBpcyBub3QgTmFOLCBlbHNlIE5hTi5cclxuICAgIGlmICgheC5kKSByZXR1cm4geS5zID8geCA6IHk7XHJcblxyXG4gICAgLy8gSWYgeSBpcyBub3QgZmluaXRlLCByZXR1cm4gSW5maW5pdHkgd2l0aCB0aGUgc2lnbiBvZiB4IGlmIHkgaXMgSW5maW5pdHksIGVsc2UgTmFOLlxyXG4gICAgaWYgKCF5LmQpIHtcclxuICAgICAgaWYgKHkucykgeS5zID0geC5zO1xyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8vIElmIHkgaXMgbm90IHplcm8sIGNhbGN1bGF0ZSB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB5IHRvIHguXHJcbiAgaWYgKHkuZFswXSkge1xyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIHggPSBkaXZpZGUoeCwgeSwgMCwgcm0sIDEpLnRpbWVzKHkpO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgZmluYWxpc2UoeCk7XHJcblxyXG4gIC8vIElmIHkgaXMgemVybywgcmV0dXJuIHplcm8gd2l0aCB0aGUgc2lnbiBvZiB4LlxyXG4gIH0gZWxzZSB7XHJcbiAgICB5LnMgPSB4LnM7XHJcbiAgICB4ID0geTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4O1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGNvbnZlcnRlZCB0byBhIG51bWJlciBwcmltaXRpdmUuXHJcbiAqIFplcm8ga2VlcHMgaXRzIHNpZ24uXHJcbiAqXHJcbiAqL1xyXG5QLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gIHJldHVybiArdGhpcztcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSA4LCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b09jdGFsID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCA4LCBzZCwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcmFpc2VkIHRvIHRoZSBwb3dlciBgeWAsIHJvdW5kZWRcclxuICogdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogRUNNQVNjcmlwdCBjb21wbGlhbnQuXHJcbiAqXHJcbiAqICAgcG93KHgsIE5hTikgICAgICAgICAgICAgICAgICAgICAgICAgICA9IE5hTlxyXG4gKiAgIHBvdyh4LCDCsTApICAgICAgICAgICAgICAgICAgICAgICAgICAgID0gMVxyXG5cclxuICogICBwb3coTmFOLCBub24temVybykgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KGFicyh4KSA+IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdyhhYnMoeCkgPiAxLCAtSW5maW5pdHkpICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdyhhYnMoeCkgPT0gMSwgwrFJbmZpbml0eSkgICAgICAgICAgID0gTmFOXHJcbiAqICAgcG93KGFicyh4KSA8IDEsICtJbmZpbml0eSkgICAgICAgICAgICA9ICswXHJcbiAqICAgcG93KGFicyh4KSA8IDEsIC1JbmZpbml0eSkgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygrSW5maW5pdHksIHkgPiAwKSAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICogICBwb3coK0luZmluaXR5LCB5IDwgMCkgICAgICAgICAgICAgICAgID0gKzBcclxuICogICBwb3coLUluZmluaXR5LCBvZGQgaW50ZWdlciA+IDApICAgICAgID0gLUluZmluaXR5XHJcbiAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdygtSW5maW5pdHksIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgPSAtMFxyXG4gKiAgIHBvdygtSW5maW5pdHksIGV2ZW4gaW50ZWdlciA8IDApICAgICAgPSArMFxyXG4gKiAgIHBvdygrMCwgeSA+IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArMFxyXG4gKiAgIHBvdygrMCwgeSA8IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICogICBwb3coLTAsIG9kZCBpbnRlZ2VyID4gMCkgICAgICAgICAgICAgID0gLTBcclxuICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA+IDApICAgICAgICAgICAgID0gKzBcclxuICogICBwb3coLTAsIG9kZCBpbnRlZ2VyIDwgMCkgICAgICAgICAgICAgID0gLUluZmluaXR5XHJcbiAqICAgcG93KC0wLCBldmVuIGludGVnZXIgPCAwKSAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gKiAgIHBvdyhmaW5pdGUgeCA8IDAsIGZpbml0ZSBub24taW50ZWdlcikgPSBOYU5cclxuICpcclxuICogRm9yIG5vbi1pbnRlZ2VyIG9yIHZlcnkgbGFyZ2UgZXhwb25lbnRzIHBvdyh4LCB5KSBpcyBjYWxjdWxhdGVkIHVzaW5nXHJcbiAqXHJcbiAqICAgeF55ID0gZXhwKHkqbG4oeCkpXHJcbiAqXHJcbiAqIEFzc3VtaW5nIHRoZSBmaXJzdCAxNSByb3VuZGluZyBkaWdpdHMgYXJlIGVhY2ggZXF1YWxseSBsaWtlbHkgdG8gYmUgYW55IGRpZ2l0IDAtOSwgdGhlXHJcbiAqIHByb2JhYmlsaXR5IG9mIGFuIGluY29ycmVjdGx5IHJvdW5kZWQgcmVzdWx0XHJcbiAqIFAoWzQ5XTl7MTR9IHwgWzUwXTB7MTR9KSA9IDIgKiAwLjIgKiAxMF4tMTQgPSA0ZS0xNSA9IDEvMi41ZSsxNFxyXG4gKiBpLmUuIDEgaW4gMjUwLDAwMCwwMDAsMDAwLDAwMFxyXG4gKlxyXG4gKiBJZiBhIHJlc3VsdCBpcyBpbmNvcnJlY3RseSByb3VuZGVkIHRoZSBtYXhpbXVtIGVycm9yIHdpbGwgYmUgMSB1bHAgKHVuaXQgaW4gbGFzdCBwbGFjZSkuXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSBwb3dlciB0byB3aGljaCB0byByYWlzZSB0aGlzIERlY2ltYWwuXHJcbiAqXHJcbiAqL1xyXG5QLnRvUG93ZXIgPSBQLnBvdyA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgdmFyIGUsIGssIHByLCByLCBybSwgcyxcclxuICAgIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICB5biA9ICsoeSA9IG5ldyBDdG9yKHkpKTtcclxuXHJcbiAgLy8gRWl0aGVyIMKxSW5maW5pdHksIE5hTiBvciDCsTA/XHJcbiAgaWYgKCF4LmQgfHwgIXkuZCB8fCAheC5kWzBdIHx8ICF5LmRbMF0pIHJldHVybiBuZXcgQ3RvcihtYXRocG93KCt4LCB5bikpO1xyXG5cclxuICB4ID0gbmV3IEN0b3IoeCk7XHJcblxyXG4gIGlmICh4LmVxKDEpKSByZXR1cm4geDtcclxuXHJcbiAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gIGlmICh5LmVxKDEpKSByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcclxuXHJcbiAgLy8geSBleHBvbmVudFxyXG4gIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG5cclxuICAvLyBJZiB5IGlzIGEgc21hbGwgaW50ZWdlciB1c2UgdGhlICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycgYWxnb3JpdGhtLlxyXG4gIGlmIChlID49IHkuZC5sZW5ndGggLSAxICYmIChrID0geW4gPCAwID8gLXluIDogeW4pIDw9IE1BWF9TQUZFX0lOVEVHRVIpIHtcclxuICAgIHIgPSBpbnRQb3coQ3RvciwgeCwgaywgcHIpO1xyXG4gICAgcmV0dXJuIHkucyA8IDAgPyBuZXcgQ3RvcigxKS5kaXYocikgOiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gIH1cclxuXHJcbiAgcyA9IHgucztcclxuXHJcbiAgLy8gaWYgeCBpcyBuZWdhdGl2ZVxyXG4gIGlmIChzIDwgMCkge1xyXG5cclxuICAgIC8vIGlmIHkgaXMgbm90IGFuIGludGVnZXJcclxuICAgIGlmIChlIDwgeS5kLmxlbmd0aCAtIDEpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIFJlc3VsdCBpcyBwb3NpdGl2ZSBpZiB4IGlzIG5lZ2F0aXZlIGFuZCB0aGUgbGFzdCBkaWdpdCBvZiBpbnRlZ2VyIHkgaXMgZXZlbi5cclxuICAgIGlmICgoeS5kW2VdICYgMSkgPT0gMCkgcyA9IDE7XHJcblxyXG4gICAgLy8gaWYgeC5lcSgtMSlcclxuICAgIGlmICh4LmUgPT0gMCAmJiB4LmRbMF0gPT0gMSAmJiB4LmQubGVuZ3RoID09IDEpIHtcclxuICAgICAgeC5zID0gcztcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBFc3RpbWF0ZSByZXN1bHQgZXhwb25lbnQuXHJcbiAgLy8geF55ID0gMTBeZSwgIHdoZXJlIGUgPSB5ICogbG9nMTAoeClcclxuICAvLyBsb2cxMCh4KSA9IGxvZzEwKHhfc2lnbmlmaWNhbmQpICsgeF9leHBvbmVudFxyXG4gIC8vIGxvZzEwKHhfc2lnbmlmaWNhbmQpID0gbG4oeF9zaWduaWZpY2FuZCkgLyBsbigxMClcclxuICBrID0gbWF0aHBvdygreCwgeW4pO1xyXG4gIGUgPSBrID09IDAgfHwgIWlzRmluaXRlKGspXHJcbiAgICA/IG1hdGhmbG9vcih5biAqIChNYXRoLmxvZygnMC4nICsgZGlnaXRzVG9TdHJpbmcoeC5kKSkgLyBNYXRoLkxOMTAgKyB4LmUgKyAxKSlcclxuICAgIDogbmV3IEN0b3IoayArICcnKS5lO1xyXG5cclxuICAvLyBFeHBvbmVudCBlc3RpbWF0ZSBtYXkgYmUgaW5jb3JyZWN0IGUuZy4geDogMC45OTk5OTk5OTk5OTk5OTk5OTksIHk6IDIuMjksIGU6IDAsIHIuZTogLTEuXHJcblxyXG4gIC8vIE92ZXJmbG93L3VuZGVyZmxvdz9cclxuICBpZiAoZSA+IEN0b3IubWF4RSArIDEgfHwgZSA8IEN0b3IubWluRSAtIDEpIHJldHVybiBuZXcgQ3RvcihlID4gMCA/IHMgLyAwIDogMCk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgQ3Rvci5yb3VuZGluZyA9IHgucyA9IDE7XHJcblxyXG4gIC8vIEVzdGltYXRlIHRoZSBleHRyYSBndWFyZCBkaWdpdHMgbmVlZGVkIHRvIGVuc3VyZSBmaXZlIGNvcnJlY3Qgcm91bmRpbmcgZGlnaXRzIGZyb21cclxuICAvLyBuYXR1cmFsTG9nYXJpdGhtKHgpLiBFeGFtcGxlIG9mIGZhaWx1cmUgd2l0aG91dCB0aGVzZSBleHRyYSBkaWdpdHMgKHByZWNpc2lvbjogMTApOlxyXG4gIC8vIG5ldyBEZWNpbWFsKDIuMzI0NTYpLnBvdygnMjA4Nzk4NzQzNjUzNDU2Ni40NjQxMScpXHJcbiAgLy8gc2hvdWxkIGJlIDEuMTYyMzc3ODIzZSs3NjQ5MTQ5MDUxNzM4MTUsIGJ1dCBpcyAxLjE2MjM1NTgyM2UrNzY0OTE0OTA1MTczODE1XHJcbiAgayA9IE1hdGgubWluKDEyLCAoZSArICcnKS5sZW5ndGgpO1xyXG5cclxuICAvLyByID0geF55ID0gZXhwKHkqbG4oeCkpXHJcbiAgciA9IG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgcHIgKyBrKSksIHByKTtcclxuXHJcbiAgLy8gciBtYXkgYmUgSW5maW5pdHksIGUuZy4gKDAuOTk5OTk5OTk5OTk5OTk5OSkucG93KC0xZSs0MClcclxuICBpZiAoci5kKSB7XHJcblxyXG4gICAgLy8gVHJ1bmNhdGUgdG8gdGhlIHJlcXVpcmVkIHByZWNpc2lvbiBwbHVzIGZpdmUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgciA9IGZpbmFsaXNlKHIsIHByICsgNSwgMSk7XHJcblxyXG4gICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTkgb3IgWzUwXTAwMDAgaW5jcmVhc2UgdGhlIHByZWNpc2lvbiBieSAxMCBhbmQgcmVjYWxjdWxhdGVcclxuICAgIC8vIHRoZSByZXN1bHQuXHJcbiAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIHByLCBybSkpIHtcclxuICAgICAgZSA9IHByICsgMTA7XHJcblxyXG4gICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgaW5jcmVhc2VkIHByZWNpc2lvbiBwbHVzIGZpdmUgcm91bmRpbmcgZGlnaXRzLlxyXG4gICAgICByID0gZmluYWxpc2UobmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBlICsgaykpLCBlKSwgZSArIDUsIDEpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCAodGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0IG1heSBiZSA0IG9yIDkpLlxyXG4gICAgICBpZiAoK2RpZ2l0c1RvU3RyaW5nKHIuZCkuc2xpY2UocHIgKyAxLCBwciArIDE1KSArIDEgPT0gMWUxNCkge1xyXG4gICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByLnMgPSBzO1xyXG4gIGV4dGVybmFsID0gdHJ1ZTtcclxuICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIGBzZGAgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnRcclxuICogdGhlIGludGVnZXIgcGFydCBvZiB0aGUgdmFsdWUgaW4gbm9ybWFsIG5vdGF0aW9uLlxyXG4gKlxyXG4gKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuUC50b1ByZWNpc2lvbiA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICB2YXIgc3RyLFxyXG4gICAgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKHNkID09PSB2b2lkIDApIHtcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcblxyXG4gICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBDdG9yLnRvRXhwTmVnLCBzZCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIG1heGltdW0gb2YgYHNkYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLCBvciB0byBgcHJlY2lzaW9uYCBhbmQgYHJvdW5kaW5nYCByZXNwZWN0aXZlbHkgaWZcclxuICogb21pdHRlZC5cclxuICpcclxuICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICpcclxuICogJ3RvU0QoKSBkaWdpdHMgb3V0IG9mIHJhbmdlOiB7c2R9J1xyXG4gKiAndG9TRCgpIGRpZ2l0cyBub3QgYW4gaW50ZWdlcjoge3NkfSdcclxuICogJ3RvU0QoKSByb3VuZGluZyBtb2RlIG5vdCBhbiBpbnRlZ2VyOiB7cm19J1xyXG4gKiAndG9TRCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gKlxyXG4gKi9cclxuUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gIHZhciB4ID0gdGhpcyxcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICBpZiAoc2QgPT09IHZvaWQgMCkge1xyXG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9IGVsc2Uge1xyXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoeCksIHNkLCBybSk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gKlxyXG4gKiBSZXR1cm4gZXhwb25lbnRpYWwgbm90YXRpb24gaWYgdGhpcyBEZWNpbWFsIGhhcyBhIHBvc2l0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhblxyXG4gKiBgdG9FeHBQb3NgLCBvciBhIG5lZ2F0aXZlIGV4cG9uZW50IGVxdWFsIHRvIG9yIGxlc3MgdGhhbiBgdG9FeHBOZWdgLlxyXG4gKlxyXG4gKi9cclxuUC50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcclxuICB2YXIgeCA9IHRoaXMsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuXHJcbiAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRydW5jYXRlZCB0byBhIHdob2xlIG51bWJlci5cclxuICpcclxuICovXHJcblAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICByZXR1cm4gZmluYWxpc2UobmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyksIHRoaXMuZSArIDEsIDEpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICogVW5saWtlIGB0b1N0cmluZ2AsIG5lZ2F0aXZlIHplcm8gd2lsbCBpbmNsdWRlIHRoZSBtaW51cyBzaWduLlxyXG4gKlxyXG4gKi9cclxuUC52YWx1ZU9mID0gUC50b0pTT04gPSBmdW5jdGlvbiAoKSB7XHJcbiAgdmFyIHggPSB0aGlzLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcblxyXG4gIHJldHVybiB4LmlzTmVnKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn07XHJcblxyXG5cclxuLy8gSGVscGVyIGZ1bmN0aW9ucyBmb3IgRGVjaW1hbC5wcm90b3R5cGUgKFApIGFuZC9vciBEZWNpbWFsIG1ldGhvZHMsIGFuZCB0aGVpciBjYWxsZXJzLlxyXG5cclxuXHJcbi8qXHJcbiAqICBkaWdpdHNUb1N0cmluZyAgICAgICAgICAgUC5jdWJlUm9vdCwgUC5sb2dhcml0aG0sIFAuc3F1YXJlUm9vdCwgUC50b0ZyYWN0aW9uLCBQLnRvUG93ZXIsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXRlVG9TdHJpbmcsIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobVxyXG4gKiAgY2hlY2tJbnQzMiAgICAgICAgICAgICAgIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b05lYXJlc3QsXHJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b1ByZWNpc2lvbiwgUC50b1NpZ25pZmljYW50RGlnaXRzLCB0b1N0cmluZ0JpbmFyeSwgcmFuZG9tXHJcbiAqICBjaGVja1JvdW5kaW5nRGlnaXRzICAgICAgUC5sb2dhcml0aG0sIFAudG9Qb3dlciwgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtXHJcbiAqICBjb252ZXJ0QmFzZSAgICAgICAgICAgICAgdG9TdHJpbmdCaW5hcnksIHBhcnNlT3RoZXJcclxuICogIGNvcyAgICAgICAgICAgICAgICAgICAgICBQLmNvc1xyXG4gKiAgZGl2aWRlICAgICAgICAgICAgICAgICAgIFAuYXRhbmgsIFAuY3ViZVJvb3QsIFAuZGl2aWRlZEJ5LCBQLmRpdmlkZWRUb0ludGVnZXJCeSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgUC5tb2R1bG8sIFAuc3F1YXJlUm9vdCwgUC50YW4sIFAudGFuaCwgUC50b0ZyYWN0aW9uLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCB0b1N0cmluZ0JpbmFyeSwgbmF0dXJhbEV4cG9uZW50aWFsLCBuYXR1cmFsTG9nYXJpdGhtLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRheWxvclNlcmllcywgYXRhbjIsIHBhcnNlT3RoZXJcclxuICogIGZpbmFsaXNlICAgICAgICAgICAgICAgICBQLmFic29sdXRlVmFsdWUsIFAuYXRhbiwgUC5hdGFuaCwgUC5jZWlsLCBQLmNvcywgUC5jb3NoLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAuY3ViZVJvb3QsIFAuZGl2aWRlZFRvSW50ZWdlckJ5LCBQLmZsb29yLCBQLmxvZ2FyaXRobSwgUC5taW51cyxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLm1vZHVsbywgUC5uZWdhdGVkLCBQLnBsdXMsIFAucm91bmQsIFAuc2luLCBQLnNpbmgsIFAuc3F1YXJlUm9vdCxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRhbiwgUC50aW1lcywgUC50b0RlY2ltYWxQbGFjZXMsIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9OZWFyZXN0LCBQLnRvUG93ZXIsIFAudG9QcmVjaXNpb24sIFAudG9TaWduaWZpY2FudERpZ2l0cyxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRydW5jYXRlZCwgZGl2aWRlLCBnZXRMbjEwLCBnZXRQaSwgbmF0dXJhbEV4cG9uZW50aWFsLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxMb2dhcml0aG0sIGNlaWwsIGZsb29yLCByb3VuZCwgdHJ1bmNcclxuICogIGZpbml0ZVRvU3RyaW5nICAgICAgICAgICBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b1ByZWNpc2lvbiwgUC50b1N0cmluZywgUC52YWx1ZU9mLFxyXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvU3RyaW5nQmluYXJ5XHJcbiAqICBnZXRCYXNlMTBFeHBvbmVudCAgICAgICAgUC5taW51cywgUC5wbHVzLCBQLnRpbWVzLCBwYXJzZU90aGVyXHJcbiAqICBnZXRMbjEwICAgICAgICAgICAgICAgICAgUC5sb2dhcml0aG0sIG5hdHVyYWxMb2dhcml0aG1cclxuICogIGdldFBpICAgICAgICAgICAgICAgICAgICBQLmFjb3MsIFAuYXNpbiwgUC5hdGFuLCB0b0xlc3NUaGFuSGFsZlBpLCBhdGFuMlxyXG4gKiAgZ2V0UHJlY2lzaW9uICAgICAgICAgICAgIFAucHJlY2lzaW9uLCBQLnRvRnJhY3Rpb25cclxuICogIGdldFplcm9TdHJpbmcgICAgICAgICAgICBkaWdpdHNUb1N0cmluZywgZmluaXRlVG9TdHJpbmdcclxuICogIGludFBvdyAgICAgICAgICAgICAgICAgICBQLnRvUG93ZXIsIHBhcnNlT3RoZXJcclxuICogIGlzT2RkICAgICAgICAgICAgICAgICAgICB0b0xlc3NUaGFuSGFsZlBpXHJcbiAqICBtYXhPck1pbiAgICAgICAgICAgICAgICAgbWF4LCBtaW5cclxuICogIG5hdHVyYWxFeHBvbmVudGlhbCAgICAgICBQLm5hdHVyYWxFeHBvbmVudGlhbCwgUC50b1Bvd2VyXHJcbiAqICBuYXR1cmFsTG9nYXJpdGhtICAgICAgICAgUC5hY29zaCwgUC5hc2luaCwgUC5hdGFuaCwgUC5sb2dhcml0aG0sIFAubmF0dXJhbExvZ2FyaXRobSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbFxyXG4gKiAgbm9uRmluaXRlVG9TdHJpbmcgICAgICAgIGZpbml0ZVRvU3RyaW5nLCB0b1N0cmluZ0JpbmFyeVxyXG4gKiAgcGFyc2VEZWNpbWFsICAgICAgICAgICAgIERlY2ltYWxcclxuICogIHBhcnNlT3RoZXIgICAgICAgICAgICAgICBEZWNpbWFsXHJcbiAqICBzaW4gICAgICAgICAgICAgICAgICAgICAgUC5zaW5cclxuICogIHRheWxvclNlcmllcyAgICAgICAgICAgICBQLmNvc2gsIFAuc2luaCwgY29zLCBzaW5cclxuICogIHRvTGVzc1RoYW5IYWxmUGkgICAgICAgICBQLmNvcywgUC5zaW5cclxuICogIHRvU3RyaW5nQmluYXJ5ICAgICAgICAgICBQLnRvQmluYXJ5LCBQLnRvSGV4YWRlY2ltYWwsIFAudG9PY3RhbFxyXG4gKiAgdHJ1bmNhdGUgICAgICAgICAgICAgICAgIGludFBvd1xyXG4gKlxyXG4gKiAgVGhyb3dzOiAgICAgICAgICAgICAgICAgIFAubG9nYXJpdGhtLCBQLnByZWNpc2lvbiwgUC50b0ZyYWN0aW9uLCBjaGVja0ludDMyLCBnZXRMbjEwLCBnZXRQaSxcclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjb25maWcsIHBhcnNlT3RoZXIsIHJhbmRvbSwgRGVjaW1hbFxyXG4gKi9cclxuXHJcblxyXG5mdW5jdGlvbiBkaWdpdHNUb1N0cmluZyhkKSB7XHJcbiAgdmFyIGksIGssIHdzLFxyXG4gICAgaW5kZXhPZkxhc3RXb3JkID0gZC5sZW5ndGggLSAxLFxyXG4gICAgc3RyID0gJycsXHJcbiAgICB3ID0gZFswXTtcclxuXHJcbiAgaWYgKGluZGV4T2ZMYXN0V29yZCA+IDApIHtcclxuICAgIHN0ciArPSB3O1xyXG4gICAgZm9yIChpID0gMTsgaSA8IGluZGV4T2ZMYXN0V29yZDsgaSsrKSB7XHJcbiAgICAgIHdzID0gZFtpXSArICcnO1xyXG4gICAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XHJcbiAgICAgIGlmIChrKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgc3RyICs9IHdzO1xyXG4gICAgfVxyXG5cclxuICAgIHcgPSBkW2ldO1xyXG4gICAgd3MgPSB3ICsgJyc7XHJcbiAgICBrID0gTE9HX0JBU0UgLSB3cy5sZW5ndGg7XHJcbiAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgfSBlbHNlIGlmICh3ID09PSAwKSB7XHJcbiAgICByZXR1cm4gJzAnO1xyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zIG9mIGxhc3Qgdy5cclxuICBmb3IgKDsgdyAlIDEwID09PSAwOykgdyAvPSAxMDtcclxuXHJcbiAgcmV0dXJuIHN0ciArIHc7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBjaGVja0ludDMyKGksIG1pbiwgbWF4KSB7XHJcbiAgaWYgKGkgIT09IH5+aSB8fCBpIDwgbWluIHx8IGkgPiBtYXgpIHtcclxuICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIGkpO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIENoZWNrIDUgcm91bmRpbmcgZGlnaXRzIGlmIGByZXBlYXRpbmdgIGlzIG51bGwsIDQgb3RoZXJ3aXNlLlxyXG4gKiBgcmVwZWF0aW5nID09IG51bGxgIGlmIGNhbGxlciBpcyBgbG9nYCBvciBgcG93YCxcclxuICogYHJlcGVhdGluZyAhPSBudWxsYCBpZiBjYWxsZXIgaXMgYG5hdHVyYWxMb2dhcml0aG1gIG9yIGBuYXR1cmFsRXhwb25lbnRpYWxgLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tSb3VuZGluZ0RpZ2l0cyhkLCBpLCBybSwgcmVwZWF0aW5nKSB7XHJcbiAgdmFyIGRpLCBrLCByLCByZDtcclxuXHJcbiAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGFycmF5IGQuXHJcbiAgZm9yIChrID0gZFswXTsgayA+PSAxMDsgayAvPSAxMCkgLS1pO1xyXG5cclxuICAvLyBJcyB0aGUgcm91bmRpbmcgZGlnaXQgaW4gdGhlIGZpcnN0IHdvcmQgb2YgZD9cclxuICBpZiAoLS1pIDwgMCkge1xyXG4gICAgaSArPSBMT0dfQkFTRTtcclxuICAgIGRpID0gMDtcclxuICB9IGVsc2Uge1xyXG4gICAgZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgfVxyXG5cclxuICAvLyBpIGlzIHRoZSBpbmRleCAoMCAtIDYpIG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAvLyBFLmcuIGlmIHdpdGhpbiB0aGUgd29yZCAzNDg3NTYzIHRoZSBmaXJzdCByb3VuZGluZyBkaWdpdCBpcyA1LFxyXG4gIC8vIHRoZW4gaSA9IDQsIGsgPSAxMDAwLCByZCA9IDM0ODc1NjMgJSAxMDAwID0gNTYzXHJcbiAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XHJcbiAgcmQgPSBkW2RpXSAlIGsgfCAwO1xyXG5cclxuICBpZiAocmVwZWF0aW5nID09IG51bGwpIHtcclxuICAgIGlmIChpIDwgMykge1xyXG4gICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMTAwIHwgMDtcclxuICAgICAgZWxzZSBpZiAoaSA9PSAxKSByZCA9IHJkIC8gMTAgfCAwO1xyXG4gICAgICByID0gcm0gPCA0ICYmIHJkID09IDk5OTk5IHx8IHJtID4gMyAmJiByZCA9PSA0OTk5OSB8fCByZCA9PSA1MDAwMCB8fCByZCA9PSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgciA9IChybSA8IDQgJiYgcmQgKyAxID09IGsgfHwgcm0gPiAzICYmIHJkICsgMSA9PSBrIC8gMikgJiZcclxuICAgICAgICAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAyKSAtIDEgfHxcclxuICAgICAgICAgIChyZCA9PSBrIC8gMiB8fCByZCA9PSAwKSAmJiAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IDA7XHJcbiAgICB9XHJcbiAgfSBlbHNlIHtcclxuICAgIGlmIChpIDwgNCkge1xyXG4gICAgICBpZiAoaSA9PSAwKSByZCA9IHJkIC8gMTAwMCB8IDA7XHJcbiAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgIGVsc2UgaWYgKGkgPT0gMikgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgciA9IChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCA9PSA5OTk5IHx8ICFyZXBlYXRpbmcgJiYgcm0gPiAzICYmIHJkID09IDQ5OTk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gKChyZXBlYXRpbmcgfHwgcm0gPCA0KSAmJiByZCArIDEgPT0gayB8fFxyXG4gICAgICAoIXJlcGVhdGluZyAmJiBybSA+IDMpICYmIHJkICsgMSA9PSBrIC8gMikgJiZcclxuICAgICAgICAoZFtkaSArIDFdIC8gayAvIDEwMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMykgLSAxO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG4vLyBDb252ZXJ0IHN0cmluZyBvZiBgYmFzZUluYCB0byBhbiBhcnJheSBvZiBudW1iZXJzIG9mIGBiYXNlT3V0YC5cclxuLy8gRWcuIGNvbnZlcnRCYXNlKCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbi8vIEVnLiBjb252ZXJ0QmFzZSgnZmYnLCAxNiwgMTApIHJldHVybnMgWzIsIDUsIDVdLlxyXG5mdW5jdGlvbiBjb252ZXJ0QmFzZShzdHIsIGJhc2VJbiwgYmFzZU91dCkge1xyXG4gIHZhciBqLFxyXG4gICAgYXJyID0gWzBdLFxyXG4gICAgYXJyTCxcclxuICAgIGkgPSAwLFxyXG4gICAgc3RyTCA9IHN0ci5sZW5ndGg7XHJcblxyXG4gIGZvciAoOyBpIDwgc3RyTDspIHtcclxuICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTspIGFyclthcnJMXSAqPSBiYXNlSW47XHJcbiAgICBhcnJbMF0gKz0gTlVNRVJBTFMuaW5kZXhPZihzdHIuY2hhckF0KGkrKykpO1xyXG4gICAgZm9yIChqID0gMDsgaiA8IGFyci5sZW5ndGg7IGorKykge1xyXG4gICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICBpZiAoYXJyW2ogKyAxXSA9PT0gdm9pZCAwKSBhcnJbaiArIDFdID0gMDtcclxuICAgICAgICBhcnJbaiArIDFdICs9IGFycltqXSAvIGJhc2VPdXQgfCAwO1xyXG4gICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJyLnJldmVyc2UoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIGNvcyh4KSA9IDEgLSB4XjIvMiEgKyB4XjQvNCEgLSAuLi5cclxuICogfHh8IDwgcGkvMlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY29zaW5lKEN0b3IsIHgpIHtcclxuICB2YXIgaywgbGVuLCB5O1xyXG5cclxuICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIHg7XHJcblxyXG4gIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogY29zKDR4KSA9IDgqKGNvc140KHgpIC0gY29zXjIoeCkpICsgMVxyXG4gIC8vIGkuZS4gY29zKHgpID0gOCooY29zXjQoeC80KSAtIGNvc14yKHgvNCkpICsgMVxyXG5cclxuICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgbGVuID0geC5kLmxlbmd0aDtcclxuICBpZiAobGVuIDwgMzIpIHtcclxuICAgIGsgPSBNYXRoLmNlaWwobGVuIC8gMyk7XHJcbiAgICB5ID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBrID0gMTY7XHJcbiAgICB5ID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gKz0gaztcclxuXHJcbiAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAxLCB4LnRpbWVzKHkpLCBuZXcgQ3RvcigxKSk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgZm9yICh2YXIgaSA9IGs7IGktLTspIHtcclxuICAgIHZhciBjb3MyeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0gY29zMngudGltZXMoY29zMngpLm1pbnVzKGNvczJ4KS50aW1lcyg4KS5wbHVzKDEpO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gLT0gaztcclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS5cclxuICovXHJcbnZhciBkaXZpZGUgPSAoZnVuY3Rpb24gKCkge1xyXG5cclxuICAvLyBBc3N1bWVzIG5vbi16ZXJvIHggYW5kIGssIGFuZCBoZW5jZSBub24temVybyByZXN1bHQuXHJcbiAgZnVuY3Rpb24gbXVsdGlwbHlJbnRlZ2VyKHgsIGssIGJhc2UpIHtcclxuICAgIHZhciB0ZW1wLFxyXG4gICAgICBjYXJyeSA9IDAsXHJcbiAgICAgIGkgPSB4Lmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKHggPSB4LnNsaWNlKCk7IGktLTspIHtcclxuICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XHJcbiAgICAgIHhbaV0gPSB0ZW1wICUgYmFzZSB8IDA7XHJcbiAgICAgIGNhcnJ5ID0gdGVtcCAvIGJhc2UgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjYXJyeSkgeC51bnNoaWZ0KGNhcnJ5KTtcclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYiwgYUwsIGJMKSB7XHJcbiAgICB2YXIgaSwgcjtcclxuXHJcbiAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgciA9IGFMID4gYkwgPyAxIDogLTE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcclxuICAgICAgICBpZiAoYVtpXSAhPSBiW2ldKSB7XHJcbiAgICAgICAgICByID0gYVtpXSA+IGJbaV0gPyAxIDogLTE7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICB2YXIgaSA9IDA7XHJcblxyXG4gICAgLy8gU3VidHJhY3QgYiBmcm9tIGEuXHJcbiAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgYVthTF0gLT0gaTtcclxuICAgICAgaSA9IGFbYUxdIDwgYlthTF0gPyAxIDogMDtcclxuICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOykgYS5zaGlmdCgpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGZ1bmN0aW9uICh4LCB5LCBwciwgcm0sIGRwLCBiYXNlKSB7XHJcbiAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLFxyXG4gICAgICB5TCwgeXosXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBzaWduID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgeGQgPSB4LmQsXHJcbiAgICAgIHlkID0geS5kO1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgTmFOLCBvciBib3RoIEluZmluaXR5IG9yIDAuXHJcbiAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4ZCA/IHlkICYmIHhkWzBdID09IHlkWzBdIDogIXlkKSA/IE5hTiA6XHJcblxyXG4gICAgICAgIC8vIFJldHVybiDCsTAgaWYgeCBpcyAwIG9yIHkgaXMgwrFJbmZpbml0eSwgb3IgcmV0dXJuIMKxSW5maW5pdHkgYXMgeSBpcyAwLlxyXG4gICAgICAgIHhkICYmIHhkWzBdID09IDAgfHwgIXlkID8gc2lnbiAqIDAgOiBzaWduIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGJhc2UpIHtcclxuICAgICAgbG9nQmFzZSA9IDE7XHJcbiAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBiYXNlID0gQkFTRTtcclxuICAgICAgbG9nQmFzZSA9IExPR19CQVNFO1xyXG4gICAgICBlID0gbWF0aGZsb29yKHguZSAvIGxvZ0Jhc2UpIC0gbWF0aGZsb29yKHkuZSAvIGxvZ0Jhc2UpO1xyXG4gICAgfVxyXG5cclxuICAgIHlMID0geWQubGVuZ3RoO1xyXG4gICAgeEwgPSB4ZC5sZW5ndGg7XHJcbiAgICBxID0gbmV3IEN0b3Ioc2lnbik7XHJcbiAgICBxZCA9IHEuZCA9IFtdO1xyXG5cclxuICAgIC8vIFJlc3VsdCBleHBvbmVudCBtYXkgYmUgb25lIGxlc3MgdGhhbiBlLlxyXG4gICAgLy8gVGhlIGRpZ2l0IGFycmF5IG9mIGEgRGVjaW1hbCBmcm9tIHRvU3RyaW5nQmluYXJ5IG1heSBoYXZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgIGlmICh5ZFtpXSA+ICh4ZFtpXSB8fCAwKSkgZS0tO1xyXG5cclxuICAgIGlmIChwciA9PSBudWxsKSB7XHJcbiAgICAgIHNkID0gcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIGlmIChkcCkge1xyXG4gICAgICBzZCA9IHByICsgKHguZSAtIHkuZSkgKyAxO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2QgPSBwcjtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc2QgPCAwKSB7XHJcbiAgICAgIHFkLnB1c2goMSk7XHJcbiAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIENvbnZlcnQgcHJlY2lzaW9uIGluIG51bWJlciBvZiBiYXNlIDEwIGRpZ2l0cyB0byBiYXNlIDFlNyBkaWdpdHMuXHJcbiAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XHJcbiAgICAgIGkgPSAwO1xyXG5cclxuICAgICAgLy8gZGl2aXNvciA8IDFlN1xyXG4gICAgICBpZiAoeUwgPT0gMSkge1xyXG4gICAgICAgIGsgPSAwO1xyXG4gICAgICAgIHlkID0geWRbMF07XHJcbiAgICAgICAgc2QrKztcclxuXHJcbiAgICAgICAgLy8gayBpcyB0aGUgY2FycnkuXHJcbiAgICAgICAgZm9yICg7IChpIDwgeEwgfHwgaykgJiYgc2QtLTsgaSsrKSB7XHJcbiAgICAgICAgICB0ID0gayAqIGJhc2UgKyAoeGRbaV0gfHwgMCk7XHJcbiAgICAgICAgICBxZFtpXSA9IHQgLyB5ZCB8IDA7XHJcbiAgICAgICAgICBrID0gdCAlIHlkIHwgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG1vcmUgPSBrIHx8IGkgPCB4TDtcclxuXHJcbiAgICAgIC8vIGRpdmlzb3IgPj0gMWU3XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIE5vcm1hbGlzZSB4ZCBhbmQgeWQgc28gaGlnaGVzdCBvcmRlciBkaWdpdCBvZiB5ZCBpcyA+PSBiYXNlLzJcclxuICAgICAgICBrID0gYmFzZSAvICh5ZFswXSArIDEpIHwgMDtcclxuXHJcbiAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICB5ZCA9IG11bHRpcGx5SW50ZWdlcih5ZCwgaywgYmFzZSk7XHJcbiAgICAgICAgICB4ZCA9IG11bHRpcGx5SW50ZWdlcih4ZCwgaywgYmFzZSk7XHJcbiAgICAgICAgICB5TCA9IHlkLmxlbmd0aDtcclxuICAgICAgICAgIHhMID0geGQubGVuZ3RoO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICByZW0gPSB4ZC5zbGljZSgwLCB5TCk7XHJcbiAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgZm9yICg7IHJlbUwgPCB5TDspIHJlbVtyZW1MKytdID0gMDtcclxuXHJcbiAgICAgICAgeXogPSB5ZC5zbGljZSgpO1xyXG4gICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgeWQwID0geWRbMF07XHJcblxyXG4gICAgICAgIGlmICh5ZFsxXSA+PSBiYXNlIC8gMikgKyt5ZDA7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIGsgPSAwO1xyXG5cclxuICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgLy8gSWYgZGl2aXNvciA8IHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChjbXAgPCAwKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIGsuXHJcbiAgICAgICAgICAgIHJlbTAgPSByZW1bMF07XHJcbiAgICAgICAgICAgIGlmICh5TCAhPSByZW1MKSByZW0wID0gcmVtMCAqIGJhc2UgKyAocmVtWzFdIHx8IDApO1xyXG5cclxuICAgICAgICAgICAgLy8gayB3aWxsIGJlIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGsgPSByZW0wIC8geWQwIHwgMDtcclxuXHJcbiAgICAgICAgICAgIC8vICBBbGdvcml0aG06XHJcbiAgICAgICAgICAgIC8vICAxLiBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0IChrKVxyXG4gICAgICAgICAgICAvLyAgMi4gaWYgcHJvZHVjdCA+IHJlbWFpbmRlcjogcHJvZHVjdCAtPSBkaXZpc29yLCBrLS1cclxuICAgICAgICAgICAgLy8gIDMuIHJlbWFpbmRlciAtPSBwcm9kdWN0XHJcbiAgICAgICAgICAgIC8vICA0LiBpZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlciBhdCAyOlxyXG4gICAgICAgICAgICAvLyAgICA1LiBjb21wYXJlIG5ldyByZW1haW5kZXIgYW5kIGRpdmlzb3JcclxuICAgICAgICAgICAgLy8gICAgNi4gSWYgcmVtYWluZGVyID4gZGl2aXNvcjogcmVtYWluZGVyIC09IGRpdmlzb3IsIGsrK1xyXG5cclxuICAgICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgICAgaWYgKGsgPj0gYmFzZSkgayA9IGJhc2UgLSAxO1xyXG5cclxuICAgICAgICAgICAgICAvLyBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0LlxyXG4gICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICAgIHByb2RMID0gcHJvZC5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgIGNtcCA9IGNvbXBhcmUocHJvZCwgcmVtLCBwcm9kTCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHByb2R1Y3QgPiByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBrLS07XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU3VidHJhY3QgZGl2aXNvciBmcm9tIHByb2R1Y3QuXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5ZCwgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAgICAgLy8gY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgIC8vIElmIGsgaXMgMCwgdGhlcmUgaXMgbm8gbmVlZCB0byBjb21wYXJlIHlkIGFuZCByZW0gYWdhaW4gYmVsb3csIHNvIGNoYW5nZSBjbXAgdG8gMVxyXG4gICAgICAgICAgICAgIC8vIHRvIGF2b2lkIGl0LiBJZiBrIGlzIDEgdGhlcmUgaXMgYSBuZWVkIHRvIGNvbXBhcmUgeWQgYW5kIHJlbSBhZ2FpbiBiZWxvdy5cclxuICAgICAgICAgICAgICBpZiAoayA9PSAwKSBjbXAgPSBrID0gMTtcclxuICAgICAgICAgICAgICBwcm9kID0geWQuc2xpY2UoKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKHByb2RMIDwgcmVtTCkgcHJvZC51bnNoaWZ0KDApO1xyXG5cclxuICAgICAgICAgICAgLy8gU3VidHJhY3QgcHJvZHVjdCBmcm9tIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuXHJcbiAgICAgICAgICAgIC8vIElmIHByb2R1Y3Qgd2FzIDwgcHJldmlvdXMgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wID09IC0xKSB7XHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgIC8vIENvbXBhcmUgZGl2aXNvciBhbmQgbmV3IHJlbWFpbmRlci5cclxuICAgICAgICAgICAgICBjbXAgPSBjb21wYXJlKHlkLCByZW0sIHlMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA8IDEpIHtcclxuICAgICAgICAgICAgICAgIGsrKztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCB5TCA8IHJlbUwgPyB5eiA6IHlkLCByZW1MLCBiYXNlKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjbXAgPT09IDApIHtcclxuICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICByZW0gPSBbMF07XHJcbiAgICAgICAgICB9ICAgIC8vIGlmIGNtcCA9PT0gMSwgayB3aWxsIGJlIDBcclxuXHJcbiAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIGssIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICBxZFtpKytdID0gaztcclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbWFpbmRlci5cclxuICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XHJcbiAgICAgICAgICAgIHJlbVtyZW1MKytdID0geGRbeGldIHx8IDA7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcclxuICAgICAgICAgICAgcmVtTCA9IDE7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9PSB2b2lkIDApICYmIHNkLS0pO1xyXG5cclxuICAgICAgICBtb3JlID0gcmVtWzBdICE9PSB2b2lkIDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgaWYgKCFxZFswXSkgcWQuc2hpZnQoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBsb2dCYXNlIGlzIDEgd2hlbiBkaXZpZGUgaXMgYmVpbmcgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgaWYgKGxvZ0Jhc2UgPT0gMSkge1xyXG4gICAgICBxLmUgPSBlO1xyXG4gICAgICBpbmV4YWN0ID0gbW9yZTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBUbyBjYWxjdWxhdGUgcS5lLCBmaXJzdCBnZXQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgcWRbMF0uXHJcbiAgICAgIGZvciAoaSA9IDEsIGsgPSBxZFswXTsgayA+PSAxMDsgayAvPSAxMCkgaSsrO1xyXG4gICAgICBxLmUgPSBpICsgZSAqIGxvZ0Jhc2UgLSAxO1xyXG5cclxuICAgICAgZmluYWxpc2UocSwgZHAgPyBwciArIHEuZSArIDEgOiBwciwgcm0sIG1vcmUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBxO1xyXG4gIH07XHJcbn0pKCk7XHJcblxyXG5cclxuLypcclxuICogUm91bmQgYHhgIHRvIGBzZGAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICogQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICovXHJcbiBmdW5jdGlvbiBmaW5hbGlzZSh4LCBzZCwgcm0sIGlzVHJ1bmNhdGVkKSB7XHJcbiAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgLy8gRG9uJ3Qgcm91bmQgaWYgc2QgaXMgbnVsbCBvciB1bmRlZmluZWQuXHJcbiAgb3V0OiBpZiAoc2QgIT0gbnVsbCkge1xyXG4gICAgeGQgPSB4LmQ7XHJcblxyXG4gICAgLy8gSW5maW5pdHkvTmFOLlxyXG4gICAgaWYgKCF4ZCkgcmV0dXJuIHg7XHJcblxyXG4gICAgLy8gcmQ6IHRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAvLyB3OiB0aGUgd29yZCBvZiB4ZCBjb250YWluaW5nIHJkLCBhIGJhc2UgMWU3IG51bWJlci5cclxuICAgIC8vIHhkaTogdGhlIGluZGV4IG9mIHcgd2l0aGluIHhkLlxyXG4gICAgLy8gZGlnaXRzOiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB3LlxyXG4gICAgLy8gaTogd2hhdCB3b3VsZCBiZSB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcgaWYgYWxsIHRoZSBudW1iZXJzIHdlcmUgNyBkaWdpdHMgbG9uZyAoaS5lLiBpZlxyXG4gICAgLy8gdGhleSBoYWQgbGVhZGluZyB6ZXJvcylcclxuICAgIC8vIGo6IGlmID4gMCwgdGhlIGFjdHVhbCBpbmRleCBvZiByZCB3aXRoaW4gdyAoaWYgPCAwLCByZCBpcyBhIGxlYWRpbmcgemVybykuXHJcblxyXG4gICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheSB4ZC5cclxuICAgIGZvciAoZGlnaXRzID0gMSwgayA9IHhkWzBdOyBrID49IDEwOyBrIC89IDEwKSBkaWdpdHMrKztcclxuICAgIGkgPSBzZCAtIGRpZ2l0cztcclxuXHJcbiAgICAvLyBJcyB0aGUgcm91bmRpbmcgZGlnaXQgaW4gdGhlIGZpcnN0IHdvcmQgb2YgeGQ/XHJcbiAgICBpZiAoaSA8IDApIHtcclxuICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgaiA9IHNkO1xyXG4gICAgICB3ID0geGRbeGRpID0gMF07XHJcblxyXG4gICAgICAvLyBHZXQgdGhlIHJvdW5kaW5nIGRpZ2l0IGF0IGluZGV4IGogb2Ygdy5cclxuICAgICAgcmQgPSB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeGRpID0gTWF0aC5jZWlsKChpICsgMSkgLyBMT0dfQkFTRSk7XHJcbiAgICAgIGsgPSB4ZC5sZW5ndGg7XHJcbiAgICAgIGlmICh4ZGkgPj0gaykge1xyXG4gICAgICAgIGlmIChpc1RydW5jYXRlZCkge1xyXG5cclxuICAgICAgICAgIC8vIE5lZWRlZCBieSBgbmF0dXJhbEV4cG9uZW50aWFsYCwgYG5hdHVyYWxMb2dhcml0aG1gIGFuZCBgc3F1YXJlUm9vdGAuXHJcbiAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTspIHhkLnB1c2goMCk7XHJcbiAgICAgICAgICB3ID0gcmQgPSAwO1xyXG4gICAgICAgICAgZGlnaXRzID0gMTtcclxuICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB3ID0gayA9IHhkW3hkaV07XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB3LlxyXG4gICAgICAgIGZvciAoZGlnaXRzID0gMTsgayA+PSAxMDsgayAvPSAxMCkgZGlnaXRzKys7XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcuXHJcbiAgICAgICAgaSAlPSBMT0dfQkFTRTtcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSBpbmRleCBvZiByZCB3aXRoaW4gdywgYWRqdXN0ZWQgZm9yIGxlYWRpbmcgemVyb3MuXHJcbiAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcgaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkaWdpdHMuXHJcbiAgICAgICAgaiA9IGkgLSBMT0dfQkFTRSArIGRpZ2l0cztcclxuXHJcbiAgICAgICAgLy8gR2V0IHRoZSByb3VuZGluZyBkaWdpdCBhdCBpbmRleCBqIG9mIHcuXHJcbiAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgaXNUcnVuY2F0ZWQgPSBpc1RydW5jYXRlZCB8fCBzZCA8IDAgfHxcclxuICAgICAgeGRbeGRpICsgMV0gIT09IHZvaWQgMCB8fCAoaiA8IDAgPyB3IDogdyAlIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSk7XHJcblxyXG4gICAgLy8gVGhlIGV4cHJlc3Npb24gYHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSlgIHJldHVybnMgYWxsIHRoZSBkaWdpdHMgb2YgdyB0byB0aGUgcmlnaHRcclxuICAgIC8vIG9mIHRoZSBkaWdpdCBhdCAobGVmdC10by1yaWdodCkgaW5kZXggaiwgZS5nLiBpZiB3IGlzIDkwODcxNCBhbmQgaiBpcyAyLCB0aGUgZXhwcmVzc2lvblxyXG4gICAgLy8gd2lsbCBnaXZlIDcxNC5cclxuXHJcbiAgICByb3VuZFVwID0gcm0gPCA0XHJcbiAgICAgID8gKHJkIHx8IGlzVHJ1bmNhdGVkKSAmJiAocm0gPT0gMCB8fCBybSA9PSAoeC5zIDwgMCA/IDMgOiAyKSlcclxuICAgICAgOiByZCA+IDUgfHwgcmQgPT0gNSAmJiAocm0gPT0gNCB8fCBpc1RydW5jYXRlZCB8fCBybSA9PSA2ICYmXHJcblxyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgKChpID4gMCA/IGogPiAwID8gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGopIDogMCA6IHhkW3hkaSAtIDFdKSAlIDEwKSAmIDEgfHxcclxuICAgICAgICAgIHJtID09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xyXG4gICAgICB4ZC5sZW5ndGggPSAwO1xyXG4gICAgICBpZiAocm91bmRVcCkge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgIHNkIC09IHguZSArIDE7XHJcblxyXG4gICAgICAgIC8vIDEsIDAuMSwgMC4wMSwgMC4wMDEsIDAuMDAwMSBldGMuXHJcbiAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcclxuICAgICAgICB4LmUgPSAtc2QgfHwgMDtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4ZFswXSA9IHguZSA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSBleGNlc3MgZGlnaXRzLlxyXG4gICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICB4ZC5sZW5ndGggPSB4ZGk7XHJcbiAgICAgIGsgPSAxO1xyXG4gICAgICB4ZGktLTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHhkLmxlbmd0aCA9IHhkaSArIDE7XHJcbiAgICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG5cclxuICAgICAgLy8gRS5nLiA1NjcwMCBiZWNvbWVzIDU2MDAwIGlmIDcgaXMgdGhlIHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAvLyBqID4gMCBtZWFucyBpID4gbnVtYmVyIG9mIGxlYWRpbmcgemVyb3Mgb2Ygdy5cclxuICAgICAgeGRbeGRpXSA9IGogPiAwID8gKHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSAlIG1hdGhwb3coMTAsIGopIHwgMCkgKiBrIDogMDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAocm91bmRVcCkge1xyXG4gICAgICBmb3IgKDs7KSB7XHJcblxyXG4gICAgICAgIC8vIElzIHRoZSBkaWdpdCB0byBiZSByb3VuZGVkIHVwIGluIHRoZSBmaXJzdCB3b3JkIG9mIHhkP1xyXG4gICAgICAgIGlmICh4ZGkgPT0gMCkge1xyXG5cclxuICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhkWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgZm9yIChpID0gMSwgaiA9IHhkWzBdOyBqID49IDEwOyBqIC89IDEwKSBpKys7XHJcbiAgICAgICAgICBqID0geGRbMF0gKz0gaztcclxuICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApIGsrKztcclxuXHJcbiAgICAgICAgICAvLyBpZiBpICE9IGsgdGhlIGxlbmd0aCBoYXMgaW5jcmVhc2VkLlxyXG4gICAgICAgICAgaWYgKGkgIT0gaykge1xyXG4gICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgaWYgKHhkWzBdID09IEJBU0UpIHhkWzBdID0gMTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeGRbeGRpXSArPSBrO1xyXG4gICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICB4ZFt4ZGktLV0gPSAwO1xyXG4gICAgICAgICAgayA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0geGQubGVuZ3RoOyB4ZFstLWldID09PSAwOykgeGQucG9wKCk7XHJcbiAgfVxyXG5cclxuICBpZiAoZXh0ZXJuYWwpIHtcclxuXHJcbiAgICAvLyBPdmVyZmxvdz9cclxuICAgIGlmICh4LmUgPiBDdG9yLm1heEUpIHtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICB4LmQgPSBudWxsO1xyXG4gICAgICB4LmUgPSBOYU47XHJcblxyXG4gICAgLy8gVW5kZXJmbG93P1xyXG4gICAgfSBlbHNlIGlmICh4LmUgPCBDdG9yLm1pbkUpIHtcclxuXHJcbiAgICAgIC8vIFplcm8uXHJcbiAgICAgIHguZSA9IDA7XHJcbiAgICAgIHguZCA9IFswXTtcclxuICAgICAgLy8gQ3Rvci51bmRlcmZsb3cgPSB0cnVlO1xyXG4gICAgfSAvLyBlbHNlIEN0b3IudW5kZXJmbG93ID0gZmFsc2U7XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGZpbml0ZVRvU3RyaW5nKHgsIGlzRXhwLCBzZCkge1xyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbm9uRmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgdmFyIGssXHJcbiAgICBlID0geC5lLFxyXG4gICAgc3RyID0gZGlnaXRzVG9TdHJpbmcoeC5kKSxcclxuICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gIGlmIChpc0V4cCkge1xyXG4gICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkge1xyXG4gICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgIH0gZWxzZSBpZiAobGVuID4gMSkge1xyXG4gICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IHN0ciArICh4LmUgPCAwID8gJ2UnIDogJ2UrJykgKyB4LmU7XHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG4gICAgc3RyID0gJzAuJyArIGdldFplcm9TdHJpbmcoLWUgLSAxKSArIHN0cjtcclxuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHN0ciArPSBnZXRaZXJvU3RyaW5nKGspO1xyXG4gIH0gZWxzZSBpZiAoZSA+PSBsZW4pIHtcclxuICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGUgKyAxIC0gbGVuKTtcclxuICAgIGlmIChzZCAmJiAoayA9IHNkIC0gZSAtIDEpID4gMCkgc3RyID0gc3RyICsgJy4nICsgZ2V0WmVyb1N0cmluZyhrKTtcclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKChrID0gZSArIDEpIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyAnLicgKyBzdHIuc2xpY2Uoayk7XHJcbiAgICBpZiAoc2QgJiYgKGsgPSBzZCAtIGxlbikgPiAwKSB7XHJcbiAgICAgIGlmIChlICsgMSA9PT0gbGVuKSBzdHIgKz0gJy4nO1xyXG4gICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBDYWxjdWxhdGUgdGhlIGJhc2UgMTAgZXhwb25lbnQgZnJvbSB0aGUgYmFzZSAxZTcgZXhwb25lbnQuXHJcbmZ1bmN0aW9uIGdldEJhc2UxMEV4cG9uZW50KGRpZ2l0cywgZSkge1xyXG4gIHZhciB3ID0gZGlnaXRzWzBdO1xyXG5cclxuICAvLyBBZGQgdGhlIG51bWJlciBvZiBkaWdpdHMgb2YgdGhlIGZpcnN0IHdvcmQgb2YgdGhlIGRpZ2l0cyBhcnJheS5cclxuICBmb3IgKCBlICo9IExPR19CQVNFOyB3ID49IDEwOyB3IC89IDEwKSBlKys7XHJcbiAgcmV0dXJuIGU7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xyXG4gIGlmIChzZCA+IExOMTBfUFJFQ0lTSU9OKSB7XHJcblxyXG4gICAgLy8gUmVzZXQgZ2xvYmFsIHN0YXRlIGluIGNhc2UgdGhlIGV4Y2VwdGlvbiBpcyBjYXVnaHQuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICBpZiAocHIpIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICB0aHJvdyBFcnJvcihwcmVjaXNpb25MaW1pdEV4Y2VlZGVkKTtcclxuICB9XHJcbiAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKExOMTApLCBzZCwgMSwgdHJ1ZSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRQaShDdG9yLCBzZCwgcm0pIHtcclxuICBpZiAoc2QgPiBQSV9QUkVDSVNJT04pIHRocm93IEVycm9yKHByZWNpc2lvbkxpbWl0RXhjZWVkZWQpO1xyXG4gIHJldHVybiBmaW5hbGlzZShuZXcgQ3RvcihQSSksIHNkLCBybSwgdHJ1ZSk7XHJcbn1cclxuXHJcblxyXG5mdW5jdGlvbiBnZXRQcmVjaXNpb24oZGlnaXRzKSB7XHJcbiAgdmFyIHcgPSBkaWdpdHMubGVuZ3RoIC0gMSxcclxuICAgIGxlbiA9IHcgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gIHcgPSBkaWdpdHNbd107XHJcblxyXG4gIC8vIElmIG5vbi16ZXJvLi4uXHJcbiAgaWYgKHcpIHtcclxuXHJcbiAgICAvLyBTdWJ0cmFjdCB0aGUgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zIG9mIHRoZSBsYXN0IHdvcmQuXHJcbiAgICBmb3IgKDsgdyAlIDEwID09IDA7IHcgLz0gMTApIGxlbi0tO1xyXG5cclxuICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZC5cclxuICAgIGZvciAodyA9IGRpZ2l0c1swXTsgdyA+PSAxMDsgdyAvPSAxMCkgbGVuKys7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gbGVuO1xyXG59XHJcblxyXG5cclxuZnVuY3Rpb24gZ2V0WmVyb1N0cmluZyhrKSB7XHJcbiAgdmFyIHpzID0gJyc7XHJcbiAgZm9yICg7IGstLTspIHpzICs9ICcwJztcclxuICByZXR1cm4genM7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgRGVjaW1hbCBgeGAgdG8gdGhlIHBvd2VyIGBuYCwgd2hlcmUgYG5gIGlzIGFuXHJcbiAqIGludGVnZXIgb2YgdHlwZSBudW1iZXIuXHJcbiAqXHJcbiAqIEltcGxlbWVudHMgJ2V4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nJy4gQ2FsbGVkIGJ5IGBwb3dgIGFuZCBgcGFyc2VPdGhlcmAuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnRQb3coQ3RvciwgeCwgbiwgcHIpIHtcclxuICB2YXIgaXNUcnVuY2F0ZWQsXHJcbiAgICByID0gbmV3IEN0b3IoMSksXHJcblxyXG4gICAgLy8gTWF4IG4gb2YgOTAwNzE5OTI1NDc0MDk5MSB0YWtlcyA1MyBsb29wIGl0ZXJhdGlvbnMuXHJcbiAgICAvLyBNYXhpbXVtIGRpZ2l0cyBhcnJheSBsZW5ndGg7IGxlYXZlcyBbMjgsIDM0XSBndWFyZCBkaWdpdHMuXHJcbiAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UgKyA0KTtcclxuXHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgaWYgKG4gJSAyKSB7XHJcbiAgICAgIHIgPSByLnRpbWVzKHgpO1xyXG4gICAgICBpZiAodHJ1bmNhdGUoci5kLCBrKSkgaXNUcnVuY2F0ZWQgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIG4gPSBtYXRoZmxvb3IobiAvIDIpO1xyXG4gICAgaWYgKG4gPT09IDApIHtcclxuXHJcbiAgICAgIC8vIFRvIGVuc3VyZSBjb3JyZWN0IHJvdW5kaW5nIHdoZW4gci5kIGlzIHRydW5jYXRlZCwgaW5jcmVtZW50IHRoZSBsYXN0IHdvcmQgaWYgaXQgaXMgemVyby5cclxuICAgICAgbiA9IHIuZC5sZW5ndGggLSAxO1xyXG4gICAgICBpZiAoaXNUcnVuY2F0ZWQgJiYgci5kW25dID09PSAwKSArK3IuZFtuXTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgeCA9IHgudGltZXMoeCk7XHJcbiAgICB0cnVuY2F0ZSh4LmQsIGspO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gcjtcclxufVxyXG5cclxuXHJcbmZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICByZXR1cm4gbi5kW24uZC5sZW5ndGggLSAxXSAmIDE7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBIYW5kbGUgYG1heGAgKGBuYCBpcyAtMSkgYW5kIGBtaW5gIChgbmAgaXMgMSkuXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBuKSB7XHJcbiAgdmFyIGssIHksXHJcbiAgICB4ID0gbmV3IEN0b3IoYXJnc1swXSksXHJcbiAgICBpID0gMDtcclxuXHJcbiAgZm9yICg7ICsraSA8IGFyZ3MubGVuZ3RoOykge1xyXG4gICAgeSA9IG5ldyBDdG9yKGFyZ3NbaV0pO1xyXG5cclxuICAgIC8vIE5hTj9cclxuICAgIGlmICgheS5zKSB7XHJcbiAgICAgIHggPSB5O1xyXG4gICAgICBicmVhaztcclxuICAgIH1cclxuXHJcbiAgICBrID0geC5jbXAoeSk7XHJcblxyXG4gICAgaWYgKGsgPT09IG4gfHwgayA9PT0gMCAmJiB4LnMgPT09IG4pIHtcclxuICAgICAgeCA9IHk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzLlxyXG4gKlxyXG4gKiBUYXlsb3IvTWFjbGF1cmluIHNlcmllcy5cclxuICpcclxuICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAqXHJcbiAqIEFyZ3VtZW50IHJlZHVjdGlvbjpcclxuICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICogICBleHAoeCkgPSBleHAoeCAvIDJeayleKDJeaylcclxuICpcclxuICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gKiBleHAoeCkgPSBleHAocikgKiAxMF5rICB3aGVyZSByID0geCAtIGsgKiBsbjEwLCBrID0gZmxvb3IoeCAvIGxuMTApXHJcbiAqIHRvIGZpcnN0IHB1dCByIGluIHRoZSByYW5nZSBbMCwgbG4xMF0sIGJlZm9yZSBkaXZpZGluZyBieSAzMiB1bnRpbCB8eHwgPCAwLjEsIGJ1dCB0aGlzIHdhc1xyXG4gKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAqXHJcbiAqIE1heCBpbnRlZ2VyIGFyZ3VtZW50OiBleHAoJzIwNzIzMjY1ODM2OTQ2NDEzJykgPSA2LjNlKzkwMDAwMDAwMDAwMDAwMDBcclxuICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICogKE1hdGggb2JqZWN0IGludGVnZXIgbWluL21heDogTWF0aC5leHAoNzA5KSA9IDguMmUrMzA3LCBNYXRoLmV4cCgtNzQ1KSA9IDVlLTMyNClcclxuICpcclxuICogIGV4cChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGV4cCgtSW5maW5pdHkpID0gMFxyXG4gKiAgZXhwKE5hTikgICAgICAgPSBOYU5cclxuICogIGV4cCjCsTApICAgICAgICA9IDFcclxuICpcclxuICogIGV4cCh4KSBpcyBub24tdGVybWluYXRpbmcgZm9yIGFueSBmaW5pdGUsIG5vbi16ZXJvIHguXHJcbiAqXHJcbiAqICBUaGUgcmVzdWx0IHdpbGwgYWx3YXlzIGJlIGNvcnJlY3RseSByb3VuZGVkLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbmF0dXJhbEV4cG9uZW50aWFsKHgsIHNkKSB7XHJcbiAgdmFyIGRlbm9taW5hdG9yLCBndWFyZCwgaiwgcG93LCBzdW0sIHQsIHdwcixcclxuICAgIHJlcCA9IDAsXHJcbiAgICBpID0gMCxcclxuICAgIGsgPSAwLFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAvLyAwL05hTi9JbmZpbml0eT9cclxuICBpZiAoIXguZCB8fCAheC5kWzBdIHx8IHguZSA+IDE3KSB7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBDdG9yKHguZFxyXG4gICAgICA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMFxyXG4gICAgICA6IHgucyA/IHgucyA8IDAgPyAwIDogeCA6IDAgLyAwKTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xyXG5cclxuICAvLyB3aGlsZSBhYnMoeCkgPj0gMC4xXHJcbiAgd2hpbGUgKHguZSA+IC0yKSB7XHJcblxyXG4gICAgLy8geCA9IHggLyAyXjVcclxuICAgIHggPSB4LnRpbWVzKHQpO1xyXG4gICAgayArPSA1O1xyXG4gIH1cclxuXHJcbiAgLy8gVXNlIDIgKiBsb2cxMCgyXmspICsgNSAoZW1waXJpY2FsbHkgZGVyaXZlZCkgdG8gZXN0aW1hdGUgdGhlIGluY3JlYXNlIGluIHByZWNpc2lvblxyXG4gIC8vIG5lY2Vzc2FyeSB0byBlbnN1cmUgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIGFyZSBjb3JyZWN0LlxyXG4gIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgd3ByICs9IGd1YXJkO1xyXG4gIGRlbm9taW5hdG9yID0gcG93ID0gc3VtID0gbmV3IEN0b3IoMSk7XHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XHJcblxyXG4gIGZvciAoOzspIHtcclxuICAgIHBvdyA9IGZpbmFsaXNlKHBvdy50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcclxuICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUocG93LCBkZW5vbWluYXRvciwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgaiA9IGs7XHJcbiAgICAgIHdoaWxlIChqLS0pIHN1bSA9IGZpbmFsaXNlKHN1bS50aW1lcyhzdW0pLCB3cHIsIDEpO1xyXG5cclxuICAgICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OS5cclxuICAgICAgLy8gSWYgc28sIHJlcGVhdCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgLy8gZS5nLiB3aXRoIHByZWNpc2lvbjogMTgsIHJvdW5kaW5nOiAxXHJcbiAgICAgIC8vIGV4cCgxOC40MDQyNzI0NjI1OTUwMzQwODM1Njc3OTM5MTk4NDM3NjEpID0gOTgzNzI1NjAuMTIyOTk5OTk5OSAoc2hvdWxkIGJlIDk4MzcyNTYwLjEyMylcclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcblxyXG4gICAgICAgIGlmIChyZXAgPCAzICYmIGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XHJcbiAgICAgICAgICBkZW5vbWluYXRvciA9IHBvdyA9IHQgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmaW5hbGlzZShzdW0sIEN0b3IucHJlY2lzaW9uID0gcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBzdW0gPSB0O1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAgcm91bmRlZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cy5cclxuICpcclxuICogIGxuKC1uKSAgICAgICAgPSBOYU5cclxuICogIGxuKDApICAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKC0wKSAgICAgICAgPSAtSW5maW5pdHlcclxuICogIGxuKDEpICAgICAgICAgPSAwXHJcbiAqICBsbihJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICogIGxuKC1JbmZpbml0eSkgPSBOYU5cclxuICogIGxuKE5hTikgICAgICAgPSBOYU5cclxuICpcclxuICogIGxuKG4pIChuICE9IDEpIGlzIG5vbi10ZXJtaW5hdGluZy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcclxuICB2YXIgYywgYzAsIGRlbm9taW5hdG9yLCBlLCBudW1lcmF0b3IsIHJlcCwgc3VtLCB0LCB3cHIsIHgxLCB4MixcclxuICAgIG4gPSAxLFxyXG4gICAgZ3VhcmQgPSAxMCxcclxuICAgIHggPSB5LFxyXG4gICAgeGQgPSB4LmQsXHJcbiAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcblxyXG4gIC8vIElzIHggbmVnYXRpdmUgb3IgSW5maW5pdHksIE5hTiwgMCBvciAxP1xyXG4gIGlmICh4LnMgPCAwIHx8ICF4ZCB8fCAheGRbMF0gfHwgIXguZSAmJiB4ZFswXSA9PSAxICYmIHhkLmxlbmd0aCA9PSAxKSB7XHJcbiAgICByZXR1cm4gbmV3IEN0b3IoeGQgJiYgIXhkWzBdID8gLTEgLyAwIDogeC5zICE9IDEgPyBOYU4gOiB4ZCA/IDAgOiB4KTtcclxuICB9XHJcblxyXG4gIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgd3ByID0gcHI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHdwciA9IHNkO1xyXG4gIH1cclxuXHJcbiAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgYyA9IGRpZ2l0c1RvU3RyaW5nKHhkKTtcclxuICBjMCA9IGMuY2hhckF0KDApO1xyXG5cclxuICBpZiAoTWF0aC5hYnMoZSA9IHguZSkgPCAxLjVlMTUpIHtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICAvLyBUaGUgc2VyaWVzIGNvbnZlcmdlcyBmYXN0ZXIgdGhlIGNsb3NlciB0aGUgYXJndW1lbnQgaXMgdG8gMSwgc28gdXNpbmdcclxuICAgIC8vIGxuKGFeYikgPSBiICogbG4oYSksICAgbG4oYSkgPSBsbihhXmIpIC8gYlxyXG4gICAgLy8gbXVsdGlwbHkgdGhlIGFyZ3VtZW50IGJ5IGl0c2VsZiB1bnRpbCB0aGUgbGVhZGluZyBkaWdpdHMgb2YgdGhlIHNpZ25pZmljYW5kIGFyZSA3LCA4LCA5LFxyXG4gICAgLy8gMTAsIDExLCAxMiBvciAxMywgcmVjb3JkaW5nIHRoZSBudW1iZXIgb2YgbXVsdGlwbGljYXRpb25zIHNvIHRoZSBzdW0gb2YgdGhlIHNlcmllcyBjYW5cclxuICAgIC8vIGxhdGVyIGJlIGRpdmlkZWQgYnkgdGhpcyBudW1iZXIsIHRoZW4gc2VwYXJhdGUgb3V0IHRoZSBwb3dlciBvZiAxMCB1c2luZ1xyXG4gICAgLy8gbG4oYSoxMF5iKSA9IGxuKGEpICsgYipsbigxMCkuXHJcblxyXG4gICAgLy8gbWF4IG4gaXMgMjEgKGdpdmVzIDAuOSwgMS4wIG9yIDEuMSkgKDllMTUgLyAyMSA9IDQuMmUxNCkuXHJcbiAgICAvL3doaWxlIChjMCA8IDkgJiYgYzAgIT0gMSB8fCBjMCA9PSAxICYmIGMuY2hhckF0KDEpID4gMSkge1xyXG4gICAgLy8gbWF4IG4gaXMgNiAoZ2l2ZXMgMC43IC0gMS4zKVxyXG4gICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XHJcbiAgICAgIHggPSB4LnRpbWVzKHkpO1xyXG4gICAgICBjID0gZGlnaXRzVG9TdHJpbmcoeC5kKTtcclxuICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuICAgICAgbisrO1xyXG4gICAgfVxyXG5cclxuICAgIGUgPSB4LmU7XHJcblxyXG4gICAgaWYgKGMwID4gMSkge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoJzAuJyArIGMpO1xyXG4gICAgICBlKys7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB4ID0gbmV3IEN0b3IoYzAgKyAnLicgKyBjLnNsaWNlKDEpKTtcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG5cclxuICAgIC8vIFRoZSBhcmd1bWVudCByZWR1Y3Rpb24gbWV0aG9kIGFib3ZlIG1heSByZXN1bHQgaW4gb3ZlcmZsb3cgaWYgdGhlIGFyZ3VtZW50IHkgaXMgYSBtYXNzaXZlXHJcbiAgICAvLyBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICg5ZTE1IC8gNiA9IDEuNWUxNSksIHNvIGluc3RlYWQgcmVjYWxsIHRoaXNcclxuICAgIC8vIGZ1bmN0aW9uIHVzaW5nIGxuKHgqMTBeZSkgPSBsbih4KSArIGUqbG4oMTApLlxyXG4gICAgdCA9IGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJyk7XHJcbiAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcblxyXG4gICAgcmV0dXJuIHNkID09IG51bGwgPyBmaW5hbGlzZSh4LCBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSkgOiB4O1xyXG4gIH1cclxuXHJcbiAgLy8geDEgaXMgeCByZWR1Y2VkIHRvIGEgdmFsdWUgbmVhciAxLlxyXG4gIHgxID0geDtcclxuXHJcbiAgLy8gVGF5bG9yIHNlcmllcy5cclxuICAvLyBsbih5KSA9IGxuKCgxICsgeCkvKDEgLSB4KSkgPSAyKHggKyB4XjMvMyArIHheNS81ICsgeF43LzcgKyAuLi4pXHJcbiAgLy8gd2hlcmUgeCA9ICh5IC0gMSkvKHkgKyAxKSAgICAofHh8IDwgMSlcclxuICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcclxuICB4MiA9IGZpbmFsaXNlKHgudGltZXMoeCksIHdwciwgMSk7XHJcbiAgZGVub21pbmF0b3IgPSAzO1xyXG5cclxuICBmb3IgKDs7KSB7XHJcbiAgICBudW1lcmF0b3IgPSBmaW5hbGlzZShudW1lcmF0b3IudGltZXMoeDIpLCB3cHIsIDEpO1xyXG4gICAgdCA9IHN1bS5wbHVzKGRpdmlkZShudW1lcmF0b3IsIG5ldyBDdG9yKGRlbm9taW5hdG9yKSwgd3ByLCAxKSk7XHJcblxyXG4gICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgc3VtID0gc3VtLnRpbWVzKDIpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLiBDaGVjayB0aGF0IGUgaXMgbm90IDAgYmVjYXVzZSwgYmVzaWRlcyBwcmV2ZW50aW5nIGFuXHJcbiAgICAgIC8vIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLCAtMCArIDAgPSArMCBhbmQgdG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgLTAgbmVlZHMgdG8gc3RheSAtMC5cclxuICAgICAgaWYgKGUgIT09IDApIHN1bSA9IHN1bS5wbHVzKGdldExuMTAoQ3Rvciwgd3ByICsgMiwgcHIpLnRpbWVzKGUgKyAnJykpO1xyXG4gICAgICBzdW0gPSBkaXZpZGUoc3VtLCBuZXcgQ3RvcihuKSwgd3ByLCAxKTtcclxuXHJcbiAgICAgIC8vIElzIHJtID4gMyBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDQ5OTksIG9yIHJtIDwgNCAob3IgdGhlIHN1bW1hdGlvbiBoYXNcclxuICAgICAgLy8gYmVlbiByZXBlYXRlZCBwcmV2aW91c2x5KSBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDk5OTk/XHJcbiAgICAgIC8vIElmIHNvLCByZXN0YXJ0IHRoZSBzdW1tYXRpb24gd2l0aCBhIGhpZ2hlciBwcmVjaXNpb24sIG90aGVyd2lzZVxyXG4gICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgLy8gbG4oMTM1NTIwMDI4LjYxMjYwOTE3MTQyNjUzODE1MzMpID0gMTguNzI0NjI5OTk5OSB3aGVuIGl0IHNob3VsZCBiZSAxOC43MjQ2My5cclxuICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoc3VtLmQsIHdwciAtIGd1YXJkLCBybSwgcmVwKSkge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gZ3VhcmQ7XHJcbiAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcclxuICAgICAgICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgICAgICAgIGRlbm9taW5hdG9yID0gcmVwID0gMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGZpbmFsaXNlKHN1bSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgcm0sIGV4dGVybmFsID0gdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICAgICAgcmV0dXJuIHN1bTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN1bSA9IHQ7XHJcbiAgICBkZW5vbWluYXRvciArPSAyO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIMKxSW5maW5pdHksIE5hTi5cclxuZnVuY3Rpb24gbm9uRmluaXRlVG9TdHJpbmcoeCkge1xyXG4gIC8vIFVuc2lnbmVkLlxyXG4gIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBzdHJpbmcgYHN0cmAuXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZURlY2ltYWwoeCwgc3RyKSB7XHJcbiAgdmFyIGUsIGksIGxlbjtcclxuXHJcbiAgLy8gVE9ETyBCaWdJbnQgc3RyOiBubyBuZWVkIHRvIGNoZWNrIGZvciBkZWNpbWFsIHBvaW50LCBleHBvbmVudGlhbCBmb3JtIG9yIGxlYWRpbmcgemVyb3MuXHJcbiAgLy8gRGVjaW1hbCBwb2ludD9cclxuICBpZiAoKGUgPSBzdHIuaW5kZXhPZignLicpKSA+IC0xKSBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuXHJcbiAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICBpZiAoKGkgPSBzdHIuc2VhcmNoKC9lL2kpKSA+IDApIHtcclxuXHJcbiAgICAvLyBEZXRlcm1pbmUgZXhwb25lbnQuXHJcbiAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgZSArPSArc3RyLnNsaWNlKGkgKyAxKTtcclxuICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMCwgaSk7XHJcbiAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgIC8vIEludGVnZXIuXHJcbiAgICBlID0gc3RyLmxlbmd0aDtcclxuICB9XHJcblxyXG4gIC8vIERldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gIGZvciAoaSA9IDA7IHN0ci5jaGFyQ29kZUF0KGkpID09PSA0ODsgaSsrKTtcclxuXHJcbiAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZvciAobGVuID0gc3RyLmxlbmd0aDsgc3RyLmNoYXJDb2RlQXQobGVuIC0gMSkgPT09IDQ4OyAtLWxlbik7XHJcbiAgc3RyID0gc3RyLnNsaWNlKGksIGxlbik7XHJcblxyXG4gIGlmIChzdHIpIHtcclxuICAgIGxlbiAtPSBpO1xyXG4gICAgeC5lID0gZSA9IGUgLSBpIC0gMTtcclxuICAgIHguZCA9IFtdO1xyXG5cclxuICAgIC8vIFRyYW5zZm9ybSBiYXNlXHJcblxyXG4gICAgLy8gZSBpcyB0aGUgYmFzZSAxMCBleHBvbmVudC5cclxuICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgaSA9IChlICsgMSkgJSBMT0dfQkFTRTtcclxuICAgIGlmIChlIDwgMCkgaSArPSBMT0dfQkFTRTtcclxuXHJcbiAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICBpZiAoaSkgeC5kLnB1c2goK3N0ci5zbGljZSgwLCBpKSk7XHJcbiAgICAgIGZvciAobGVuIC09IExPR19CQVNFOyBpIDwgbGVuOykgeC5kLnB1c2goK3N0ci5zbGljZShpLCBpICs9IExPR19CQVNFKSk7XHJcbiAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgaSA9IExPR19CQVNFIC0gc3RyLmxlbmd0aDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGkgLT0gbGVuO1xyXG4gICAgfVxyXG5cclxuICAgIGZvciAoOyBpLS07KSBzdHIgKz0gJzAnO1xyXG4gICAgeC5kLnB1c2goK3N0cik7XHJcblxyXG4gICAgaWYgKGV4dGVybmFsKSB7XHJcblxyXG4gICAgICAvLyBPdmVyZmxvdz9cclxuICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xyXG5cclxuICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAgIC8vIFVuZGVyZmxvdz9cclxuICAgICAgfSBlbHNlIGlmICh4LmUgPCB4LmNvbnN0cnVjdG9yLm1pbkUpIHtcclxuXHJcbiAgICAgICAgLy8gWmVyby5cclxuICAgICAgICB4LmUgPSAwO1xyXG4gICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAvLyB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICAgIH0gLy8gZWxzZSB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IGZhbHNlO1xyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcblxyXG4gICAgLy8gWmVyby5cclxuICAgIHguZSA9IDA7XHJcbiAgICB4LmQgPSBbMF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFBhcnNlIHRoZSB2YWx1ZSBvZiBhIG5ldyBEZWNpbWFsIGB4YCBmcm9tIGEgc3RyaW5nIGBzdHJgLCB3aGljaCBpcyBub3QgYSBkZWNpbWFsIHZhbHVlLlxyXG4gKi9cclxuZnVuY3Rpb24gcGFyc2VPdGhlcih4LCBzdHIpIHtcclxuICB2YXIgYmFzZSwgQ3RvciwgZGl2aXNvciwgaSwgaXNGbG9hdCwgbGVuLCBwLCB4ZCwgeGU7XHJcblxyXG4gIGlmIChzdHIuaW5kZXhPZignXycpID4gLTEpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKC8oXFxkKV8oPz1cXGQpL2csICckMScpO1xyXG4gICAgaWYgKGlzRGVjaW1hbC50ZXN0KHN0cikpIHJldHVybiBwYXJzZURlY2ltYWwoeCwgc3RyKTtcclxuICB9IGVsc2UgaWYgKHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICdOYU4nKSB7XHJcbiAgICBpZiAoIStzdHIpIHgucyA9IE5hTjtcclxuICAgIHguZSA9IE5hTjtcclxuICAgIHguZCA9IG51bGw7XHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG4gIGlmIChpc0hleC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gMTY7XHJcbiAgICBzdHIgPSBzdHIudG9Mb3dlckNhc2UoKTtcclxuICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkgIHtcclxuICAgIGJhc2UgPSAyO1xyXG4gIH0gZWxzZSBpZiAoaXNPY3RhbC50ZXN0KHN0cikpICB7XHJcbiAgICBiYXNlID0gODtcclxuICB9IGVsc2Uge1xyXG4gICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgc3RyKTtcclxuICB9XHJcblxyXG4gIC8vIElzIHRoZXJlIGEgYmluYXJ5IGV4cG9uZW50IHBhcnQ/XHJcbiAgaSA9IHN0ci5zZWFyY2goL3AvaSk7XHJcblxyXG4gIGlmIChpID4gMCkge1xyXG4gICAgcCA9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgc3RyID0gc3RyLnN1YnN0cmluZygyLCBpKTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gc3RyLnNsaWNlKDIpO1xyXG4gIH1cclxuXHJcbiAgLy8gQ29udmVydCBgc3RyYCBhcyBhbiBpbnRlZ2VyIHRoZW4gZGl2aWRlIHRoZSByZXN1bHQgYnkgYGJhc2VgIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2ggdGhhdCB0aGVcclxuICAvLyBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcbiAgaSA9IHN0ci5pbmRleE9mKCcuJyk7XHJcbiAgaXNGbG9hdCA9IGkgPj0gMDtcclxuICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgaWYgKGlzRmxvYXQpIHtcclxuICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgbGVuID0gc3RyLmxlbmd0aDtcclxuICAgIGkgPSBsZW4gLSBpO1xyXG5cclxuICAgIC8vIGxvZ1sxMF0oMTYpID0gMS4yMDQxLi4uICwgbG9nWzEwXSg4OCkgPSAxLjk0NDQuLi4uXHJcbiAgICBkaXZpc29yID0gaW50UG93KEN0b3IsIG5ldyBDdG9yKGJhc2UpLCBpLCBpICogMik7XHJcbiAgfVxyXG5cclxuICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XHJcbiAgeGUgPSB4ZC5sZW5ndGggLSAxO1xyXG5cclxuICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpIHhkLnBvcCgpO1xyXG4gIGlmIChpIDwgMCkgcmV0dXJuIG5ldyBDdG9yKHgucyAqIDApO1xyXG4gIHguZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCB4ZSk7XHJcbiAgeC5kID0geGQ7XHJcbiAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgLy8gQXQgd2hhdCBwcmVjaXNpb24gdG8gcGVyZm9ybSB0aGUgZGl2aXNpb24gdG8gZW5zdXJlIGV4YWN0IGNvbnZlcnNpb24/XHJcbiAgLy8gbWF4RGVjaW1hbEludGVnZXJQYXJ0RGlnaXRDb3VudCA9IGNlaWwobG9nWzEwXShiKSAqIG90aGVyQmFzZUludGVnZXJQYXJ0RGlnaXRDb3VudClcclxuICAvLyBsb2dbMTBdKDIpID0gMC4zMDEwMywgbG9nWzEwXSg4KSA9IDAuOTAzMDksIGxvZ1sxMF0oMTYpID0gMS4yMDQxMlxyXG4gIC8vIEUuZy4gY2VpbCgxLjIgKiAzKSA9IDQsIHNvIHVwIHRvIDQgZGVjaW1hbCBkaWdpdHMgYXJlIG5lZWRlZCB0byByZXByZXNlbnQgMyBoZXggaW50IGRpZ2l0cy5cclxuICAvLyBtYXhEZWNpbWFsRnJhY3Rpb25QYXJ0RGlnaXRDb3VudCA9IHtIZXg6NHxPY3Q6M3xCaW46MX0gKiBvdGhlckJhc2VGcmFjdGlvblBhcnREaWdpdENvdW50XHJcbiAgLy8gVGhlcmVmb3JlIHVzaW5nIDQgKiB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiBzdHIgd2lsbCBhbHdheXMgYmUgZW5vdWdoLlxyXG4gIGlmIChpc0Zsb2F0KSB4ID0gZGl2aWRlKHgsIGRpdmlzb3IsIGxlbiAqIDQpO1xyXG5cclxuICAvLyBNdWx0aXBseSBieSB0aGUgYmluYXJ5IGV4cG9uZW50IHBhcnQgaWYgcHJlc2VudC5cclxuICBpZiAocCkgeCA9IHgudGltZXMoTWF0aC5hYnMocCkgPCA1NCA/IG1hdGhwb3coMiwgcCkgOiBEZWNpbWFsLnBvdygyLCBwKSk7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4geDtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICogfHh8IDwgcGkvMlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luZShDdG9yLCB4KSB7XHJcbiAgdmFyIGssXHJcbiAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICBpZiAobGVuIDwgMykge1xyXG4gICAgcmV0dXJuIHguaXNaZXJvKCkgPyB4IDogdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG4gIH1cclxuXHJcbiAgLy8gQXJndW1lbnQgcmVkdWN0aW9uOiBzaW4oNXgpID0gMTYqc2luXjUoeCkgLSAyMCpzaW5eMyh4KSArIDUqc2luKHgpXHJcbiAgLy8gaS5lLiBzaW4oeCkgPSAxNipzaW5eNSh4LzUpIC0gMjAqc2luXjMoeC81KSArIDUqc2luKHgvNSlcclxuICAvLyBhbmQgIHNpbih4KSA9IHNpbih4LzUpKDUgKyBzaW5eMih4LzUpKDE2c2luXjIoeC81KSAtIDIwKSlcclxuXHJcbiAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gIGsgPSAxLjQgKiBNYXRoLnNxcnQobGVuKTtcclxuICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xyXG4gIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMiwgeCwgeCk7XHJcblxyXG4gIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgdmFyIHNpbjJfeCxcclxuICAgIGQ1ID0gbmV3IEN0b3IoNSksXHJcbiAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICBkMjAgPSBuZXcgQ3RvcigyMCk7XHJcbiAgZm9yICg7IGstLTspIHtcclxuICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XHJcbiAgICB4ID0geC50aW1lcyhkNS5wbHVzKHNpbjJfeC50aW1lcyhkMTYudGltZXMoc2luMl94KS5taW51cyhkMjApKSkpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHg7XHJcbn1cclxuXHJcblxyXG4vLyBDYWxjdWxhdGUgVGF5bG9yIHNlcmllcyBmb3IgYGNvc2AsIGBjb3NoYCwgYHNpbmAgYW5kIGBzaW5oYC5cclxuZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xyXG4gIHZhciBqLCB0LCB1LCB4MixcclxuICAgIGkgPSAxLFxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gIHUgPSBuZXcgQ3Rvcih5KTtcclxuXHJcbiAgZm9yICg7Oykge1xyXG4gICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgdSA9IGlzSHlwZXJib2xpYyA/IHkucGx1cyh0KSA6IHkubWludXModCk7XHJcbiAgICB5ID0gZGl2aWRlKHQudGltZXMoeDIpLCBuZXcgQ3RvcihuKysgKiBuKyspLCBwciwgMSk7XHJcbiAgICB0ID0gdS5wbHVzKHkpO1xyXG5cclxuICAgIGlmICh0LmRba10gIT09IHZvaWQgMCkge1xyXG4gICAgICBmb3IgKGogPSBrOyB0LmRbal0gPT09IHUuZFtqXSAmJiBqLS07KTtcclxuICAgICAgaWYgKGogPT0gLTEpIGJyZWFrO1xyXG4gICAgfVxyXG5cclxuICAgIGogPSB1O1xyXG4gICAgdSA9IHk7XHJcbiAgICB5ID0gdDtcclxuICAgIHQgPSBqO1xyXG4gICAgaSsrO1xyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gIHQuZC5sZW5ndGggPSBrICsgMTtcclxuXHJcbiAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcblxyXG4vLyBFeHBvbmVudCBlIG11c3QgYmUgcG9zaXRpdmUgYW5kIG5vbi16ZXJvLlxyXG5mdW5jdGlvbiB0aW55UG93KGIsIGUpIHtcclxuICB2YXIgbiA9IGI7XHJcbiAgd2hpbGUgKC0tZSkgbiAqPSBiO1xyXG4gIHJldHVybiBuO1xyXG59XHJcblxyXG5cclxuLy8gUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAgcmVkdWNlZCB0byBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGFsZiBwaS5cclxuZnVuY3Rpb24gdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSB7XHJcbiAgdmFyIHQsXHJcbiAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICBwaSA9IGdldFBpKEN0b3IsIEN0b3IucHJlY2lzaW9uLCAxKSxcclxuICAgIGhhbGZQaSA9IHBpLnRpbWVzKDAuNSk7XHJcblxyXG4gIHggPSB4LmFicygpO1xyXG5cclxuICBpZiAoeC5sdGUoaGFsZlBpKSkge1xyXG4gICAgcXVhZHJhbnQgPSBpc05lZyA/IDQgOiAxO1xyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuICB0ID0geC5kaXZUb0ludChwaSk7XHJcblxyXG4gIGlmICh0LmlzWmVybygpKSB7XHJcbiAgICBxdWFkcmFudCA9IGlzTmVnID8gMyA6IDI7XHJcbiAgfSBlbHNlIHtcclxuICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcclxuXHJcbiAgICAvLyAwIDw9IHggPCBwaVxyXG4gICAgaWYgKHgubHRlKGhhbGZQaSkpIHtcclxuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDIgOiAzKSA6IChpc05lZyA/IDQgOiAxKTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDEgOiA0KSA6IChpc05lZyA/IDMgOiAyKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB4Lm1pbnVzKHBpKS5hYnMoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiB0aGUgdmFsdWUgb2YgRGVjaW1hbCBgeGAgYXMgYSBzdHJpbmcgaW4gYmFzZSBgYmFzZU91dGAuXHJcbiAqXHJcbiAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgaW5jbHVkZSBhIGJpbmFyeSBleHBvbmVudCBzdWZmaXguXHJcbiAqL1xyXG5mdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcclxuICB2YXIgYmFzZSwgZSwgaSwgaywgbGVuLCByb3VuZFVwLCBzdHIsIHhkLCB5LFxyXG4gICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XHJcblxyXG4gIGlmIChpc0V4cCkge1xyXG4gICAgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICB9XHJcblxyXG4gIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICBzdHIgPSBub25GaW5pdGVUb1N0cmluZyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICBpID0gc3RyLmluZGV4T2YoJy4nKTtcclxuXHJcbiAgICAvLyBVc2UgZXhwb25lbnRpYWwgbm90YXRpb24gYWNjb3JkaW5nIHRvIGB0b0V4cFBvc2AgYW5kIGB0b0V4cE5lZ2A/IE5vLCBidXQgaWYgcmVxdWlyZWQ6XHJcbiAgICAvLyBtYXhCaW5hcnlFeHBvbmVudCA9IGZsb29yKChkZWNpbWFsRXhwb25lbnQgKyAxKSAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBtaW5CaW5hcnlFeHBvbmVudCA9IGZsb29yKGRlY2ltYWxFeHBvbmVudCAqIGxvZ1syXSgxMCkpXHJcbiAgICAvLyBsb2dbMl0oMTApID0gMy4zMjE5MjgwOTQ4ODczNjIzNDc4NzAzMTk0Mjk0ODkzOTAxNzU4NjRcclxuXHJcbiAgICBpZiAoaXNFeHApIHtcclxuICAgICAgYmFzZSA9IDI7XHJcbiAgICAgIGlmIChiYXNlT3V0ID09IDE2KSB7XHJcbiAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKGJhc2VPdXQgPT0gOCkge1xyXG4gICAgICAgIHNkID0gc2QgKiAzIC0gMjtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYmFzZSA9IGJhc2VPdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCB0aGUgbnVtYmVyIGFzIGFuIGludGVnZXIgdGhlbiBkaXZpZGUgdGhlIHJlc3VsdCBieSBpdHMgYmFzZSByYWlzZWQgdG8gYSBwb3dlciBzdWNoXHJcbiAgICAvLyB0aGF0IHRoZSBmcmFjdGlvbiBwYXJ0IHdpbGwgYmUgcmVzdG9yZWQuXHJcblxyXG4gICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICBpZiAoaSA+PSAwKSB7XHJcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgIHkuZSA9IHN0ci5sZW5ndGggLSBpO1xyXG4gICAgICB5LmQgPSBjb252ZXJ0QmFzZShmaW5pdGVUb1N0cmluZyh5KSwgMTAsIGJhc2UpO1xyXG4gICAgICB5LmUgPSB5LmQubGVuZ3RoO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCAxMCwgYmFzZSk7XHJcbiAgICBlID0gbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyB4ZFstLWxlbl0gPT0gMDspIHhkLnBvcCgpO1xyXG5cclxuICAgIGlmICgheGRbMF0pIHtcclxuICAgICAgc3RyID0gaXNFeHAgPyAnMHArMCcgOiAnMCc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBlLS07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgICAgIHguZCA9IHhkO1xyXG4gICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xyXG4gICAgICAgIHhkID0geC5kO1xyXG4gICAgICAgIGUgPSB4LmU7XHJcbiAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSByb3VuZGluZyBkaWdpdCwgaS5lLiB0aGUgZGlnaXQgYWZ0ZXIgdGhlIGRpZ2l0IHRoYXQgbWF5IGJlIHJvdW5kZWQgdXAuXHJcbiAgICAgIGkgPSB4ZFtzZF07XHJcbiAgICAgIGsgPSBiYXNlIC8gMjtcclxuICAgICAgcm91bmRVcCA9IHJvdW5kVXAgfHwgeGRbc2QgKyAxXSAhPT0gdm9pZCAwO1xyXG5cclxuICAgICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICAgID8gKGkgIT09IHZvaWQgMCB8fCByb3VuZFVwKSAmJiAocm0gPT09IDAgfHwgcm0gPT09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgIDogaSA+IGsgfHwgaSA9PT0gayAmJiAocm0gPT09IDQgfHwgcm91bmRVcCB8fCBybSA9PT0gNiAmJiB4ZFtzZCAtIDFdICYgMSB8fFxyXG4gICAgICAgICAgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgIHhkLmxlbmd0aCA9IHNkO1xyXG5cclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICBmb3IgKDsgKyt4ZFstLXNkXSA+IGJhc2UgLSAxOykge1xyXG4gICAgICAgICAgeGRbc2RdID0gMDtcclxuICAgICAgICAgIGlmICghc2QpIHtcclxuICAgICAgICAgICAgKytlO1xyXG4gICAgICAgICAgICB4ZC51bnNoaWZ0KDEpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAvLyBFLmcuIFs0LCAxMSwgMTVdIGJlY29tZXMgNGJmLlxyXG4gICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuXHJcbiAgICAgIC8vIEFkZCBiaW5hcnkgZXhwb25lbnQgc3VmZml4P1xyXG4gICAgICBpZiAoaXNFeHApIHtcclxuICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgaWYgKGJhc2VPdXQgPT0gMTYgfHwgYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICAgIGkgPSBiYXNlT3V0ID09IDE2ID8gNCA6IDM7XHJcbiAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKSBzdHIgKz0gJzAnO1xyXG4gICAgICAgICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgYmFzZU91dCk7XHJcbiAgICAgICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKTtcclxuXHJcbiAgICAgICAgICAgIC8vIHhkWzBdIHdpbGwgYWx3YXlzIGJlIGJlIDFcclxuICAgICAgICAgICAgZm9yIChpID0gMSwgc3RyID0gJzEuJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzdHIgPSAgc3RyICsgKGUgPCAwID8gJ3AnIDogJ3ArJykgKyBlO1xyXG4gICAgICB9IGVsc2UgaWYgKGUgPCAwKSB7XHJcbiAgICAgICAgZm9yICg7ICsrZTspIHN0ciA9ICcwJyArIHN0cjtcclxuICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGlmICgrK2UgPiBsZW4pIGZvciAoZSAtPSBsZW47IGUtLSA7KSBzdHIgKz0gJzAnO1xyXG4gICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gJzB4JyA6IGJhc2VPdXQgPT0gMiA/ICcwYicgOiBiYXNlT3V0ID09IDggPyAnMG8nIDogJycpICsgc3RyO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHgucyA8IDAgPyAnLScgKyBzdHIgOiBzdHI7XHJcbn1cclxuXHJcblxyXG4vLyBEb2VzIG5vdCBzdHJpcCB0cmFpbGluZyB6ZXJvcy5cclxuZnVuY3Rpb24gdHJ1bmNhdGUoYXJyLCBsZW4pIHtcclxuICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xyXG4gICAgYXJyLmxlbmd0aCA9IGxlbjtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxufVxyXG5cclxuXHJcbi8vIERlY2ltYWwgbWV0aG9kc1xyXG5cclxuXHJcbi8qXHJcbiAqICBhYnNcclxuICogIGFjb3NcclxuICogIGFjb3NoXHJcbiAqICBhZGRcclxuICogIGFzaW5cclxuICogIGFzaW5oXHJcbiAqICBhdGFuXHJcbiAqICBhdGFuaFxyXG4gKiAgYXRhbjJcclxuICogIGNicnRcclxuICogIGNlaWxcclxuICogIGNsYW1wXHJcbiAqICBjbG9uZVxyXG4gKiAgY29uZmlnXHJcbiAqICBjb3NcclxuICogIGNvc2hcclxuICogIGRpdlxyXG4gKiAgZXhwXHJcbiAqICBmbG9vclxyXG4gKiAgaHlwb3RcclxuICogIGxuXHJcbiAqICBsb2dcclxuICogIGxvZzJcclxuICogIGxvZzEwXHJcbiAqICBtYXhcclxuICogIG1pblxyXG4gKiAgbW9kXHJcbiAqICBtdWxcclxuICogIHBvd1xyXG4gKiAgcmFuZG9tXHJcbiAqICByb3VuZFxyXG4gKiAgc2V0XHJcbiAqICBzaWduXHJcbiAqICBzaW5cclxuICogIHNpbmhcclxuICogIHNxcnRcclxuICogIHN1YlxyXG4gKiAgc3VtXHJcbiAqICB0YW5cclxuICogIHRhbmhcclxuICogIHRydW5jXHJcbiAqL1xyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhYnMoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hYnMoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNjb3NpbmUgaW4gcmFkaWFucyBvZiBgeGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhY29zKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYWNvcygpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGludmVyc2Ugb2YgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhY29zaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIGB4YCBhbmQgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhZGQoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5wbHVzKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3NpbmUgaW4gcmFkaWFucyBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGFzaW4oeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBhc2luaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmFzaW5oKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCBpbiByYWRpYW5zIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYXRhbih4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmF0YW4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvXHJcbiAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGF0YW5oKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHkveGAgaW4gdGhlIHJhbmdlIC1waSB0byBwaVxyXG4gKiAoaW5jbHVzaXZlKSwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gKiBSYW5nZTogWy1waSwgcGldXHJcbiAqXHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSB5LWNvb3JkaW5hdGUuXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSB4LWNvb3JkaW5hdGUuXHJcbiAqXHJcbiAqIGF0YW4yKMKxMCwgLTApICAgICAgICAgICAgICAgPSDCsXBpXHJcbiAqIGF0YW4yKMKxMCwgKzApICAgICAgICAgICAgICAgPSDCsTBcclxuICogYXRhbjIowrEwLCAteCkgICAgICAgICAgICAgICA9IMKxcGkgZm9yIHggPiAwXHJcbiAqIGF0YW4yKMKxMCwgeCkgICAgICAgICAgICAgICAgPSDCsTAgZm9yIHggPiAwXHJcbiAqIGF0YW4yKC15LCDCsTApICAgICAgICAgICAgICAgPSAtcGkvMiBmb3IgeSA+IDBcclxuICogYXRhbjIoeSwgwrEwKSAgICAgICAgICAgICAgICA9IHBpLzIgZm9yIHkgPiAwXHJcbiAqIGF0YW4yKMKxeSwgLUluZmluaXR5KSAgICAgICAgPSDCsXBpIGZvciBmaW5pdGUgeSA+IDBcclxuICogYXRhbjIowrF5LCArSW5maW5pdHkpICAgICAgICA9IMKxMCBmb3IgZmluaXRlIHkgPiAwXHJcbiAqIGF0YW4yKMKxSW5maW5pdHksIHgpICAgICAgICAgPSDCsXBpLzIgZm9yIGZpbml0ZSB4XHJcbiAqIGF0YW4yKMKxSW5maW5pdHksIC1JbmZpbml0eSkgPSDCsTMqcGkvNFxyXG4gKiBhdGFuMijCsUluZmluaXR5LCArSW5maW5pdHkpID0gwrFwaS80XHJcbiAqIGF0YW4yKE5hTiwgeCkgPSBOYU5cclxuICogYXRhbjIoeSwgTmFOKSA9IE5hTlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gYXRhbjIoeSwgeCkge1xyXG4gIHkgPSBuZXcgdGhpcyh5KTtcclxuICB4ID0gbmV3IHRoaXMoeCk7XHJcbiAgdmFyIHIsXHJcbiAgICBwciA9IHRoaXMucHJlY2lzaW9uLFxyXG4gICAgcm0gPSB0aGlzLnJvdW5kaW5nLFxyXG4gICAgd3ByID0gcHIgKyA0O1xyXG5cclxuICAvLyBFaXRoZXIgTmFOXHJcbiAgaWYgKCF5LnMgfHwgIXgucykge1xyXG4gICAgciA9IG5ldyB0aGlzKE5hTik7XHJcblxyXG4gIC8vIEJvdGggwrFJbmZpbml0eVxyXG4gIH0gZWxzZSBpZiAoIXkuZCAmJiAheC5kKSB7XHJcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xyXG4gICAgci5zID0geS5zO1xyXG5cclxuICAvLyB4IGlzIMKxSW5maW5pdHkgb3IgeSBpcyDCsTBcclxuICB9IGVsc2UgaWYgKCF4LmQgfHwgeS5pc1plcm8oKSkge1xyXG4gICAgciA9IHgucyA8IDAgPyBnZXRQaSh0aGlzLCBwciwgcm0pIDogbmV3IHRoaXMoMCk7XHJcbiAgICByLnMgPSB5LnM7XHJcblxyXG4gIC8vIHkgaXMgwrFJbmZpbml0eSBvciB4IGlzIMKxMFxyXG4gIH0gZWxzZSBpZiAoIXkuZCB8fCB4LmlzWmVybygpKSB7XHJcbiAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcygwLjUpO1xyXG4gICAgci5zID0geS5zO1xyXG5cclxuICAvLyBCb3RoIG5vbi16ZXJvIGFuZCBmaW5pdGVcclxuICB9IGVsc2UgaWYgKHgucyA8IDApIHtcclxuICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xyXG4gICAgdGhpcy5yb3VuZGluZyA9IDE7XHJcbiAgICByID0gdGhpcy5hdGFuKGRpdmlkZSh5LCB4LCB3cHIsIDEpKTtcclxuICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xyXG4gICAgdGhpcy5wcmVjaXNpb24gPSBwcjtcclxuICAgIHRoaXMucm91bmRpbmcgPSBybTtcclxuICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcclxuICB9IGVsc2Uge1xyXG4gICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcjtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBjdWJlIHJvb3Qgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjYnJ0KHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY2JydCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJvdW5kZWQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfQ0VJTGAuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjZWlsKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAyKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBjbGFtcGVkIHRvIHRoZSByYW5nZSBkZWxpbmVhdGVkIGJ5IGBtaW5gIGFuZCBgbWF4YC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICogbWluIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKiBtYXgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5jbGFtcChtaW4sIG1heCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBDb25maWd1cmUgZ2xvYmFsIHNldHRpbmdzIGZvciBhIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbiAqXHJcbiAqIGBvYmpgIGlzIGFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyxcclxuICpcclxuICogICBwcmVjaXNpb24gIHtudW1iZXJ9XHJcbiAqICAgcm91bmRpbmcgICB7bnVtYmVyfVxyXG4gKiAgIHRvRXhwTmVnICAge251bWJlcn1cclxuICogICB0b0V4cFBvcyAgIHtudW1iZXJ9XHJcbiAqICAgbWF4RSAgICAgICB7bnVtYmVyfVxyXG4gKiAgIG1pbkUgICAgICAge251bWJlcn1cclxuICogICBtb2R1bG8gICAgIHtudW1iZXJ9XHJcbiAqICAgY3J5cHRvICAgICB7Ym9vbGVhbnxudW1iZXJ9XHJcbiAqICAgZGVmYXVsdHMgICB7dHJ1ZX1cclxuICpcclxuICogRS5nLiBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAsIHJvdW5kaW5nOiA0IH0pXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb25maWcob2JqKSB7XHJcbiAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHRocm93IEVycm9yKGRlY2ltYWxFcnJvciArICdPYmplY3QgZXhwZWN0ZWQnKTtcclxuICB2YXIgaSwgcCwgdixcclxuICAgIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLFxyXG4gICAgcHMgPSBbXHJcbiAgICAgICdwcmVjaXNpb24nLCAxLCBNQVhfRElHSVRTLFxyXG4gICAgICAncm91bmRpbmcnLCAwLCA4LFxyXG4gICAgICAndG9FeHBOZWcnLCAtRVhQX0xJTUlULCAwLFxyXG4gICAgICAndG9FeHBQb3MnLCAwLCBFWFBfTElNSVQsXHJcbiAgICAgICdtYXhFJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAnbWluRScsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICdtb2R1bG8nLCAwLCA5XHJcbiAgICBdO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICs9IDMpIHtcclxuICAgIGlmIChwID0gcHNbaV0sIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XHJcbiAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgICAgaWYgKG1hdGhmbG9vcih2KSA9PT0gdiAmJiB2ID49IHBzW2kgKyAxXSAmJiB2IDw9IHBzW2kgKyAyXSkgdGhpc1twXSA9IHY7XHJcbiAgICAgIGVsc2UgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArICc6ICcgKyB2KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGlmIChwID0gJ2NyeXB0bycsIHVzZURlZmF1bHRzKSB0aGlzW3BdID0gREVGQVVMVFNbcF07XHJcbiAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XHJcbiAgICBpZiAodiA9PT0gdHJ1ZSB8fCB2ID09PSBmYWxzZSB8fCB2ID09PSAwIHx8IHYgPT09IDEpIHtcclxuICAgICAgaWYgKHYpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgIChjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHx8IGNyeXB0by5yYW5kb21CeXRlcykpIHtcclxuICAgICAgICAgIHRoaXNbcF0gPSB0cnVlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXNbcF0gPSBmYWxzZTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgcCArICc6ICcgKyB2KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gY29zKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgYHhgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBjb3NoKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuY29zaCgpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBEZWNpbWFsIGNvbnN0cnVjdG9yIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFzIHRoaXMgRGVjaW1hbFxyXG4gKiBjb25zdHJ1Y3Rvci5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGNsb25lKG9iaikge1xyXG4gIHZhciBpLCBwLCBwcztcclxuXHJcbiAgLypcclxuICAgKiBUaGUgRGVjaW1hbCBjb25zdHJ1Y3RvciBhbmQgZXhwb3J0ZWQgZnVuY3Rpb24uXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgaW5zdGFuY2UuXHJcbiAgICpcclxuICAgKiB2IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIG51bWVyaWMgdmFsdWUuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBEZWNpbWFsKHYpIHtcclxuICAgIHZhciBlLCBpLCB0LFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAvLyBEZWNpbWFsIGNhbGxlZCB3aXRob3V0IG5ldy5cclxuICAgIGlmICghKHggaW5zdGFuY2VvZiBEZWNpbWFsKSkgcmV0dXJuIG5ldyBEZWNpbWFsKHYpO1xyXG5cclxuICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIERlY2ltYWwgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgRGVjaW1hbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgIC8vIHdoaWNoIHBvaW50cyB0byBPYmplY3QuXHJcbiAgICB4LmNvbnN0cnVjdG9yID0gRGVjaW1hbDtcclxuXHJcbiAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcclxuICAgICAgeC5zID0gdi5zO1xyXG5cclxuICAgICAgaWYgKGV4dGVybmFsKSB7XHJcbiAgICAgICAgaWYgKCF2LmQgfHwgdi5lID4gRGVjaW1hbC5tYXhFKSB7XHJcblxyXG4gICAgICAgICAgLy8gSW5maW5pdHkuXHJcbiAgICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgIH0gZWxzZSBpZiAodi5lIDwgRGVjaW1hbC5taW5FKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguZCA9IHYuZC5zbGljZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4LmUgPSB2LmU7XHJcbiAgICAgICAgeC5kID0gdi5kID8gdi5kLnNsaWNlKCkgOiB2LmQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICB0ID0gdHlwZW9mIHY7XHJcblxyXG4gICAgaWYgKHQgPT09ICdudW1iZXInKSB7XHJcbiAgICAgIGlmICh2ID09PSAwKSB7XHJcbiAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgdiA9IC12O1xyXG4gICAgICAgIHgucyA9IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgucyA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igc21hbGwgaW50ZWdlcnMuXHJcbiAgICAgIGlmICh2ID09PSB+fnYgJiYgdiA8IDFlNykge1xyXG4gICAgICAgIGZvciAoZSA9IDAsIGkgPSB2OyBpID49IDEwOyBpIC89IDEwKSBlKys7XHJcblxyXG4gICAgICAgIGlmIChleHRlcm5hbCkge1xyXG4gICAgICAgICAgaWYgKGUgPiBEZWNpbWFsLm1heEUpIHtcclxuICAgICAgICAgICAgeC5lID0gTmFOO1xyXG4gICAgICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChlIDwgRGVjaW1hbC5taW5FKSB7XHJcbiAgICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSW5maW5pdHkgb3IgTmFOP1xyXG4gICAgICBpZiAodiAqIDAgIT09IDApIHtcclxuICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcclxuICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgaWYgKChpID0gdi5jaGFyQ29kZUF0KDApKSA9PT0gNDUpIHsgIC8vIG1pbnVzIHNpZ25cclxuICAgICAgICB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaSA9PT0gNDMpIHYgPSB2LnNsaWNlKDEpOyAgLy8gcGx1cyBzaWduXHJcbiAgICAgICAgeC5zID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodCA9PT0gJ2JpZ2ludCcpIHtcclxuICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgdiA9IC12O1xyXG4gICAgICAgIHgucyA9IC0xO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHgucyA9IDE7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyB2KTtcclxuICB9XHJcblxyXG4gIERlY2ltYWwucHJvdG90eXBlID0gUDtcclxuXHJcbiAgRGVjaW1hbC5ST1VORF9VUCA9IDA7XHJcbiAgRGVjaW1hbC5ST1VORF9ET1dOID0gMTtcclxuICBEZWNpbWFsLlJPVU5EX0NFSUwgPSAyO1xyXG4gIERlY2ltYWwuUk9VTkRfRkxPT1IgPSAzO1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0RPV04gPSA1O1xyXG4gIERlY2ltYWwuUk9VTkRfSEFMRl9FVkVOID0gNjtcclxuICBEZWNpbWFsLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgRGVjaW1hbC5ST1VORF9IQUxGX0ZMT09SID0gODtcclxuICBEZWNpbWFsLkVVQ0xJRCA9IDk7XHJcblxyXG4gIERlY2ltYWwuY29uZmlnID0gRGVjaW1hbC5zZXQgPSBjb25maWc7XHJcbiAgRGVjaW1hbC5jbG9uZSA9IGNsb25lO1xyXG4gIERlY2ltYWwuaXNEZWNpbWFsID0gaXNEZWNpbWFsSW5zdGFuY2U7XHJcblxyXG4gIERlY2ltYWwuYWJzID0gYWJzO1xyXG4gIERlY2ltYWwuYWNvcyA9IGFjb3M7XHJcbiAgRGVjaW1hbC5hY29zaCA9IGFjb3NoOyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5hZGQgPSBhZGQ7XHJcbiAgRGVjaW1hbC5hc2luID0gYXNpbjtcclxuICBEZWNpbWFsLmFzaW5oID0gYXNpbmg7ICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmF0YW4gPSBhdGFuO1xyXG4gIERlY2ltYWwuYXRhbmggPSBhdGFuaDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwuYXRhbjIgPSBhdGFuMjtcclxuICBEZWNpbWFsLmNicnQgPSBjYnJ0OyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmNlaWwgPSBjZWlsO1xyXG4gIERlY2ltYWwuY2xhbXAgPSBjbGFtcDtcclxuICBEZWNpbWFsLmNvcyA9IGNvcztcclxuICBEZWNpbWFsLmNvc2ggPSBjb3NoOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLmRpdiA9IGRpdjtcclxuICBEZWNpbWFsLmV4cCA9IGV4cDtcclxuICBEZWNpbWFsLmZsb29yID0gZmxvb3I7XHJcbiAgRGVjaW1hbC5oeXBvdCA9IGh5cG90OyAgICAgICAgLy8gRVM2XHJcbiAgRGVjaW1hbC5sbiA9IGxuO1xyXG4gIERlY2ltYWwubG9nID0gbG9nO1xyXG4gIERlY2ltYWwubG9nMTAgPSBsb2cxMDsgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwubG9nMiA9IGxvZzI7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwubWF4ID0gbWF4O1xyXG4gIERlY2ltYWwubWluID0gbWluO1xyXG4gIERlY2ltYWwubW9kID0gbW9kO1xyXG4gIERlY2ltYWwubXVsID0gbXVsO1xyXG4gIERlY2ltYWwucG93ID0gcG93O1xyXG4gIERlY2ltYWwucmFuZG9tID0gcmFuZG9tO1xyXG4gIERlY2ltYWwucm91bmQgPSByb3VuZDtcclxuICBEZWNpbWFsLnNpZ24gPSBzaWduOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLnNpbiA9IHNpbjtcclxuICBEZWNpbWFsLnNpbmggPSBzaW5oOyAgICAgICAgICAvLyBFUzZcclxuICBEZWNpbWFsLnNxcnQgPSBzcXJ0O1xyXG4gIERlY2ltYWwuc3ViID0gc3ViO1xyXG4gIERlY2ltYWwuc3VtID0gc3VtO1xyXG4gIERlY2ltYWwudGFuID0gdGFuO1xyXG4gIERlY2ltYWwudGFuaCA9IHRhbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gIERlY2ltYWwudHJ1bmMgPSB0cnVuYzsgICAgICAgIC8vIEVTNlxyXG5cclxuICBpZiAob2JqID09PSB2b2lkIDApIG9iaiA9IHt9O1xyXG4gIGlmIChvYmopIHtcclxuICAgIGlmIChvYmouZGVmYXVsdHMgIT09IHRydWUpIHtcclxuICAgICAgcHMgPSBbJ3ByZWNpc2lvbicsICdyb3VuZGluZycsICd0b0V4cE5lZycsICd0b0V4cFBvcycsICdtYXhFJywgJ21pbkUnLCAnbW9kdWxvJywgJ2NyeXB0byddO1xyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOykgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgRGVjaW1hbC5jb25maWcob2JqKTtcclxuXHJcbiAgcmV0dXJuIERlY2ltYWw7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgZGl2aWRlZCBieSBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGRpdih4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhlIGJhc2Ugb2YgdGhlIG5hdHVyYWwgbG9nLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZXhwKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkuZXhwKCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmQgdG8gYW4gaW50ZWdlciB1c2luZyBgUk9VTkRfRkxPT1JgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gZmxvb3IoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDMpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoZSBzdW0gb2YgdGhlIHNxdWFyZXMgb2YgdGhlIGFyZ3VtZW50cyxcclxuICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBoeXBvdChhLCBiLCAuLi4pID0gc3FydChhXjIgKyBiXjIgKyAuLi4pXHJcbiAqXHJcbiAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGh5cG90KCkge1xyXG4gIHZhciBpLCBuLFxyXG4gICAgdCA9IG5ldyB0aGlzKDApO1xyXG5cclxuICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICBmb3IgKGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDspIHtcclxuICAgIG4gPSBuZXcgdGhpcyhhcmd1bWVudHNbaSsrXSk7XHJcbiAgICBpZiAoIW4uZCkge1xyXG4gICAgICBpZiAobi5zKSB7XHJcbiAgICAgICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBuZXcgdGhpcygxIC8gMCk7XHJcbiAgICAgIH1cclxuICAgICAgdCA9IG47XHJcbiAgICB9IGVsc2UgaWYgKHQuZCkge1xyXG4gICAgICB0ID0gdC5wbHVzKG4udGltZXMobikpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gdC5zcXJ0KCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gdHJ1ZSBpZiBvYmplY3QgaXMgYSBEZWNpbWFsIGluc3RhbmNlICh3aGVyZSBEZWNpbWFsIGlzIGFueSBEZWNpbWFsIGNvbnN0cnVjdG9yKSxcclxuICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xyXG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBEZWNpbWFsIHx8IG9iaiAmJiBvYmoudG9TdHJpbmdUYWcgPT09IHRhZyB8fCBmYWxzZTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGxuKHgpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubG4oKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBsb2cgb2YgYHhgIHRvIHRoZSBiYXNlIGB5YCwgb3IgdG8gYmFzZSAxMCBpZiBubyBiYXNlXHJcbiAqIGlzIHNwZWNpZmllZCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiBsb2dbeV0oeClcclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gVGhlIGFyZ3VtZW50IG9mIHRoZSBsb2dhcml0aG0uXHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSBiYXNlIG9mIHRoZSBsb2dhcml0aG0uXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2coeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAyIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMik7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAxMCBsb2dhcml0aG0gb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBsb2cxMCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygxMCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWF4aW11bSBvZiB0aGUgYXJndW1lbnRzLlxyXG4gKlxyXG4gKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBtYXgoKSB7XHJcbiAgcmV0dXJuIG1heE9yTWluKHRoaXMsIGFyZ3VtZW50cywgLTEpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1pbmltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbWluKCkge1xyXG4gIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIDEpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG1vZHVsbyBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIG1vZCh4LCB5KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLm1vZCh5KTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtdWx0aXBsaWVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKiB5IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gbXVsKHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJhaXNlZCB0byB0aGUgcG93ZXIgYHlgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgYmFzZS5cclxuICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gVGhlIGV4cG9uZW50LlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcG93KHgsIHkpIHtcclxuICByZXR1cm4gbmV3IHRoaXMoeCkucG93KHkpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJucyBhIG5ldyBEZWNpbWFsIHdpdGggYSByYW5kb20gdmFsdWUgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuIDAgYW5kIGxlc3MgdGhhbiAxLCBhbmQgd2l0aFxyXG4gKiBgc2RgLCBvciBgRGVjaW1hbC5wcmVjaXNpb25gIGlmIGBzZGAgaXMgb21pdHRlZCwgc2lnbmlmaWNhbnQgZGlnaXRzIChvciBsZXNzIGlmIHRyYWlsaW5nIHplcm9zXHJcbiAqIGFyZSBwcm9kdWNlZCkuXHJcbiAqXHJcbiAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcmFuZG9tKHNkKSB7XHJcbiAgdmFyIGQsIGUsIGssIG4sXHJcbiAgICBpID0gMCxcclxuICAgIHIgPSBuZXcgdGhpcygxKSxcclxuICAgIHJkID0gW107XHJcblxyXG4gIGlmIChzZCA9PT0gdm9pZCAwKSBzZCA9IHRoaXMucHJlY2lzaW9uO1xyXG4gIGVsc2UgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gIGsgPSBNYXRoLmNlaWwoc2QgLyBMT0dfQkFTRSk7XHJcblxyXG4gIGlmICghdGhpcy5jcnlwdG8pIHtcclxuICAgIGZvciAoOyBpIDwgazspIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcclxuXHJcbiAgLy8gQnJvd3NlcnMgc3VwcG9ydGluZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLlxyXG4gIH0gZWxzZSBpZiAoY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xyXG4gICAgZCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGspKTtcclxuXHJcbiAgICBmb3IgKDsgaSA8IGs7KSB7XHJcbiAgICAgIG4gPSBkW2ldO1xyXG5cclxuICAgICAgLy8gMCA8PSBuIDwgNDI5NDk2NzI5NlxyXG4gICAgICAvLyBQcm9iYWJpbGl0eSBuID49IDQuMjllOSwgaXMgNDk2NzI5NiAvIDQyOTQ5NjcyOTYgPSAwLjAwMTE2ICgxIGluIDg2NSkuXHJcbiAgICAgIGlmIChuID49IDQuMjllOSkge1xyXG4gICAgICAgIGRbaV0gPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIDAgPD0gbiA8PSA0Mjg5OTk5OTk5XHJcbiAgICAgICAgLy8gMCA8PSAobiAlIDFlNykgPD0gOTk5OTk5OVxyXG4gICAgICAgIHJkW2krK10gPSBuICUgMWU3O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gIC8vIE5vZGUuanMgc3VwcG9ydGluZyBjcnlwdG8ucmFuZG9tQnl0ZXMuXHJcbiAgfSBlbHNlIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcclxuXHJcbiAgICAvLyBidWZmZXJcclxuICAgIGQgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoayAqPSA0KTtcclxuXHJcbiAgICBmb3IgKDsgaSA8IGs7KSB7XHJcblxyXG4gICAgICAvLyAwIDw9IG4gPCAyMTQ3NDgzNjQ4XHJcbiAgICAgIG4gPSBkW2ldICsgKGRbaSArIDFdIDw8IDgpICsgKGRbaSArIDJdIDw8IDE2KSArICgoZFtpICsgM10gJiAweDdmKSA8PCAyNCk7XHJcblxyXG4gICAgICAvLyBQcm9iYWJpbGl0eSBuID49IDIuMTRlOSwgaXMgNzQ4MzY0OCAvIDIxNDc0ODM2NDggPSAwLjAwMzUgKDEgaW4gMjg2KS5cclxuICAgICAgaWYgKG4gPj0gMi4xNGU5KSB7XHJcbiAgICAgICAgY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLmNvcHkoZCwgaSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIC8vIDAgPD0gbiA8PSAyMTM5OTk5OTk5XHJcbiAgICAgICAgLy8gMCA8PSAobiAlIDFlNykgPD0gOTk5OTk5OVxyXG4gICAgICAgIHJkLnB1c2gobiAlIDFlNyk7XHJcbiAgICAgICAgaSArPSA0O1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaSA9IGsgLyA0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBFcnJvcihjcnlwdG9VbmF2YWlsYWJsZSk7XHJcbiAgfVxyXG5cclxuICBrID0gcmRbLS1pXTtcclxuICBzZCAlPSBMT0dfQkFTRTtcclxuXHJcbiAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIHNkLlxyXG4gIGlmIChrICYmIHNkKSB7XHJcbiAgICBuID0gbWF0aHBvdygxMCwgTE9HX0JBU0UgLSBzZCk7XHJcbiAgICByZFtpXSA9IChrIC8gbiB8IDApICogbjtcclxuICB9XHJcblxyXG4gIC8vIFJlbW92ZSB0cmFpbGluZyB3b3JkcyB3aGljaCBhcmUgemVyby5cclxuICBmb3IgKDsgcmRbaV0gPT09IDA7IGktLSkgcmQucG9wKCk7XHJcblxyXG4gIC8vIFplcm8/XHJcbiAgaWYgKGkgPCAwKSB7XHJcbiAgICBlID0gMDtcclxuICAgIHJkID0gWzBdO1xyXG4gIH0gZWxzZSB7XHJcbiAgICBlID0gLTE7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgd29yZHMgd2hpY2ggYXJlIHplcm8gYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgIGZvciAoOyByZFswXSA9PT0gMDsgZSAtPSBMT0dfQkFTRSkgcmQuc2hpZnQoKTtcclxuXHJcbiAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHJkIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgZm9yIChrID0gMSwgbiA9IHJkWzBdOyBuID49IDEwOyBuIC89IDEwKSBrKys7XHJcblxyXG4gICAgLy8gQWRqdXN0IHRoZSBleHBvbmVudCBmb3IgbGVhZGluZyB6ZXJvcyBvZiB0aGUgZmlyc3Qgd29yZCBvZiByZC5cclxuICAgIGlmIChrIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBrO1xyXG4gIH1cclxuXHJcbiAgci5lID0gZTtcclxuICByLmQgPSByZDtcclxuXHJcbiAgcmV0dXJuIHI7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgcm91bmRlZCB0byBhbiBpbnRlZ2VyIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogVG8gZW11bGF0ZSBgTWF0aC5yb3VuZGAsIHNldCByb3VuZGluZyB0byA3IChST1VORF9IQUxGX0NFSUwpLlxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gcm91bmQoeCkge1xyXG4gIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuXHJcbiAqICAgMSAgICBpZiB4ID4gMCxcclxuICogIC0xICAgIGlmIHggPCAwLFxyXG4gKiAgIDAgICAgaWYgeCBpcyAwLFxyXG4gKiAgLTAgICAgaWYgeCBpcyAtMCxcclxuICogICBOYU4gIG90aGVyd2lzZVxyXG4gKlxyXG4gKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2lnbih4KSB7XHJcbiAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gIHJldHVybiB4LmQgPyAoeC5kWzBdID8geC5zIDogMCAqIHgucykgOiB4LnMgfHwgTmFOO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNpbih4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgc2luZSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc2luaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnNpbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBzcXVhcmUgcm9vdCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHNxcnQoeCkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gKiB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdWIoeCwgeSkge1xyXG4gIHJldHVybiBuZXcgdGhpcyh4KS5zdWIoeSk7XHJcbn1cclxuXHJcblxyXG4vKlxyXG4gKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIHRoZSBhcmd1bWVudHMsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogT25seSB0aGUgcmVzdWx0IGlzIHJvdW5kZWQsIG5vdCB0aGUgaW50ZXJtZWRpYXRlIGNhbGN1bGF0aW9ucy5cclxuICpcclxuICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gc3VtKCkge1xyXG4gIHZhciBpID0gMCxcclxuICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICB4ID0gbmV3IHRoaXMoYXJnc1tpXSk7XHJcblxyXG4gIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgZm9yICg7IHgucyAmJiArK2kgPCBhcmdzLmxlbmd0aDspIHggPSB4LnBsdXMoYXJnc1tpXSk7XHJcbiAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICByZXR1cm4gZmluYWxpc2UoeCwgdGhpcy5wcmVjaXNpb24sIHRoaXMucm91bmRpbmcpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAqXHJcbiAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRhbih4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbigpO1xyXG59XHJcblxyXG5cclxuLypcclxuICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gKlxyXG4gKi9cclxuZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbmgoKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCB0cnVuY2F0ZWQgdG8gYW4gaW50ZWdlci5cclxuICpcclxuICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICpcclxuICovXHJcbmZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICByZXR1cm4gZmluYWxpc2UoeCA9IG5ldyB0aGlzKHgpLCB4LmUgKyAxLCAxKTtcclxufVxyXG5cclxuXHJcblBbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBQLnRvU3RyaW5nO1xyXG5QW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnRGVjaW1hbCc7XHJcblxyXG4vLyBDcmVhdGUgYW5kIGNvbmZpZ3VyZSBpbml0aWFsIERlY2ltYWwgY29uc3RydWN0b3IuXHJcbmV4cG9ydCB2YXIgRGVjaW1hbCA9IFAuY29uc3RydWN0b3IgPSBjbG9uZShERUZBVUxUUyk7XHJcblxyXG4vLyBDcmVhdGUgdGhlIGludGVybmFsIGNvbnN0YW50cyBmcm9tIHRoZWlyIHN0cmluZyB2YWx1ZXMuXHJcbkxOMTAgPSBuZXcgRGVjaW1hbChMTjEwKTtcclxuUEkgPSBuZXcgRGVjaW1hbChQSSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZWNpbWFsO1xyXG4iXSwibmFtZXMiOlsiRVhQX0xJTUlUIiwiTUFYX0RJR0lUUyIsIk5VTUVSQUxTIiwiTE4xMCIsIlBJIiwiREVGQVVMVFMiLCJwcmVjaXNpb24iLCJyb3VuZGluZyIsIm1vZHVsbyIsInRvRXhwTmVnIiwidG9FeHBQb3MiLCJtaW5FIiwibWF4RSIsImNyeXB0byIsImluZXhhY3QiLCJxdWFkcmFudCIsImV4dGVybmFsIiwiZGVjaW1hbEVycm9yIiwiaW52YWxpZEFyZ3VtZW50IiwicHJlY2lzaW9uTGltaXRFeGNlZWRlZCIsImNyeXB0b1VuYXZhaWxhYmxlIiwidGFnIiwibWF0aGZsb29yIiwiTWF0aCIsImZsb29yIiwibWF0aHBvdyIsInBvdyIsImlzQmluYXJ5IiwiaXNIZXgiLCJpc09jdGFsIiwiaXNEZWNpbWFsIiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX1NBRkVfSU5URUdFUiIsIkxOMTBfUFJFQ0lTSU9OIiwibGVuZ3RoIiwiUElfUFJFQ0lTSU9OIiwiUCIsInRvU3RyaW5nVGFnIiwiYWJzb2x1dGVWYWx1ZSIsImFicyIsIngiLCJjb25zdHJ1Y3RvciIsInMiLCJmaW5hbGlzZSIsImNlaWwiLCJlIiwiY2xhbXBlZFRvIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJrIiwiQ3RvciIsIk5hTiIsImd0IiwiRXJyb3IiLCJjbXAiLCJjb21wYXJlZFRvIiwieSIsImkiLCJqIiwieGRMIiwieWRMIiwieGQiLCJkIiwieWQiLCJ4cyIsInlzIiwiY29zaW5lIiwiY29zIiwicHIiLCJybSIsInNkIiwidG9MZXNzVGhhbkhhbGZQaSIsIm5lZyIsImN1YmVSb290IiwiY2JydCIsIm0iLCJuIiwiciIsInJlcCIsInQiLCJ0MyIsInQzcGx1c3giLCJpc0Zpbml0ZSIsImlzWmVybyIsImRpZ2l0c1RvU3RyaW5nIiwidG9FeHBvbmVudGlhbCIsInNsaWNlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwidGltZXMiLCJwbHVzIiwiZGl2aWRlIiwiZXEiLCJjaGFyQXQiLCJkZWNpbWFsUGxhY2VzIiwiZHAiLCJ3IiwiZGl2aWRlZEJ5IiwiZGl2IiwiZGl2aWRlZFRvSW50ZWdlckJ5IiwiZGl2VG9JbnQiLCJlcXVhbHMiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaHlwZXJib2xpY0Nvc2luZSIsImNvc2giLCJsZW4iLCJvbmUiLCJ0aW55UG93IiwidGF5bG9yU2VyaWVzIiwiY29zaDJfeCIsImQ4IiwibWludXMiLCJoeXBlcmJvbGljU2luZSIsInNpbmgiLCJzcXJ0Iiwic2luaDJfeCIsImQ1IiwiZDE2IiwiZDIwIiwiaHlwZXJib2xpY1RhbmdlbnQiLCJ0YW5oIiwiaW52ZXJzZUNvc2luZSIsImFjb3MiLCJpc05lZyIsImdldFBpIiwiYXRhbiIsImludmVyc2VIeXBlcmJvbGljQ29zaW5lIiwiYWNvc2giLCJsdGUiLCJsbiIsImludmVyc2VIeXBlcmJvbGljU2luZSIsImFzaW5oIiwiaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50IiwiYXRhbmgiLCJ3cHIiLCJ4c2QiLCJpbnZlcnNlU2luZSIsImFzaW4iLCJoYWxmUGkiLCJpbnZlcnNlVGFuZ2VudCIsInB4IiwieDIiLCJpc0ludGVnZXIiLCJpc0ludCIsImlzTmFOIiwiaXNOZWdhdGl2ZSIsImlzUG9zaXRpdmUiLCJpc1BvcyIsImxlc3NUaGFuIiwibHQiLCJsZXNzVGhhbk9yRXF1YWxUbyIsImxvZ2FyaXRobSIsImxvZyIsImJhc2UiLCJpc0Jhc2UxMCIsImRlbm9taW5hdG9yIiwiaW5mIiwibnVtIiwiYXJnIiwiZ3VhcmQiLCJuYXR1cmFsTG9nYXJpdGhtIiwiZ2V0TG4xMCIsImNoZWNrUm91bmRpbmdEaWdpdHMiLCJzdWIiLCJ4ZSIsInhMVHkiLCJyZXZlcnNlIiwicHVzaCIsInBvcCIsInNoaWZ0IiwiZ2V0QmFzZTEwRXhwb25lbnQiLCJtb2QiLCJxIiwibmF0dXJhbEV4cG9uZW50aWFsIiwiZXhwIiwibmVnYXRlZCIsImFkZCIsImNhcnJ5IiwidW5zaGlmdCIsInoiLCJnZXRQcmVjaXNpb24iLCJyb3VuZCIsInNpbmUiLCJzaW4iLCJzcXVhcmVSb290IiwidGFuZ2VudCIsInRhbiIsIm11bCIsInJMIiwidG9CaW5hcnkiLCJ0b1N0cmluZ0JpbmFyeSIsInRvRGVjaW1hbFBsYWNlcyIsInRvRFAiLCJjaGVja0ludDMyIiwic3RyIiwiZmluaXRlVG9TdHJpbmciLCJ0b0ZpeGVkIiwidG9GcmFjdGlvbiIsIm1heEQiLCJkMCIsImQxIiwiZDIiLCJuMCIsIm4xIiwidG9IZXhhZGVjaW1hbCIsInRvSGV4IiwidG9OZWFyZXN0IiwidG9OdW1iZXIiLCJ0b09jdGFsIiwidG9Qb3dlciIsInluIiwiaW50UG93IiwidG9QcmVjaXNpb24iLCJ0b1NpZ25pZmljYW50RGlnaXRzIiwidG9TRCIsInRydW5jYXRlZCIsInRydW5jIiwidmFsdWVPZiIsInRvSlNPTiIsIndzIiwiaW5kZXhPZkxhc3RXb3JkIiwiZ2V0WmVyb1N0cmluZyIsInJlcGVhdGluZyIsImRpIiwicmQiLCJjb252ZXJ0QmFzZSIsImJhc2VJbiIsImJhc2VPdXQiLCJhcnIiLCJhcnJMIiwic3RyTCIsImNvczJ4IiwibXVsdGlwbHlJbnRlZ2VyIiwidGVtcCIsImNvbXBhcmUiLCJhIiwiYiIsImFMIiwiYkwiLCJzdWJ0cmFjdCIsImxvZ0Jhc2UiLCJtb3JlIiwicHJvZCIsInByb2RMIiwicWQiLCJyZW0iLCJyZW1MIiwicmVtMCIsInhpIiwieEwiLCJ5ZDAiLCJ5TCIsInl6Iiwic2lnbiIsImlzVHJ1bmNhdGVkIiwiZGlnaXRzIiwicm91bmRVcCIsInhkaSIsIm91dCIsImlzRXhwIiwibm9uRmluaXRlVG9TdHJpbmciLCJ6cyIsInRydW5jYXRlIiwiaXNPZGQiLCJtYXhPck1pbiIsImFyZ3MiLCJzdW0iLCJjIiwiYzAiLCJudW1lcmF0b3IiLCJ4MSIsIlN0cmluZyIsInBhcnNlRGVjaW1hbCIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJjaGFyQ29kZUF0IiwicGFyc2VPdGhlciIsImRpdmlzb3IiLCJpc0Zsb2F0IiwicCIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsIkRlY2ltYWwiLCJzaW4yX3giLCJpc0h5cGVyYm9saWMiLCJ1IiwicGkiLCJhdGFuMiIsImNvbmZpZyIsIm9iaiIsInYiLCJ1c2VEZWZhdWx0cyIsImRlZmF1bHRzIiwicHMiLCJnZXRSYW5kb21WYWx1ZXMiLCJyYW5kb21CeXRlcyIsImNsb25lIiwiaXNEZWNpbWFsSW5zdGFuY2UiLCJwcm90b3R5cGUiLCJST1VORF9VUCIsIlJPVU5EX0RPV04iLCJST1VORF9DRUlMIiwiUk9VTkRfRkxPT1IiLCJST1VORF9IQUxGX1VQIiwiUk9VTkRfSEFMRl9ET1dOIiwiUk9VTkRfSEFMRl9FVkVOIiwiUk9VTkRfSEFMRl9DRUlMIiwiUk9VTkRfSEFMRl9GTE9PUiIsIkVVQ0xJRCIsInNldCIsImh5cG90IiwibG9nMTAiLCJsb2cyIiwicmFuZG9tIiwiaGFzT3duUHJvcGVydHkiLCJhcmd1bWVudHMiLCJVaW50MzJBcnJheSIsImNvcHkiLCJTeW1ib2wiLCJmb3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/decimal.js@10.6.0/node_modules/decimal.js/decimal.mjs\n");

/***/ })

};
;